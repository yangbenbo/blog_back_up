---
title: 多线程
date: 2020-11-14 21:07:02
categories:
- program
tags:
- 多线程
---

## c++ 使用线程注意事项
1. 限定符避免编译器优化
    {% post_link c++记录 参考限定符部分 %},不过没用好像也没什么问题   
     
        // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值)
        volatile int val;
2. 锁同一个对象需要同一个锁,如全局变量或类对象        
        
        std::mutex mut  
        //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁
        lock_guard<mutex> lock (mut);  
3. sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长
    
        std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        
4. 线程销毁 
    - thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常
    - thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达--这是两个独立的事情.
    - 执行到析构函数时要么join,要么detach线程


## 引用
1. [C++11：多线程与锁](https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)
2. [C++11中std::mutex的使用](https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf)
3. [thread中join和detach的区别](https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf)