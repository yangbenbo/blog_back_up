{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weizhuang.jpg","path":"img/weizhuang.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"source/img/weiZhuang.png","path":"img/weiZhuang.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/weiZhuang.png","path":"img/weiZhuang.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/jun.jpg","path":"img/jun.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/README.md","hash":"f93b538bb1eab4bef32ed007af271e99b05a9597","modified":1600872120884},{"_id":"themes/3-hexo/_config.yml","hash":"1b8eaa67f3618523a289df79cee66a770462aebd","modified":1606121019338},{"_id":"source/_posts/FTP配置和使用.md","hash":"a6a61ba89034fdfa7285c0c6bb3546ffeb4445cd","modified":1600872120840},{"_id":"source/_posts/Github-SSH-Key避免Hexo部署输入密码.md","hash":"c50c20168fa225c89ca4068c093f16a2e19904cd","modified":1600872120840},{"_id":"source/_posts/Linux-正则表达式.md","hash":"792562f974467fd95a71fb7f7b4ed52f88027da0","modified":1600872120840},{"_id":"source/_posts/Linux进程管理.md","hash":"697cf98a88837db9e2894c2af8e638b0fc4b292d","modified":1600872120844},{"_id":"source/_posts/Linux-Qt5-ROS配置Qwtplot3d.md","hash":"3cc698c4245a064792bd5579a02213eeb3b00609","modified":1600872120840},{"_id":"source/_posts/Markdown语法.md","hash":"341ffbe0c761f693de9bbdf6a41c399930091ec6","modified":1600872120844},{"_id":"source/_posts/QT事件.md","hash":"3cc3efc5e9ba19a649ab84b292c433e3d93b739e","modified":1600872120844},{"_id":"source/_posts/QT坐标系统.md","hash":"3ed96773186525a5896f6efa7ac6c726acd07a0e","modified":1600872120844},{"_id":"source/_posts/ROS记录.md","hash":"e317465e085d9a200d64b7adcf96e7ceceff9211","modified":1600872120844},{"_id":"source/_posts/ROS遇到的问题.md","hash":"a598dd36fe142569e7c3141a0867c60736b7c648","modified":1603781404790},{"_id":"source/_posts/SAMBA服务简单搭建.md","hash":"6c6a923e02202dd8649d489893b54596793c4952","modified":1600872120844},{"_id":"source/_posts/ROS中CMakeLists-txt.md","hash":"c2ab707dab8d0d5be3498a20891145275081953c","modified":1605785676967},{"_id":"source/_posts/c-pragma-once.md","hash":"6f9930f220a73325163d9ed8569147a5d5b14922","modified":1600872120848},{"_id":"source/_posts/c-函数指针.md","hash":"8920e67a8591b26557d27ffd8e7318e6d739d889","modified":1600872120852},{"_id":"source/_posts/gdb调试.md","hash":"880dd75b4aee8632311bbdd2368141351d6a80d7","modified":1600872120852},{"_id":"source/_posts/c-string与c风格字符串.md","hash":"44971b05b78f7e6760c1c2907fec7839ad8ce063","modified":1600872120848},{"_id":"source/_posts/hexo博客和gitbook配置.md","hash":"9cb433176d6a001ea9844c43dff05636e2e9d191","modified":1600872120852},{"_id":"source/_posts/c-中argc-argv理解.md","hash":"e7d89001db810ef41e5e88d4c02ad05448361b79","modified":1600872120848},{"_id":"source/_posts/make宏编译.md","hash":"f3bad2b8c54b875ad37b757d4c3058380003a9a6","modified":1600872120852},{"_id":"source/_posts/mathtype常用配置.md","hash":"05330ea9018876f55dbd6525778a6724c6e85fe4","modified":1600872120852},{"_id":"source/_posts/c++记录.md","hash":"12ff6ebf447c2f84973959303631c9500170622c","modified":1605361890790},{"_id":"source/_posts/matlab中常见问题.md","hash":"643a15f7b9f7860dafeb2b3c23ba9a605b3e94ad","modified":1600872120852},{"_id":"source/_posts/git基本使用.md","hash":"a6861d7d89999f0be78b30995aee492805308cce","modified":1605417847099},{"_id":"source/_posts/python-装饰器.md","hash":"c7614b73e547694f1211b058304805ba8ff9ce49","modified":1604988492355},{"_id":"source/_posts/hexo本地图片配置.md","hash":"591e672e7feb22388c8399bd457f4561bb9b8d44","modified":1600872120852},{"_id":"source/_posts/qt纪要.md","hash":"16c58f78f9f3e3216020993cb3a667b28bd8f308","modified":1603782519387},{"_id":"source/_posts/mysql.md","hash":"37732033219b701e2dca549ae48bbf3be8729336","modified":1600872120852},{"_id":"source/_posts/ssh远程登录.md","hash":"3e0dbdffb8f0b75b544f3fab0ab9284dc183d4e7","modified":1600872120860},{"_id":"source/_posts/python基础.md","hash":"d54360208fdf05e95eda7545b37d4d268be83528","modified":1603781129261},{"_id":"source/_posts/matlab-绘图.md","hash":"ab19573c96f9a5a427ad00fb089dca1cc35d65c0","modified":1600872120852},{"_id":"source/_posts/shell和下载工具.md","hash":"44777dc16081c068030b09e0dcd569803cfd5812","modified":1600872120852},{"_id":"source/_posts/ubuntu系统配置.md","hash":"eeac9ac3a5c19347f21e27c1580db83a02a264d8","modified":1600872120860},{"_id":"source/_posts/ubuntu配置grub-指定默认内核.md","hash":"02befc07c9a7026b8ea4596a84f4b5b71b39b745","modified":1600872120860},{"_id":"source/_posts/ubuntu下wps缺少字体.md","hash":"9855c6342ae6ab662a2cd82982744febacbe4b75","modified":1600872120860},{"_id":"source/_posts/vim常用命令.md","hash":"25c18001895a66a070261280538193a7ce0e07c4","modified":1600872120860},{"_id":"source/_posts/word参考文献交叉引用.md","hash":"cc8823dfcd876bfec5814366a400a7fe85ce598e","modified":1575421360897},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解.md","hash":"4a32a3ae4b1345ed7d6ec0f87e1c18d7a07b110c","modified":1575944543268},{"_id":"source/_posts/ubuntu解压文件名字无法显示中文-中文乱码.md","hash":"23517f008d6863cd93a06a5da374a534129b0ed6","modified":1600872120860},{"_id":"source/_posts/多系统启动盘制作.md","hash":"ad60edf04d6590e0ad0f4ef4ee97203567ae69e9","modified":1600872120864},{"_id":"source/_posts/word排版.md","hash":"6a556202dc488834545b1f677819110190b24b37","modified":1603780010582},{"_id":"source/_posts/实用小技巧汇总.md","hash":"a48bf7fd24ce7a2e40165585a61cbf814f04b667","modified":1600872120864},{"_id":"source/_posts/常用软件快捷键.md","hash":"485a8e31fea9744a853206c4528c4295bfa32b11","modified":1605432792075},{"_id":"source/_posts/惯性张量.md","hash":"be5d281b23c4f575640bb6944df191247f18a226","modified":1605340998598},{"_id":"source/_posts/ubuntu小技巧.md","hash":"f707cc5ed942a03dd3f8db4f4359275b5c947f42","modified":1605577262263},{"_id":"source/_posts/傅里叶变换理解.md","hash":"83d54dcff0146bf6e2c2aa95f81a388d1d53c196","modified":1575187289216},{"_id":"source/_posts/多线程.md","hash":"ddc23d9675085abd24a3d3f73f4bb71b5bcde93e","modified":1605925818912},{"_id":"source/_posts/拉氏变换.md","hash":"a2470af615834bd6778aa1f5a63b9fbb76203246","modified":1600872120864},{"_id":"source/_posts/排序算法.md","hash":"bbb9108df95cdfd88e643e81fdcf3b339a210138","modified":1600872120864},{"_id":"source/_posts/数据结构c.md","hash":"deba4516cc26df622400afe1ea2ea5b5480cd73f","modified":1600872120864},{"_id":"source/_posts/样本方差分母为什么是n-1.md","hash":"5c91c4172f8700f0ab0fe2ff08d9ee5ae8858ecb","modified":1570077532501},{"_id":"source/_posts/根轨迹.md","hash":"f351c27babddc959adb7e0157149226e54e04206","modified":1600872120864},{"_id":"source/_posts/正交函数.md","hash":"6311346b93a8e2bd5e7132e952e71b14990ed0f7","modified":1600872120864},{"_id":"source/_posts/理解补码.md","hash":"b4086a15c513e10129d5a29b46022b4210039181","modified":1600872120868},{"_id":"source/_posts/用户权限管理.md","hash":"f4ee7dd487eaa7b7022d9a47985f1e3d6871d886","modified":1600872120868},{"_id":"source/_posts/电脑小问题记录.md","hash":"d645101857b3d12714dbb4ea95b7e8b03fe0ad45","modified":1605142172212},{"_id":"source/_posts/矩生成函数.md","hash":"06bf29d3d8f9b67d76b3df36a016383c44443dd9","modified":1600872120868},{"_id":"source/_posts/科式加速度.md","hash":"04e61f9f1011c0e414bfb76365e983a73f94fbf7","modified":1600872120868},{"_id":"source/_posts/解决libapr-1-so-0：对‘uuid-generate-UUID-1-0’未定义的引用.md","hash":"fad0aeaccb593cec919448000bff99d002708ee3","modified":1604979305667},{"_id":"source/_posts/网络基础.md","hash":"c15e51f3c5e5d4d329712a3f3b831496153cd746","modified":1600872120876},{"_id":"source/_posts/逆运动学.md","hash":"266bc8c7b5236289e4f34561d53f3f6fa51bbaa1","modified":1606118208207},{"_id":"source/_posts/雅克比矩阵零空间.md","hash":"5bd47c35675ec4d0ed71f6e49864ef09f3a59ce6","modified":1600872120880},{"_id":"source/_posts/高效工具.md","hash":"4967949c3094b6421689fcfc1c2082f12c688342","modified":1600872120884},{"_id":"source/about/index.md","hash":"2aa039e1289929ac246b3c8cf6111a1da1c754b4","modified":1600872120884},{"_id":"themes/3-hexo/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1600872120884},{"_id":"themes/3-hexo/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1600872120884},{"_id":"themes/3-hexo/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1600872120884},{"_id":"themes/3-hexo/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1600872120884},{"_id":"themes/3-hexo/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1600872120884},{"_id":"themes/3-hexo/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1600872120884},{"_id":"themes/3-hexo/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1600872120884},{"_id":"themes/3-hexo/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1600872120884},{"_id":"themes/3-hexo/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1600872120884},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1600872120884},{"_id":"source/_posts/高斯分布.md","hash":"5f63b80e75f4421be202c9b1f1ddff084f69b57a","modified":1571836987108},{"_id":"themes/3-hexo/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1600872120884},{"_id":"themes/3-hexo/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1600872120884},{"_id":"themes/3-hexo/layout/index.ejs","hash":"a5c464897e7dc9d45d03d8b61e742b1ac4173a95","modified":1600872120884},{"_id":"themes/3-hexo/layout/indexs.md","hash":"70f295af5fccfce214ecbf57368b343f96849f1f","modified":1606121189673},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1600872120884},{"_id":"source/_posts/mathtype常用配置/mathtype.png","hash":"10ea8619c0eaf404b92c14c7f079f8a3ff037080","modified":1575120594000},{"_id":"source/_posts/python基础/matrix_multiply.png","hash":"41b1913118e5f9e426fd12733d6d9ff3189d5580","modified":1600872120852},{"_id":"source/_posts/shell和下载工具/var_test.png","hash":"3c15bbeccafb0fd3c659f538e9d2b8eafedf1f7a","modified":1600872120856},{"_id":"source/_posts/word参考文献交叉引用/插入.png","hash":"a95f410fb60268217d5c2555371df17175e98b09","modified":1575419694233},{"_id":"source/_posts/word参考文献交叉引用/隐藏.png","hash":"6fb91946c93874f5aa64a133d155fffdc5a2d3f8","modified":1575421177803},{"_id":"source/_posts/word排版/中文字号.png","hash":"3ec4c98b3b55dec311b8322c5b7056a97dacbf55","modified":1576331033000},{"_id":"source/_posts/word排版/导出样式.png","hash":"04e4cc8986a87ed0efd558dd0cd0e2b67adb036b","modified":1576332532000},{"_id":"source/_posts/实用小技巧汇总/切换对话关.png","hash":"382c5a593a2158b6b5843b348a5966004eb99e83","modified":1571544139000},{"_id":"source/_posts/实用小技巧汇总/切换对话开.png","hash":"9ddb234c96fca65b9f0de504f3826519201548ec","modified":1571550034000},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/zyx欧拉角.png","hash":"bde66b749f572a0657fc831730d8ac6d8f53642a","modified":1575777574927},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/xyz固定角.png","hash":"6905c7ab265b380fc218e9f89c0c5bb22d568854","modified":1575777343304},{"_id":"source/_posts/根轨迹/close-loop.png","hash":"ce505026b6bab4c4fed8b952779d1e479f63a34a","modified":1600872120864},{"_id":"source/_posts/根轨迹/measureing phase.png","hash":"5c9067dff0918652ce0c1dc9abe90cd7fdc4e47c","modified":1600872120864},{"_id":"source/_posts/拉氏变换/卷积.png","hash":"7c518f87f0f30bd4180d2b68a69739fcd59963d9","modified":1600872120864},{"_id":"source/_posts/理解补码/fanma.png","hash":"213eeabe70bf75fc0fd0c7b5f8870c0891f63ee2","modified":1600872120868},{"_id":"source/_posts/网络基础/IPSection.png","hash":"bdbce57c43200c894a8cc3c3e119b0c136a69ebf","modified":1600872120876},{"_id":"source/_posts/网络基础/Subnet.png","hash":"29274e59f7782c8082a71d184cdccc93ced51ee3","modified":1600872120876},{"_id":"source/_posts/网络基础/Supernet.png","hash":"1d07c9900d9df77262d2c23718d4e8d74c7311cb","modified":1600872120876},{"_id":"source/_posts/网络基础/IPHead.png","hash":"35c13174d9ad41ad6fd98901f92d5c2a3a75c0d5","modified":1600872120876},{"_id":"source/_posts/网络基础/TCPHead.png","hash":"99cbe8516062a2363b7855dbc7124c5d72c3fd19","modified":1600872120876},{"_id":"source/_posts/网络基础/TCPIPdata.png","hash":"63c1c8f40fbbe93d72eca755113d33ba8e6f6600","modified":1600872120876},{"_id":"source/_posts/网络基础/TCPIPfamily.png","hash":"a30fe82d175c06bc0fd8dafc249712d1f2372ec5","modified":1600872120876},{"_id":"source/_posts/网络基础/csmacd.gif","hash":"64832c592201f746d687d678bffcf4a7095148ec","modified":1600872120880},{"_id":"source/_posts/网络基础/UDPHead.png","hash":"b4c73d9e9ae19566dbaf8307f0fea863c01f84a4","modified":1600872120876},{"_id":"source/_posts/逆运动学/niudun.png","hash":"829d90f882a20510af010730f90c1bd43af2919d","modified":1606111039000},{"_id":"source/_posts/高斯分布/条件边缘.png","hash":"0d10a2c33bc0cad6298d2a3ca58f31efd9d70f50","modified":1571836936574},{"_id":"source/_posts/高斯分布/高斯分布.png","hash":"7b4dff423bdb89baf3abb3183d3c73f4e72542d0","modified":1571206160414},{"_id":"source/_posts/雅克比矩阵零空间/redundancy.png","hash":"f64614c4840d463d43514fed93869d6003327adc","modified":1600872120880},{"_id":"source/_posts/雅克比矩阵零空间/velocity_force.png","hash":"1a1b04a3937f144672945928053975640264f6c6","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"84cf0f001afe58574e983a1c42a3710b10427cca","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"05d3cddf5f3a53577452db4efa811bd361f7c0c4","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"6eab1e5fae6bd60928325d026a1bed61c43d11a9","modified":1600872120884},{"_id":"source/_posts/网络基础/TCPTrans.png","hash":"96cc0240da5cc05f7f556053ecb9ff184b8cfd14","modified":1600872120876},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"0e976208d79b0396eb51ca1af5016c963c6e4618","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"8f34f4f40696a29764719683f355e519622e2c23","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"89d2f1979cc193ce3c6a243bdd73f63a9c9612b4","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"87e932476754f27424f9ec397ed66a4ab8a59ad8","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1600872120884},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1600872120896},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1600872120896},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1600872120896},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"7497be722e78973f55d0d280db14fc4d26f71ba7","modified":1600872120892},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1600872120896},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1600872120892},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1600872120888},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1600872120892},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1600872120892},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1600872120892},{"_id":"themes/3-hexo/source/img/weizhuang.jpg","hash":"059570ce336604bda3418da46378d072b7a14d3f","modified":1600872120892},{"_id":"source/_posts/Linux-Qt5-ROS配置Qwtplot3d/simpleplot.png","hash":"46b3646563effe834ac262454c0da13eb208ce9a","modified":1600872120840},{"_id":"source/_posts/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png","hash":"8684ecd38afe075ac38b2ebbe4b4558904ca8e6f","modified":1600872120840},{"_id":"source/_posts/QT坐标系统/coordinate.png","hash":"6ef0735e38cff93f1f0a4f5d98d112b9a7b976e7","modified":1600872120844},{"_id":"source/_posts/c++记录/运算符优先级.png","hash":"0e0cf56eb380fd8e618ec50351d6fdffa7f46554","modified":1600872120848},{"_id":"source/_posts/c++记录/异常图.png","hash":"f8fb0e2f3398c1fb68cf357522c5d61de82d243f","modified":1600872120848},{"_id":"source/_posts/c++记录/异常表.png","hash":"cf39134b4fbeb2d6960c060144e415741220ce0a","modified":1600872120848},{"_id":"source/_posts/shell和下载工具/delete_replace.png","hash":"c3acf1313dff46f4250d31654111d9b15187a2ea","modified":1600872120856},{"_id":"source/_posts/vim常用命令/Vim.png","hash":"55cc6592ecd5d690b671329f2ae791de22b5f991","modified":1600872120860},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/pose.jpg","hash":"4d4599a1842e8c366a9b322b19c60cd0bc96ab06","modified":1600872120864},{"_id":"source/_posts/多系统启动盘制作/WinSetup.png","hash":"dc0c69daa169f90f98370cf2e4070d098307cdc4","modified":1570077532501},{"_id":"source/_posts/网络基础/OSI_TCPIP.png","hash":"78c5f49e837b46b272a24dde24260b7c4042569c","modified":1600872120876},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1600872120892},{"_id":"source/_posts/shell和下载工具/文件测试.png","hash":"f25b0d9a634b48697caaffae9ccee3ea95e434ef","modified":1600872120856},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"8a3a175c2da956366ce91bfc4f4012a487f4bdfc","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"980c2ee1ef71b8e44f2f1a0bcab047563ea826b5","modified":1600872120884},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"35d2c0c08507d96b4c7fcbf3193782f5324c4a11","modified":1600872120884},{"_id":"source/_posts/逆运动学/iksurvey.pdf","hash":"f5cedd3e7b2b897a4c4d56ab018439aadc8e0240","modified":1606046412000},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1600872120888},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1600872120884},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"69a37140efe0579b1089cea5cbc6f2f0a5dd4c19","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"bed4d16dc5947e9cee0296fa8999cf21754f2d93","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1600872120888},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"49f26040a9948aff907773b0fbb4ad7e0a855472","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1600872120888},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1600872120892},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1600872120892},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1600872120892},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1600872120892},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1600872120892},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1600872120892},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1600872120888},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1600872120896},{"_id":"source/_posts/雅克比矩阵零空间/Redundancy-19.pdf","hash":"71ebcbff6e4e55632315ae68d31849b47f402db9","modified":1600872120880},{"_id":"source/_posts/科式加速度/科式加速度.png","hash":"cdbd03efd4d05d9a61eaf6db49867fd5da182b7d","modified":1600872120872},{"_id":"source/_posts/python基础/OPGL_pointcloud.pdf","hash":"80673c61ebdbac9c635e1e3356502d9b4d503e26","modified":1603752017325},{"_id":"source/img/weiZhuang.png","hash":"bbe2f746285b051dc363e233f0dbfa54b56a127b","modified":1606120354000},{"_id":"themes/3-hexo/source/img/weiZhuang.png","hash":"bbe2f746285b051dc363e233f0dbfa54b56a127b","modified":1606120354000},{"_id":"themes/3-hexo/source/img/jun.jpg","hash":"34823f55d563cc27937c8444d5b558cee3592279","modified":1606121128000},{"_id":"public/atom.xml","hash":"30f1b20ad6de6a01ef6fc86e3c72a8f6da9eea0f","modified":1606121200701},{"_id":"public/search.xml","hash":"65f1534847ba301a2b6af38f4500c63aabae7da9","modified":1606121200702},{"_id":"public/about/index.html","hash":"d274be4d1fd99cba9824572c2e5cbe107c806bd2","modified":1606121200784},{"_id":"public/2020/11/23/逆运动学/index.html","hash":"1239bfb3067b97d76bf3c7d64cc9b2abce1a04f0","modified":1606121200784},{"_id":"public/2020/11/14/多线程/index.html","hash":"c49fe4b34962a237bbb8fa61828fa92ffd4c7a67","modified":1606121200785},{"_id":"public/2020/11/12/电脑小问题记录/index.html","hash":"ed35251ce4ff7193e8446c6ecb430e7644d4b334","modified":1606121200785},{"_id":"public/2020/11/10/python-装饰器/index.html","hash":"5156638711c7d081c16276dc4a96e72ecd71c9d8","modified":1606121200785},{"_id":"public/2020/11/10/解决libapr-1-so-0：对‘uuid-generate-UUID-1-0’未定义的引用/index.html","hash":"ed1cdb689c7b6b712d926d7d6c3008201f5635ce","modified":1606121200785},{"_id":"public/2020/05/22/python基础/index.html","hash":"a9e9c6f0f3a5f3574b5cbb05e67eeedea202b11d","modified":1606121200786},{"_id":"public/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/index.html","hash":"ce12c07b807fb48d12b9f821b4e4b06ffb43b8d5","modified":1606121200786},{"_id":"public/2020/04/21/mysql/index.html","hash":"f8de5afa3c03e33ee9194a160d427c30e968a1e9","modified":1606121200786},{"_id":"public/2020/03/28/根轨迹/index.html","hash":"4c8d4dbe34738bf1d4d54cd75b0e39ac1ad8ce41","modified":1606121200786},{"_id":"public/2020/03/16/排序算法/index.html","hash":"f97853670f4d7aeceab1593ef814688807141662","modified":1606121200786},{"_id":"public/2020/03/13/理解补码/index.html","hash":"99f059a4c2570cb2d8d3ff2b2846dfc2b9e8f4f2","modified":1606121200786},{"_id":"public/2020/02/22/c-string与c风格字符串/index.html","hash":"8aed75b47bb0db494cec83d551cdba33dc035052","modified":1606121200787},{"_id":"public/2020/02/19/雅克比矩阵零空间/index.html","hash":"de69cb00fcc118781bc7f8cb13905f5716c76571","modified":1606121200787},{"_id":"public/2020/02/15/数据结构c/index.html","hash":"663310996652209f3d368e2dcf9928330811d1b4","modified":1606121200787},{"_id":"public/2020/02/05/c-pragma-once/index.html","hash":"7df10d3e260d83cd74df7c2a6ee6b9717197bc39","modified":1606121200787},{"_id":"public/2020/02/03/QT坐标系统/index.html","hash":"c014d41ebf708534f7f40bcad48d3f5c22388c0f","modified":1606121200787},{"_id":"public/2020/02/01/QT事件/index.html","hash":"42477ba0f2d0b6e850530be7038af2ac611a8250","modified":1606121200788},{"_id":"public/2020/01/22/c-中argc-argv理解/index.html","hash":"85c43fde3b7f62e1f5a4c16de614d2d6631415b8","modified":1606121200788},{"_id":"public/2020/01/13/科式加速度/index.html","hash":"c73e12819445ba7911531f35dba2b78e35ea3ad9","modified":1606121200788},{"_id":"public/2020/01/09/ubuntu配置grub-指定默认内核/index.html","hash":"45542ac45d873c1fc99cda1e16f2803c3871c39a","modified":1606121200789},{"_id":"public/2019/12/30/惯性张量/index.html","hash":"149688b2eebc27ac03d3c6b46a1f007a8f334c05","modified":1606121200789},{"_id":"public/2019/12/27/拉氏变换/index.html","hash":"63d2a1a56042bae91f592844a13529eb40354462","modified":1606121200789},{"_id":"public/2019/12/22/ubuntu下wps缺少字体/index.html","hash":"cf1fc4bb376655a3223e06f8317b8de70fbd8759","modified":1606121200789},{"_id":"public/2019/12/21/ROS遇到的问题/index.html","hash":"339085b5de948fa8c61cde65e265e4827aa5e14c","modified":1606121200789},{"_id":"public/2019/12/15/网络基础/index.html","hash":"680d989fd279217436df7a970046bb89295927fa","modified":1606121200789},{"_id":"public/2019/12/14/word排版/index.html","hash":"b391d19caee2c77c62d1b8107ea7f308553b21cf","modified":1606121200789},{"_id":"public/2019/12/08/位姿变换矩阵左乘和右乘理解/index.html","hash":"bcfc93206d7c834ab4f8130cc7fb4de33a4b5344","modified":1606121200789},{"_id":"public/2019/12/04/word参考文献交叉引用/index.html","hash":"218297a931b1cb7760ca428e6f70655ac118f7c7","modified":1606121200790},{"_id":"public/2019/11/30/高效工具/index.html","hash":"d66d2f714708b2df7abf890ec0adf62738168f21","modified":1606121200790},{"_id":"public/2019/11/30/mathtype常用配置/index.html","hash":"8d13857c6ce9d309da2eb84e36a75f9ddf94ecce","modified":1606121200790},{"_id":"public/2019/11/30/傅里叶变换理解/index.html","hash":"0c5ead8bb7862eddcbcbc074ed439d9047f2e319","modified":1606121200790},{"_id":"public/2019/11/23/ubuntu解压文件名字无法显示中文-中文乱码/index.html","hash":"5e07c79b37d12f69e1885922f4c66952c345fc65","modified":1606121200790},{"_id":"public/2019/11/22/qt纪要/index.html","hash":"83ab60a8506349e6f86d8725d164d7ce02408e83","modified":1606121200790},{"_id":"public/2019/11/16/c-函数指针/index.html","hash":"0bc601acb6f8c3dd0a0b9761744248b01c3fe6b1","modified":1606121200791},{"_id":"public/2019/11/02/make宏编译/index.html","hash":"2f635524b88ec761d4ae9a5449e1f43cfaf6c039","modified":1606121200791},{"_id":"public/2019/11/02/Linux-正则表达式/index.html","hash":"b2f0cfe3bb334bf5d1841019cb58588394b13c11","modified":1606121200791},{"_id":"public/2019/10/24/matlab中常见问题/index.html","hash":"ed68347288caf6febd5a0a2cae2070372f6703b2","modified":1606121200791},{"_id":"public/2019/10/24/matlab-绘图/index.html","hash":"ac82294ecb2656696a5ceb8f02cf9e89f6deea0f","modified":1606121200791},{"_id":"public/2019/10/20/实用小技巧汇总/index.html","hash":"06fce961708ec86f0c1d71c2c6e2b6168a96398e","modified":1606121200791},{"_id":"public/2019/10/16/高斯分布/index.html","hash":"d2b314468ec6a5524141a809335502079c2c43db","modified":1606121200792},{"_id":"public/2019/10/07/常用软件快捷键/index.html","hash":"d9e1af8725f1dde9d3ad5ef1e24f23b16a65159c","modified":1606121200792},{"_id":"public/2019/10/07/ROS记录/index.html","hash":"6e25126d0787c0157daae114b6117b004663b61d","modified":1606121200792},{"_id":"public/2019/10/06/c++记录/index.html","hash":"0c6a892551d500e21e335e105a4cdfadff665cdd","modified":1606121200792},{"_id":"public/2019/10/06/hexo博客和gitbook配置/index.html","hash":"75ba9572bf65d30e37a5db0a5965032b30a7290e","modified":1606121200792},{"_id":"public/2019/10/05/ROS中CMakeLists-txt/index.html","hash":"2fcb00cf60e250738cd422d70964f5ccf845c9df","modified":1606121200793},{"_id":"public/2019/10/03/gdb调试/index.html","hash":"ff6bb359ccfab51ad59f88f2bae8f175bb6979ca","modified":1606121200793},{"_id":"public/2019/10/02/Linux进程管理/index.html","hash":"2007dc92f4a5ef9f8e20764c497fffd89b451bc9","modified":1606121200793},{"_id":"public/2019/10/01/SAMBA服务简单搭建/index.html","hash":"7b41443ab31478063027a0a010f4e9175fc1da66","modified":1606121200793},{"_id":"public/2019/10/01/Github-SSH-Key避免Hexo部署输入密码/index.html","hash":"4ccd2fb0b29cc11f1cee6d1d2825276c4bc09457","modified":1606121200793},{"_id":"public/2019/09/30/用户权限管理/index.html","hash":"c6c3b69cce6ab67e6bfb4f59eb9f24db412a9147","modified":1606121200793},{"_id":"public/2019/09/30/FTP配置和使用/index.html","hash":"a6ff75c66cc57a79b9197df33d8f1e77b03c12ab","modified":1606121200794},{"_id":"public/2019/09/30/vim常用命令/index.html","hash":"7fa26e946558379541aced4165d13072a542ca45","modified":1606121200794},{"_id":"public/2019/09/29/ubuntu小技巧/index.html","hash":"b53029cd38c4187df63b6cb40ad4cf921a1565a9","modified":1606121200794},{"_id":"public/2019/09/29/shell和下载工具/index.html","hash":"a530249b6379f37fe34263bae1eaa8e6185f8844","modified":1606121200794},{"_id":"public/2019/09/29/ssh远程登录/index.html","hash":"71a93af686e5c2a2d7361a3fb0bef2f84cddc4da","modified":1606121200794},{"_id":"public/2019/09/01/矩生成函数/index.html","hash":"481459fcf28f34f005fc900d0eb5231384495eaf","modified":1606121200795},{"_id":"public/2019/08/31/样本方差分母为什么是n-1/index.html","hash":"e53a5490de2a5651795d17ec53d01e49c4ae0527","modified":1606121200795},{"_id":"public/2019/07/21/多系统启动盘制作/index.html","hash":"0ea5c69db842099bff683cf0c43795e86879a706","modified":1606121200795},{"_id":"public/2019/07/18/正交函数/index.html","hash":"dae7c1c198ae20a6dcb92b22eb58771120eaeb0b","modified":1606121200795},{"_id":"public/2019/07/16/git基本使用/index.html","hash":"b6e284dd5b5d69416d1eab9ddce30bc3ecb0f447","modified":1606121200795},{"_id":"public/2019/07/16/hexo本地图片配置/index.html","hash":"5f0a39db41ffe8a4663b0fbff74b7f6f8ddf310e","modified":1606121200795},{"_id":"public/2019/07/14/ubuntu系统配置/index.html","hash":"dafaf2c150aed4b29d9cd1cb9085a2f18d35098c","modified":1606121200796},{"_id":"public/2019/07/14/Markdown语法/index.html","hash":"9557091c2a1e13f188fb2bea86a727038c66d0b0","modified":1606121200796},{"_id":"public/archives/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200796},{"_id":"public/archives/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200796},{"_id":"public/archives/page/3/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200796},{"_id":"public/archives/page/4/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200796},{"_id":"public/archives/page/5/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/page/6/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/page/7/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/2019/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/2019/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/2019/page/3/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/2019/page/4/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200797},{"_id":"public/archives/2019/page/5/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/07/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/08/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/09/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/10/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/10/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/11/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200798},{"_id":"public/archives/2019/12/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/01/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/02/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/03/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200799},{"_id":"public/archives/2020/04/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/archives/2020/05/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/archives/2020/11/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/page/3/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/page/4/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200800},{"_id":"public/page/5/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/page/6/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/page/7/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/categories/Linux/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/categories/Linux/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/categories/Linux/page/3/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/categories/program/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200801},{"_id":"public/categories/program/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/ROS/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/software/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/blog/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/math/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/math/page/2/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200802},{"_id":"public/categories/systems/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200803},{"_id":"public/categories/internet/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200803},{"_id":"public/tags/数据传输/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200803},{"_id":"public/tags/blog/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200803},{"_id":"public/tags/ssh/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200804},{"_id":"public/tags/hexo/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/正则表达式/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/Qt/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/ROS/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/program/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/qt/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/NodeHandle/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200805},{"_id":"public/tags/文件共享/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/c/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/gdb/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/字符串/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/gitbook/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/make/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/equation/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/matlab/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/python/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/git/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200806},{"_id":"public/tags/mysql/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/software/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/ubuntu/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/grub/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/wps/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/vim/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/word/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/机器人学/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200807},{"_id":"public/tags/位姿变换/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/编码/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/重装系统/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/matlab绘图/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/ps/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/快捷键/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200808},{"_id":"public/tags/simulink/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/clion/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/world/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/excel/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/傅里叶变换/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/多线程/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/自动控制原理/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200809},{"_id":"public/tags/sort/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/数据结构/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/概率论/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/根轨迹/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/补码/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/信号分析/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/权限/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200810},{"_id":"public/tags/软硬件/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/加速度/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/anaconda/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/shell/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/下载工具/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/网络基础/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/雅克比矩阵/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200811},{"_id":"public/tags/伪逆/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200812},{"_id":"public/tags/efficiency/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200812},{"_id":"public/tags/机器人/index.html","hash":"0148f96b0419b7aaec1223d20e2a12c3f53608fc","modified":1606121200812},{"_id":"public/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1606121200822},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1606121200822},{"_id":"public/img/weizhuang.jpg","hash":"059570ce336604bda3418da46378d072b7a14d3f","modified":1606121200822},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1606121200822},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1606121200822},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1606121200822},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1606121200822},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1606121200823},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1606121200823},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1606121200823},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1606121200823},{"_id":"public/2019/11/30/mathtype常用配置/mathtype.png","hash":"10ea8619c0eaf404b92c14c7f079f8a3ff037080","modified":1606121200823},{"_id":"public/2020/03/13/理解补码/fanma.png","hash":"213eeabe70bf75fc0fd0c7b5f8870c0891f63ee2","modified":1606121200823},{"_id":"public/2019/12/27/拉氏变换/卷积.png","hash":"7c518f87f0f30bd4180d2b68a69739fcd59963d9","modified":1606121200823},{"_id":"public/2020/05/22/python基础/matrix_multiply.png","hash":"41b1913118e5f9e426fd12733d6d9ff3189d5580","modified":1606121200823},{"_id":"public/2019/12/04/word参考文献交叉引用/插入.png","hash":"a95f410fb60268217d5c2555371df17175e98b09","modified":1606121200823},{"_id":"public/2019/12/04/word参考文献交叉引用/隐藏.png","hash":"6fb91946c93874f5aa64a133d155fffdc5a2d3f8","modified":1606121200823},{"_id":"public/2019/12/14/word排版/中文字号.png","hash":"3ec4c98b3b55dec311b8322c5b7056a97dacbf55","modified":1606121200823},{"_id":"public/2019/12/14/word排版/导出样式.png","hash":"04e4cc8986a87ed0efd558dd0cd0e2b67adb036b","modified":1606121200823},{"_id":"public/2019/10/20/实用小技巧汇总/切换对话关.png","hash":"382c5a593a2158b6b5843b348a5966004eb99e83","modified":1606121200823},{"_id":"public/2019/10/20/实用小技巧汇总/切换对话开.png","hash":"9ddb234c96fca65b9f0de504f3826519201548ec","modified":1606121200823},{"_id":"public/2020/03/28/根轨迹/close-loop.png","hash":"ce505026b6bab4c4fed8b952779d1e479f63a34a","modified":1606121200823},{"_id":"public/2020/03/28/根轨迹/measureing phase.png","hash":"5c9067dff0918652ce0c1dc9abe90cd7fdc4e47c","modified":1606121200823},{"_id":"public/2019/12/08/位姿变换矩阵左乘和右乘理解/xyz固定角.png","hash":"6905c7ab265b380fc218e9f89c0c5bb22d568854","modified":1606121200823},{"_id":"public/2019/12/08/位姿变换矩阵左乘和右乘理解/zyx欧拉角.png","hash":"bde66b749f572a0657fc831730d8ac6d8f53642a","modified":1606121200823},{"_id":"public/2019/10/16/高斯分布/条件边缘.png","hash":"0d10a2c33bc0cad6298d2a3ca58f31efd9d70f50","modified":1606121200823},{"_id":"public/2019/10/16/高斯分布/高斯分布.png","hash":"7b4dff423bdb89baf3abb3183d3c73f4e72542d0","modified":1606121200823},{"_id":"public/2019/09/29/shell和下载工具/var_test.png","hash":"3c15bbeccafb0fd3c659f538e9d2b8eafedf1f7a","modified":1606121200823},{"_id":"public/2020/02/19/雅克比矩阵零空间/redundancy.png","hash":"f64614c4840d463d43514fed93869d6003327adc","modified":1606121200823},{"_id":"public/2020/02/19/雅克比矩阵零空间/velocity_force.png","hash":"1a1b04a3937f144672945928053975640264f6c6","modified":1606121200823},{"_id":"public/2019/12/15/网络基础/IPHead.png","hash":"35c13174d9ad41ad6fd98901f92d5c2a3a75c0d5","modified":1606121200823},{"_id":"public/2019/12/15/网络基础/IPSection.png","hash":"bdbce57c43200c894a8cc3c3e119b0c136a69ebf","modified":1606121200823},{"_id":"public/2019/12/15/网络基础/Subnet.png","hash":"29274e59f7782c8082a71d184cdccc93ced51ee3","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/Supernet.png","hash":"1d07c9900d9df77262d2c23718d4e8d74c7311cb","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/TCPHead.png","hash":"99cbe8516062a2363b7855dbc7124c5d72c3fd19","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/TCPIPdata.png","hash":"63c1c8f40fbbe93d72eca755113d33ba8e6f6600","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/TCPIPfamily.png","hash":"a30fe82d175c06bc0fd8dafc249712d1f2372ec5","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/TCPTrans.png","hash":"96cc0240da5cc05f7f556053ecb9ff184b8cfd14","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/UDPHead.png","hash":"b4c73d9e9ae19566dbaf8307f0fea863c01f84a4","modified":1606121200824},{"_id":"public/2019/12/15/网络基础/csmacd.gif","hash":"64832c592201f746d687d678bffcf4a7095148ec","modified":1606121200824},{"_id":"public/2020/11/23/逆运动学/niudun.png","hash":"829d90f882a20510af010730f90c1bd43af2919d","modified":1606121200824},{"_id":"public/2019/10/06/c++记录/运算符优先级.png","hash":"0e0cf56eb380fd8e618ec50351d6fdffa7f46554","modified":1606121200824},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1606121201111},{"_id":"public/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1606121201112},{"_id":"public/2020/02/03/QT坐标系统/coordinate.png","hash":"6ef0735e38cff93f1f0a4f5d98d112b9a7b976e7","modified":1606121201112},{"_id":"public/2019/09/30/vim常用命令/Vim.png","hash":"55cc6592ecd5d690b671329f2ae791de22b5f991","modified":1606121201112},{"_id":"public/2019/07/21/多系统启动盘制作/WinSetup.png","hash":"dc0c69daa169f90f98370cf2e4070d098307cdc4","modified":1606121201112},{"_id":"public/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot.png","hash":"46b3646563effe834ac262454c0da13eb208ce9a","modified":1606121201112},{"_id":"public/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png","hash":"8684ecd38afe075ac38b2ebbe4b4558904ca8e6f","modified":1606121201112},{"_id":"public/2019/12/08/位姿变换矩阵左乘和右乘理解/pose.jpg","hash":"4d4599a1842e8c366a9b322b19c60cd0bc96ab06","modified":1606121201112},{"_id":"public/2019/09/29/shell和下载工具/delete_replace.png","hash":"c3acf1313dff46f4250d31654111d9b15187a2ea","modified":1606121201112},{"_id":"public/2019/12/15/网络基础/OSI_TCPIP.png","hash":"78c5f49e837b46b272a24dde24260b7c4042569c","modified":1606121201112},{"_id":"public/2019/10/06/c++记录/异常图.png","hash":"f8fb0e2f3398c1fb68cf357522c5d61de82d243f","modified":1606121201112},{"_id":"public/2019/10/06/c++记录/异常表.png","hash":"cf39134b4fbeb2d6960c060144e415741220ce0a","modified":1606121201112},{"_id":"public/css/mobile.css","hash":"fd53e624c39f72d78099dca43d0fce28bc20a6ec","modified":1606121201116},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1606121201116},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1606121201116},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1606121201116},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1606121201117},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1606121201117},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1606121201117},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1606121201117},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1606121201117},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1606121201117},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1606121201117},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1606121201117},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1606121201117},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1606121201117},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1606121201117},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1606121201117},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1606121201117},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1606121201117},{"_id":"public/css/style.css","hash":"89c3585af10d974b935cf75363248a36e9ce7b3e","modified":1606121201117},{"_id":"public/2019/09/29/shell和下载工具/文件测试.png","hash":"f25b0d9a634b48697caaffae9ccee3ea95e434ef","modified":1606121201117},{"_id":"public/2020/11/23/逆运动学/iksurvey.pdf","hash":"f5cedd3e7b2b897a4c4d56ab018439aadc8e0240","modified":1606121201117},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1606121201120},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1606121201125},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1606121201125},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1606121201125},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1606121201127},{"_id":"public/2020/02/19/雅克比矩阵零空间/Redundancy-19.pdf","hash":"71ebcbff6e4e55632315ae68d31849b47f402db9","modified":1606121201141},{"_id":"public/2020/01/13/科式加速度/科式加速度.png","hash":"cdbd03efd4d05d9a61eaf6db49867fd5da182b7d","modified":1606121201141},{"_id":"public/2020/05/22/python基础/OPGL_pointcloud.pdf","hash":"80673c61ebdbac9c635e1e3356502d9b4d503e26","modified":1606121201157},{"_id":"public/img/jun.jpg","hash":"34823f55d563cc27937c8444d5b558cee3592279","modified":1606121201160},{"_id":"public/img/weiZhuang.png","hash":"bbe2f746285b051dc363e233f0dbfa54b56a127b","modified":1606121201164},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1606121201173}],"Category":[{"name":"Linux","_id":"ckhub3ch20002mxkav3a8q08b"},{"name":"program","_id":"ckhub3che000jmxkatxdef798"},{"name":"ROS","_id":"ckhub3chk0012mxkac3lklj2b"},{"name":"software","_id":"ckhub3chp001kmxkafrc1by68"},{"name":"blog","_id":"ckhub3cht0021mxka20xbr4qj"},{"name":"math","_id":"ckhub3ci2002zmxka5ft2fmhq"},{"name":"systems","_id":"ckhub3ci40037mxkahmpl4q0r"},{"name":"internet","_id":"ckhub3cjn0075mxka9hpxk9ps"}],"Data":[],"Page":[{"title":"博主","_content":"\n\n\n个人简介\n---\n杨本泊，\n\n就读于武大，目前研究机械臂轨迹规划。\n\n喜欢研究新兴技术和未来发展方向。\n\n最近\n---\n搭建博客\n\n联系方式\n---\n\n- QQ : 2519130844\n- 邮箱 : yangbenbo_whu@qq.com","source":"about/index.md","raw":"---\ntitle: 博主\n---\n\n\n\n个人简介\n---\n杨本泊，\n\n就读于武大，目前研究机械臂轨迹规划。\n\n喜欢研究新兴技术和未来发展方向。\n\n最近\n---\n搭建博客\n\n联系方式\n---\n\n- QQ : 2519130844\n- 邮箱 : yangbenbo_whu@qq.com","date":"2020-09-23T14:42:00.884Z","updated":"2020-09-23T14:42:00.884Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckhub3cjg006wmxkamhcx8tci","content":"<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>杨本泊，</p>\n<p>就读于武大，目前研究机械臂轨迹规划。</p>\n<p>喜欢研究新兴技术和未来发展方向。</p>\n<h2 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h2><p>搭建博客</p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>QQ : 2519130844</li>\n<li>邮箱 : yangbenbo_whu@qq.com</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p>杨本泊，</p>\n<p>就读于武大，目前研究机械臂轨迹规划。</p>\n<p>喜欢研究新兴技术和未来发展方向。</p>\n<h2 id=\"最近\"><a href=\"#最近\" class=\"headerlink\" title=\"最近\"></a>最近</h2><p>搭建博客</p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>QQ : 2519130844</li>\n<li>邮箱 : yangbenbo_whu@qq.com</li>\n</ul>\n"}],"Post":[{"title":"FTP配置和使用","date":"2019-09-30T12:45:12.000Z","_content":"\n# FTP简介\n文件传输协议(File Transfer Protocol)：传统网络传输协议，主要实现服务器和客户端之间的文件传输\n\n# FTP配置\n匿名用户无法使用ls dir等命令查看文件\n\n---\n    sudo apt-get install vsftpd   #服务器端\n    sudo vim /etc/vsftpd.conf     #可以默认 anonymous_enable=YES 可用anonymous作为用户名和密码登录\n    sudo /etc/init.d/vsftpd restart  #重启服务\n    \n    ftp 10.1.1.20   #连接服务器\n    \n    \n配置文件:vsftpd.conf   # 测试了一下 感觉默认设置就可以本地用户登录 \n可能需要改/etc/ftpusers  并重启  \n\n\n    local_root=/home/ftp  # 锁定共享目录 手动添加  可以不用\n    local_enable=YES    #本机可以访问\n    write_enable=YES    #允许写操作\n    \n    #chroot_local_user=YES\n    chroot_list_enable=YES    # 限制实体用户在自己的主目录设定文件\n    # (default follows)\n    chroot_list_file=/etc/vsftpd.chroot_list\n    sudo vim /etc/vsftpd.chroot_list     # 添加用户名\n    sudo vim /etc/ftpusers  #这里面是不能访问ftp的用户  删除对应的\n    \n    \n# 常用命令\n## FTP命令\n\n    ftp> ascii # 设定以ASCII方式传送文件(缺省值) \n    ftp> bell  # 每完成一次文件传送,报警提示. \n    ftp> binary # 设定以二进制方式传送文件. \n    ftp> bye  # 终止主机FTP进程,并退出FTP管理方式. \n    ftp> case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. \n    ftp> cd   # 同UNIX的CD命令. \n    ftp> cdup  # 返回上一级目录. \n    ftp> chmod # 改变远端主机的文件权限. \n    ftp> close # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. \n    ftp> delete # 删除远端主机中的文件. \n    ftp> dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. \n    ftp> get [remote-file] [local-file] # 从远端主机中传送至本地主机中. \n    ftp> help [command] # 输出命令的解释. \n    ftp> lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. \n    ftp> ls [remote-directory] [local-file] # 同DIR. \n    ftp> macdef         # 定义宏命令. \n    ftp> mdelete [remote-files] # 删除一批文件. \n    ftp> mget [remote-files]  # 从远端主机接收一批文件至本地主机. \n    ftp> mkdir directory-name  # 在远端主机中建立目录. \n    ftp> mput local-files # 将本地主机中一批文件传送至远端主机. \n    ftp> open host [port] # 重新建立一个新的连接. \n    ftp> prompt      # 交互提示模式. \n    ftp> put local-file [remote-file] # 将本地一个文件传送至远端主机中. \n    ftp> pwd # 列出当前远端主机目录. \n    ftp> quit # 同BYE. \n    ftp> recv remote-file [local-file] # 同GET. \n    ftp> rename [from] [to]   # 改变远端主机中的文件名. \n    ftp> rmdir directory-name  # 删除远端主机中的目录. \n    ftp> send local-file [remote-file] # 同PUT. \n    ftp> status  # 显示当前FTP的状态. \n    ftp> system  # 显示远端主机系统类型. \n    ftp> user user-name [password] [account] # 重新以别的用户名登录远端主机. \n    ftp> ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。\n    ftp> ! # 从 ftp 子系统退出到外壳。\n   \n   \n## 关闭FTP\n    bye\n    \n    exit\n    \n    quit\n## 上传下载\n    ftp> put /path/readme.txt # 上传 readme.txt 文件\n    ftp> mput *.txt      # 可以上传多个文件\n    \n    ftp> get readme.txt # 下载 readme.txt 文件\n    ftp> mget *.txt   # 下载\n    \nwin10上传下载 命令同Linux\n    \n    cmd\n    ftp 10.1.1.20\n    \n    \n## 状态码\n    •230 - 登录成功\n    •200 - 命令执行成功\n    •150 - 文件状态正常，开启数据连接端口\n    •250 - 目录切换操作完成\n    •226 - 关闭数据连接端口，请求的文件操作成功 \n# 参考\n1. [Linux中ftp的常用命令](https://www.cnblogs.com/feiquan/p/9236768.html)\n2. 1. [Ubuntu安装ftp服务](https://blog.csdn.net/Klein_yang/article/details/84954958)","source":"_posts/FTP配置和使用.md","raw":"---\ntitle: FTP配置和使用\ndate: 2019-09-30 20:45:12\ncategories:\n- Linux\ntags:\n- 数据传输\n\n---\n\n# FTP简介\n文件传输协议(File Transfer Protocol)：传统网络传输协议，主要实现服务器和客户端之间的文件传输\n\n# FTP配置\n匿名用户无法使用ls dir等命令查看文件\n\n---\n    sudo apt-get install vsftpd   #服务器端\n    sudo vim /etc/vsftpd.conf     #可以默认 anonymous_enable=YES 可用anonymous作为用户名和密码登录\n    sudo /etc/init.d/vsftpd restart  #重启服务\n    \n    ftp 10.1.1.20   #连接服务器\n    \n    \n配置文件:vsftpd.conf   # 测试了一下 感觉默认设置就可以本地用户登录 \n可能需要改/etc/ftpusers  并重启  \n\n\n    local_root=/home/ftp  # 锁定共享目录 手动添加  可以不用\n    local_enable=YES    #本机可以访问\n    write_enable=YES    #允许写操作\n    \n    #chroot_local_user=YES\n    chroot_list_enable=YES    # 限制实体用户在自己的主目录设定文件\n    # (default follows)\n    chroot_list_file=/etc/vsftpd.chroot_list\n    sudo vim /etc/vsftpd.chroot_list     # 添加用户名\n    sudo vim /etc/ftpusers  #这里面是不能访问ftp的用户  删除对应的\n    \n    \n# 常用命令\n## FTP命令\n\n    ftp> ascii # 设定以ASCII方式传送文件(缺省值) \n    ftp> bell  # 每完成一次文件传送,报警提示. \n    ftp> binary # 设定以二进制方式传送文件. \n    ftp> bye  # 终止主机FTP进程,并退出FTP管理方式. \n    ftp> case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. \n    ftp> cd   # 同UNIX的CD命令. \n    ftp> cdup  # 返回上一级目录. \n    ftp> chmod # 改变远端主机的文件权限. \n    ftp> close # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. \n    ftp> delete # 删除远端主机中的文件. \n    ftp> dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. \n    ftp> get [remote-file] [local-file] # 从远端主机中传送至本地主机中. \n    ftp> help [command] # 输出命令的解释. \n    ftp> lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. \n    ftp> ls [remote-directory] [local-file] # 同DIR. \n    ftp> macdef         # 定义宏命令. \n    ftp> mdelete [remote-files] # 删除一批文件. \n    ftp> mget [remote-files]  # 从远端主机接收一批文件至本地主机. \n    ftp> mkdir directory-name  # 在远端主机中建立目录. \n    ftp> mput local-files # 将本地主机中一批文件传送至远端主机. \n    ftp> open host [port] # 重新建立一个新的连接. \n    ftp> prompt      # 交互提示模式. \n    ftp> put local-file [remote-file] # 将本地一个文件传送至远端主机中. \n    ftp> pwd # 列出当前远端主机目录. \n    ftp> quit # 同BYE. \n    ftp> recv remote-file [local-file] # 同GET. \n    ftp> rename [from] [to]   # 改变远端主机中的文件名. \n    ftp> rmdir directory-name  # 删除远端主机中的目录. \n    ftp> send local-file [remote-file] # 同PUT. \n    ftp> status  # 显示当前FTP的状态. \n    ftp> system  # 显示远端主机系统类型. \n    ftp> user user-name [password] [account] # 重新以别的用户名登录远端主机. \n    ftp> ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。\n    ftp> ! # 从 ftp 子系统退出到外壳。\n   \n   \n## 关闭FTP\n    bye\n    \n    exit\n    \n    quit\n## 上传下载\n    ftp> put /path/readme.txt # 上传 readme.txt 文件\n    ftp> mput *.txt      # 可以上传多个文件\n    \n    ftp> get readme.txt # 下载 readme.txt 文件\n    ftp> mget *.txt   # 下载\n    \nwin10上传下载 命令同Linux\n    \n    cmd\n    ftp 10.1.1.20\n    \n    \n## 状态码\n    •230 - 登录成功\n    •200 - 命令执行成功\n    •150 - 文件状态正常，开启数据连接端口\n    •250 - 目录切换操作完成\n    •226 - 关闭数据连接端口，请求的文件操作成功 \n# 参考\n1. [Linux中ftp的常用命令](https://www.cnblogs.com/feiquan/p/9236768.html)\n2. 1. [Ubuntu安装ftp服务](https://blog.csdn.net/Klein_yang/article/details/84954958)","slug":"FTP配置和使用","published":1,"updated":"2020-09-23T14:42:00.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cgx0000mxkaf3s8hlax","content":"<h1 id=\"FTP简介\"><a href=\"#FTP简介\" class=\"headerlink\" title=\"FTP简介\"></a>FTP简介</h1><p>文件传输协议(File Transfer Protocol)：传统网络传输协议，主要实现服务器和客户端之间的文件传输</p>\n<h1 id=\"FTP配置\"><a href=\"#FTP配置\" class=\"headerlink\" title=\"FTP配置\"></a>FTP配置</h1><p>匿名用户无法使用ls dir等命令查看文件</p>\n<hr>\n<pre><code>sudo apt-get install vsftpd   #服务器端\nsudo vim /etc/vsftpd.conf     #可以默认 anonymous_enable=YES 可用anonymous作为用户名和密码登录\nsudo /etc/init.d/vsftpd restart  #重启服务\n\nftp 10.1.1.20   #连接服务器\n</code></pre><p>配置文件:vsftpd.conf   # 测试了一下 感觉默认设置就可以本地用户登录<br>可能需要改/etc/ftpusers  并重启  </p>\n<pre><code>local_root=/home/ftp  # 锁定共享目录 手动添加  可以不用\nlocal_enable=YES    #本机可以访问\nwrite_enable=YES    #允许写操作\n\n#chroot_local_user=YES\nchroot_list_enable=YES    # 限制实体用户在自己的主目录设定文件\n# (default follows)\nchroot_list_file=/etc/vsftpd.chroot_list\nsudo vim /etc/vsftpd.chroot_list     # 添加用户名\nsudo vim /etc/ftpusers  #这里面是不能访问ftp的用户  删除对应的\n</code></pre><h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"FTP命令\"><a href=\"#FTP命令\" class=\"headerlink\" title=\"FTP命令\"></a>FTP命令</h2><pre><code>ftp&gt; ascii # 设定以ASCII方式传送文件(缺省值) \nftp&gt; bell  # 每完成一次文件传送,报警提示. \nftp&gt; binary # 设定以二进制方式传送文件. \nftp&gt; bye  # 终止主机FTP进程,并退出FTP管理方式. \nftp&gt; case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. \nftp&gt; cd   # 同UNIX的CD命令. \nftp&gt; cdup  # 返回上一级目录. \nftp&gt; chmod # 改变远端主机的文件权限. \nftp&gt; close # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. \nftp&gt; delete # 删除远端主机中的文件. \nftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. \nftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. \nftp&gt; help [command] # 输出命令的解释. \nftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. \nftp&gt; ls [remote-directory] [local-file] # 同DIR. \nftp&gt; macdef         # 定义宏命令. \nftp&gt; mdelete [remote-files] # 删除一批文件. \nftp&gt; mget [remote-files]  # 从远端主机接收一批文件至本地主机. \nftp&gt; mkdir directory-name  # 在远端主机中建立目录. \nftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. \nftp&gt; open host [port] # 重新建立一个新的连接. \nftp&gt; prompt      # 交互提示模式. \nftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. \nftp&gt; pwd # 列出当前远端主机目录. \nftp&gt; quit # 同BYE. \nftp&gt; recv remote-file [local-file] # 同GET. \nftp&gt; rename [from] [to]   # 改变远端主机中的文件名. \nftp&gt; rmdir directory-name  # 删除远端主机中的目录. \nftp&gt; send local-file [remote-file] # 同PUT. \nftp&gt; status  # 显示当前FTP的状态. \nftp&gt; system  # 显示远端主机系统类型. \nftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. \nftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。\nftp&gt; ! # 从 ftp 子系统退出到外壳。\n</code></pre><h2 id=\"关闭FTP\"><a href=\"#关闭FTP\" class=\"headerlink\" title=\"关闭FTP\"></a>关闭FTP</h2><pre><code>bye\n\nexit\n\nquit\n</code></pre><h2 id=\"上传下载\"><a href=\"#上传下载\" class=\"headerlink\" title=\"上传下载\"></a>上传下载</h2><pre><code>ftp&gt; put /path/readme.txt # 上传 readme.txt 文件\nftp&gt; mput *.txt      # 可以上传多个文件\n\nftp&gt; get readme.txt # 下载 readme.txt 文件\nftp&gt; mget *.txt   # 下载\n</code></pre><p>win10上传下载 命令同Linux</p>\n<pre><code>cmd\nftp 10.1.1.20\n</code></pre><h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><pre><code>•230 - 登录成功\n•200 - 命令执行成功\n•150 - 文件状态正常，开启数据连接端口\n•250 - 目录切换操作完成\n•226 - 关闭数据连接端口，请求的文件操作成功 \n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.cnblogs.com/feiquan/p/9236768.html\" target=\"_blank\" rel=\"noopener\">Linux中ftp的常用命令</a></li>\n<li><ol>\n<li><a href=\"https://blog.csdn.net/Klein_yang/article/details/84954958\" target=\"_blank\" rel=\"noopener\">Ubuntu安装ftp服务</a></li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"FTP简介\"><a href=\"#FTP简介\" class=\"headerlink\" title=\"FTP简介\"></a>FTP简介</h1><p>文件传输协议(File Transfer Protocol)：传统网络传输协议，主要实现服务器和客户端之间的文件传输</p>\n<h1 id=\"FTP配置\"><a href=\"#FTP配置\" class=\"headerlink\" title=\"FTP配置\"></a>FTP配置</h1><p>匿名用户无法使用ls dir等命令查看文件</p>\n<hr>\n<pre><code>sudo apt-get install vsftpd   #服务器端\nsudo vim /etc/vsftpd.conf     #可以默认 anonymous_enable=YES 可用anonymous作为用户名和密码登录\nsudo /etc/init.d/vsftpd restart  #重启服务\n\nftp 10.1.1.20   #连接服务器\n</code></pre><p>配置文件:vsftpd.conf   # 测试了一下 感觉默认设置就可以本地用户登录<br>可能需要改/etc/ftpusers  并重启  </p>\n<pre><code>local_root=/home/ftp  # 锁定共享目录 手动添加  可以不用\nlocal_enable=YES    #本机可以访问\nwrite_enable=YES    #允许写操作\n\n#chroot_local_user=YES\nchroot_list_enable=YES    # 限制实体用户在自己的主目录设定文件\n# (default follows)\nchroot_list_file=/etc/vsftpd.chroot_list\nsudo vim /etc/vsftpd.chroot_list     # 添加用户名\nsudo vim /etc/ftpusers  #这里面是不能访问ftp的用户  删除对应的\n</code></pre><h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h2 id=\"FTP命令\"><a href=\"#FTP命令\" class=\"headerlink\" title=\"FTP命令\"></a>FTP命令</h2><pre><code>ftp&gt; ascii # 设定以ASCII方式传送文件(缺省值) \nftp&gt; bell  # 每完成一次文件传送,报警提示. \nftp&gt; binary # 设定以二进制方式传送文件. \nftp&gt; bye  # 终止主机FTP进程,并退出FTP管理方式. \nftp&gt; case # 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母. \nftp&gt; cd   # 同UNIX的CD命令. \nftp&gt; cdup  # 返回上一级目录. \nftp&gt; chmod # 改变远端主机的文件权限. \nftp&gt; close # 终止远端的FTP进程,返回到FTP命令状态, 所有的宏定义都被删除. \nftp&gt; delete # 删除远端主机中的文件. \nftp&gt; dir [remote-directory] [local-file] # 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件. \nftp&gt; get [remote-file] [local-file] # 从远端主机中传送至本地主机中. \nftp&gt; help [command] # 输出命令的解释. \nftp&gt; lcd # 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录. \nftp&gt; ls [remote-directory] [local-file] # 同DIR. \nftp&gt; macdef         # 定义宏命令. \nftp&gt; mdelete [remote-files] # 删除一批文件. \nftp&gt; mget [remote-files]  # 从远端主机接收一批文件至本地主机. \nftp&gt; mkdir directory-name  # 在远端主机中建立目录. \nftp&gt; mput local-files # 将本地主机中一批文件传送至远端主机. \nftp&gt; open host [port] # 重新建立一个新的连接. \nftp&gt; prompt      # 交互提示模式. \nftp&gt; put local-file [remote-file] # 将本地一个文件传送至远端主机中. \nftp&gt; pwd # 列出当前远端主机目录. \nftp&gt; quit # 同BYE. \nftp&gt; recv remote-file [local-file] # 同GET. \nftp&gt; rename [from] [to]   # 改变远端主机中的文件名. \nftp&gt; rmdir directory-name  # 删除远端主机中的目录. \nftp&gt; send local-file [remote-file] # 同PUT. \nftp&gt; status  # 显示当前FTP的状态. \nftp&gt; system  # 显示远端主机系统类型. \nftp&gt; user user-name [password] [account] # 重新以别的用户名登录远端主机. \nftp&gt; ? [command] # 同HELP. [command]指定需要帮助的命令名称。如果没有指定 command，ftp 将显示全部命令的列表。\nftp&gt; ! # 从 ftp 子系统退出到外壳。\n</code></pre><h2 id=\"关闭FTP\"><a href=\"#关闭FTP\" class=\"headerlink\" title=\"关闭FTP\"></a>关闭FTP</h2><pre><code>bye\n\nexit\n\nquit\n</code></pre><h2 id=\"上传下载\"><a href=\"#上传下载\" class=\"headerlink\" title=\"上传下载\"></a>上传下载</h2><pre><code>ftp&gt; put /path/readme.txt # 上传 readme.txt 文件\nftp&gt; mput *.txt      # 可以上传多个文件\n\nftp&gt; get readme.txt # 下载 readme.txt 文件\nftp&gt; mget *.txt   # 下载\n</code></pre><p>win10上传下载 命令同Linux</p>\n<pre><code>cmd\nftp 10.1.1.20\n</code></pre><h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><pre><code>•230 - 登录成功\n•200 - 命令执行成功\n•150 - 文件状态正常，开启数据连接端口\n•250 - 目录切换操作完成\n•226 - 关闭数据连接端口，请求的文件操作成功 \n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.cnblogs.com/feiquan/p/9236768.html\" target=\"_blank\" rel=\"noopener\">Linux中ftp的常用命令</a></li>\n<li><ol>\n<li><a href=\"https://blog.csdn.net/Klein_yang/article/details/84954958\" target=\"_blank\" rel=\"noopener\">Ubuntu安装ftp服务</a></li>\n</ol>\n</li>\n</ol>\n"},{"title":"Github SSH Key避免Hexo部署输入密码","date":"2019-10-01T08:19:16.000Z","_content":"# 操作\n前提: 已经生成ssh公钥放在github\n\n修改_config.yaml,将部署方式从https改为ssh\n    \n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: https://github.com/yangbenbo/yangbenbo.github.io.git\n      branch: master\n      \n改为\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:yangbenbo/yangbenbo.github.io.git\n      branch: master   \n# 注意事项\n1. ubuntu换内核(kernel)启动 需要重新上传ssh-key              \n      \n# 参考\n1. [使用Github SSH Key来避免Hexo部署时输入账户密码](https://www.cnblogs.com/yaoel/p/5381826.html)      ","source":"_posts/Github-SSH-Key避免Hexo部署输入密码.md","raw":"---\ntitle: Github SSH Key避免Hexo部署输入密码\ndate: 2019-10-01 16:19:16\ncategories:\n- Linux\ntags:\n- blog\n- ssh\n- hexo\n\n---\n# 操作\n前提: 已经生成ssh公钥放在github\n\n修改_config.yaml,将部署方式从https改为ssh\n    \n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: https://github.com/yangbenbo/yangbenbo.github.io.git\n      branch: master\n      \n改为\n\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n      type: git\n      repository: git@github.com:yangbenbo/yangbenbo.github.io.git\n      branch: master   \n# 注意事项\n1. ubuntu换内核(kernel)启动 需要重新上传ssh-key              \n      \n# 参考\n1. [使用Github SSH Key来避免Hexo部署时输入账户密码](https://www.cnblogs.com/yaoel/p/5381826.html)      ","slug":"Github-SSH-Key避免Hexo部署输入密码","published":1,"updated":"2020-09-23T14:42:00.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ch10001mxkawuxqkd4l","content":"<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><p>前提: 已经生成ssh公钥放在github</p>\n<p>修改_config.yaml,将部署方式从https改为ssh</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/yangbenbo/yangbenbo.github.io.git\n  branch: master\n</code></pre><p>改为</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:yangbenbo/yangbenbo.github.io.git\n  branch: master   \n</code></pre><h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><ol>\n<li>ubuntu换内核(kernel)启动 需要重新上传ssh-key              </li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.cnblogs.com/yaoel/p/5381826.html\" target=\"_blank\" rel=\"noopener\">使用Github SSH Key来避免Hexo部署时输入账户密码</a>      </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><p>前提: 已经生成ssh公钥放在github</p>\n<p>修改_config.yaml,将部署方式从https改为ssh</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/yangbenbo/yangbenbo.github.io.git\n  branch: master\n</code></pre><p>改为</p>\n<pre><code># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:yangbenbo/yangbenbo.github.io.git\n  branch: master   \n</code></pre><h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><ol>\n<li>ubuntu换内核(kernel)启动 需要重新上传ssh-key              </li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.cnblogs.com/yaoel/p/5381826.html\" target=\"_blank\" rel=\"noopener\">使用Github SSH Key来避免Hexo部署时输入账户密码</a>      </li>\n</ol>\n"},{"title":"Linux 正则表达式","date":"2019-11-02T01:22:39.000Z","_content":"\n# Linux 的正则表达式\nLinux有两套库可以使用POSIX PCRE 前面一种是Linux自带的\n1. 分隔符-分隔单词\n\n        \\< \\>\n        \\<[a-z]at\\>     # 后面这种行也会被匹配到  %$bat!* \n    \"单词\"指的是两侧由非单词字符分隔的字符串.非单词字符指字母 数字 下划线之外的任何字符\n2. 位置匹配\n    \n        ^a      # a开头\n        t$      # t结尾\n    \n3. 重复\n    \n        *       重复0次或多次\n        +       重复1次或多次\n        ?       重复0次或者1次\n        {n}     重复n次\n        {n,}    重复n次或者更多\n        {n,m}   重复n-m次\n4. 子表达式-分组\n        \n        egrep \"(or){2,}\"  xx/xx     # or重复2次或更多\n5. 反义\n\n    放在[]中,注意与匹配开头的 ^ 区别\n            \n        ^[^y]   # 不以字母y开头的所有行\n6. 分支\n    正则表达式简单执行\"与\"的组合 使用| 或者\n    \n        ^h|t&   # h开头或者t结尾\n7. 转义\n    \\ 取消所有元字符的特殊含义\n    \n        \\.  # 匹配.\n8. 逆向引用\n\n    子表达式(分组)捕获的内容可以在正则表达式的其他地方使用  使用 \\1 表示引用第一个分组捕获内容\n        \n        (\\<.*\\>).?( )*\\1    # 表示 匹配 某个单词出现后 紧跟0或1个标点符号以及任意多个空格后再次出现这个单词的行                                        \n            ","source":"_posts/Linux-正则表达式.md","raw":"---\ntitle: Linux 正则表达式\ndate: 2019-11-02 09:22:39\ncategories:\n- Linux\ntags:\n- 正则表达式\n---\n\n# Linux 的正则表达式\nLinux有两套库可以使用POSIX PCRE 前面一种是Linux自带的\n1. 分隔符-分隔单词\n\n        \\< \\>\n        \\<[a-z]at\\>     # 后面这种行也会被匹配到  %$bat!* \n    \"单词\"指的是两侧由非单词字符分隔的字符串.非单词字符指字母 数字 下划线之外的任何字符\n2. 位置匹配\n    \n        ^a      # a开头\n        t$      # t结尾\n    \n3. 重复\n    \n        *       重复0次或多次\n        +       重复1次或多次\n        ?       重复0次或者1次\n        {n}     重复n次\n        {n,}    重复n次或者更多\n        {n,m}   重复n-m次\n4. 子表达式-分组\n        \n        egrep \"(or){2,}\"  xx/xx     # or重复2次或更多\n5. 反义\n\n    放在[]中,注意与匹配开头的 ^ 区别\n            \n        ^[^y]   # 不以字母y开头的所有行\n6. 分支\n    正则表达式简单执行\"与\"的组合 使用| 或者\n    \n        ^h|t&   # h开头或者t结尾\n7. 转义\n    \\ 取消所有元字符的特殊含义\n    \n        \\.  # 匹配.\n8. 逆向引用\n\n    子表达式(分组)捕获的内容可以在正则表达式的其他地方使用  使用 \\1 表示引用第一个分组捕获内容\n        \n        (\\<.*\\>).?( )*\\1    # 表示 匹配 某个单词出现后 紧跟0或1个标点符号以及任意多个空格后再次出现这个单词的行                                        \n            ","slug":"Linux-正则表达式","published":1,"updated":"2020-09-23T14:42:00.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ch40004mxka64elno8d","content":"<h1 id=\"Linux-的正则表达式\"><a href=\"#Linux-的正则表达式\" class=\"headerlink\" title=\"Linux 的正则表达式\"></a>Linux 的正则表达式</h1><p>Linux有两套库可以使用POSIX PCRE 前面一种是Linux自带的</p>\n<ol>\n<li><p>分隔符-分隔单词</p>\n<pre><code> \\&lt; \\&gt;\n \\&lt;[a-z]at\\&gt;     # 后面这种行也会被匹配到  %$bat!* \n</code></pre><p> “单词”指的是两侧由非单词字符分隔的字符串.非单词字符指字母 数字 下划线之外的任何字符</p>\n</li>\n<li><p>位置匹配</p>\n<pre><code> ^a      # a开头\n t$      # t结尾\n</code></pre></li>\n<li><p>重复</p>\n<pre><code> *       重复0次或多次\n +       重复1次或多次\n ?       重复0次或者1次\n {n}     重复n次\n {n,}    重复n次或者更多\n {n,m}   重复n-m次\n</code></pre></li>\n<li><p>子表达式-分组</p>\n<pre><code> egrep &quot;(or){2,}&quot;  xx/xx     # or重复2次或更多\n</code></pre></li>\n<li><p>反义</p>\n<p> 放在[]中,注意与匹配开头的 ^ 区别</p>\n<pre><code> ^[^y]   # 不以字母y开头的所有行\n</code></pre></li>\n<li><p>分支<br> 正则表达式简单执行”与”的组合 使用| 或者</p>\n<pre><code> ^h|t&amp;   # h开头或者t结尾\n</code></pre></li>\n<li><p>转义<br> \\ 取消所有元字符的特殊含义</p>\n<pre><code> \\.  # 匹配.\n</code></pre></li>\n<li><p>逆向引用</p>\n<p> 子表达式(分组)捕获的内容可以在正则表达式的其他地方使用  使用 \\1 表示引用第一个分组捕获内容</p>\n<pre><code> (\\&lt;.*\\&gt;).?( )*\\1    # 表示 匹配 某个单词出现后 紧跟0或1个标点符号以及任意多个空格后再次出现这个单词的行                                        \n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux-的正则表达式\"><a href=\"#Linux-的正则表达式\" class=\"headerlink\" title=\"Linux 的正则表达式\"></a>Linux 的正则表达式</h1><p>Linux有两套库可以使用POSIX PCRE 前面一种是Linux自带的</p>\n<ol>\n<li><p>分隔符-分隔单词</p>\n<pre><code> \\&lt; \\&gt;\n \\&lt;[a-z]at\\&gt;     # 后面这种行也会被匹配到  %$bat!* \n</code></pre><p> “单词”指的是两侧由非单词字符分隔的字符串.非单词字符指字母 数字 下划线之外的任何字符</p>\n</li>\n<li><p>位置匹配</p>\n<pre><code> ^a      # a开头\n t$      # t结尾\n</code></pre></li>\n<li><p>重复</p>\n<pre><code> *       重复0次或多次\n +       重复1次或多次\n ?       重复0次或者1次\n {n}     重复n次\n {n,}    重复n次或者更多\n {n,m}   重复n-m次\n</code></pre></li>\n<li><p>子表达式-分组</p>\n<pre><code> egrep &quot;(or){2,}&quot;  xx/xx     # or重复2次或更多\n</code></pre></li>\n<li><p>反义</p>\n<p> 放在[]中,注意与匹配开头的 ^ 区别</p>\n<pre><code> ^[^y]   # 不以字母y开头的所有行\n</code></pre></li>\n<li><p>分支<br> 正则表达式简单执行”与”的组合 使用| 或者</p>\n<pre><code> ^h|t&amp;   # h开头或者t结尾\n</code></pre></li>\n<li><p>转义<br> \\ 取消所有元字符的特殊含义</p>\n<pre><code> \\.  # 匹配.\n</code></pre></li>\n<li><p>逆向引用</p>\n<p> 子表达式(分组)捕获的内容可以在正则表达式的其他地方使用  使用 \\1 表示引用第一个分组捕获内容</p>\n<pre><code> (\\&lt;.*\\&gt;).?( )*\\1    # 表示 匹配 某个单词出现后 紧跟0或1个标点符号以及任意多个空格后再次出现这个单词的行                                        \n</code></pre></li>\n</ol>\n"},{"title":"Linux进程管理","date":"2019-10-02T01:28:29.000Z","_content":"\n# Linux进程\nLinux是一个多用户多任务的操作系统。init进程是所有进程的发起者和控制者，每个进程\n都有一个编号，PID(Process ID)，是在当前系统中的运行顺序，init进程在系统运行期间不会消亡或停止\n\n## 进程管理常用命令\n1. 查看进程状态\n\n    ps aux      #静态查看系统中所有进程信息\n    top         #动态查看  P M T 分别按照CPU Memory Time排序\n    \n2. 设置优先级 nice [-n][command][arguments]   #优先级-20 - 19 默认为0 -20最高\n    \n    nice  --12 processname   #-12\n    renice          #修改优先级\n3. 终止进程\n\n    kill[-signal] PID   #不带参数默认15 即终止进程 \n    kill -l             #查看可选signal\n    kill -CONT  4385    #重新开始进程\n    kill -9 4385        #强制终止\n    kill -STOP 4385     #停止但不退出\n    \n    killall [-signal] [processname]  #终止所有名为processname的进程\n    \n# 临时和周期任务安排\n\n待补充    \n        ","source":"_posts/Linux进程管理.md","raw":"---\ntitle: Linux进程管理\ndate: 2019-10-02 09:28:29\ncategories:\n- Linux\n\ntags:\n\n\n---\n\n# Linux进程\nLinux是一个多用户多任务的操作系统。init进程是所有进程的发起者和控制者，每个进程\n都有一个编号，PID(Process ID)，是在当前系统中的运行顺序，init进程在系统运行期间不会消亡或停止\n\n## 进程管理常用命令\n1. 查看进程状态\n\n    ps aux      #静态查看系统中所有进程信息\n    top         #动态查看  P M T 分别按照CPU Memory Time排序\n    \n2. 设置优先级 nice [-n][command][arguments]   #优先级-20 - 19 默认为0 -20最高\n    \n    nice  --12 processname   #-12\n    renice          #修改优先级\n3. 终止进程\n\n    kill[-signal] PID   #不带参数默认15 即终止进程 \n    kill -l             #查看可选signal\n    kill -CONT  4385    #重新开始进程\n    kill -9 4385        #强制终止\n    kill -STOP 4385     #停止但不退出\n    \n    killall [-signal] [processname]  #终止所有名为processname的进程\n    \n# 临时和周期任务安排\n\n待补充    \n        ","slug":"Linux进程管理","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ch50005mxkaxclpyb3o","content":"<h1 id=\"Linux进程\"><a href=\"#Linux进程\" class=\"headerlink\" title=\"Linux进程\"></a>Linux进程</h1><p>Linux是一个多用户多任务的操作系统。init进程是所有进程的发起者和控制者，每个进程<br>都有一个编号，PID(Process ID)，是在当前系统中的运行顺序，init进程在系统运行期间不会消亡或停止</p>\n<h2 id=\"进程管理常用命令\"><a href=\"#进程管理常用命令\" class=\"headerlink\" title=\"进程管理常用命令\"></a>进程管理常用命令</h2><ol>\n<li><p>查看进程状态</p>\n<p> ps aux      #静态查看系统中所有进程信息<br> top         #动态查看  P M T 分别按照CPU Memory Time排序</p>\n</li>\n<li><p>设置优先级 nice [-n][command][arguments]   #优先级-20 - 19 默认为0 -20最高</p>\n<p> nice  —12 processname   #-12<br> renice          #修改优先级</p>\n</li>\n<li><p>终止进程</p>\n<p> kill[-signal] PID   #不带参数默认15 即终止进程<br> kill -l             #查看可选signal<br> kill -CONT  4385    #重新开始进程<br> kill -9 4385        #强制终止<br> kill -STOP 4385     #停止但不退出</p>\n<p> killall [-signal] [processname]  #终止所有名为processname的进程</p>\n</li>\n</ol>\n<h1 id=\"临时和周期任务安排\"><a href=\"#临时和周期任务安排\" class=\"headerlink\" title=\"临时和周期任务安排\"></a>临时和周期任务安排</h1><p>待补充    </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux进程\"><a href=\"#Linux进程\" class=\"headerlink\" title=\"Linux进程\"></a>Linux进程</h1><p>Linux是一个多用户多任务的操作系统。init进程是所有进程的发起者和控制者，每个进程<br>都有一个编号，PID(Process ID)，是在当前系统中的运行顺序，init进程在系统运行期间不会消亡或停止</p>\n<h2 id=\"进程管理常用命令\"><a href=\"#进程管理常用命令\" class=\"headerlink\" title=\"进程管理常用命令\"></a>进程管理常用命令</h2><ol>\n<li><p>查看进程状态</p>\n<p> ps aux      #静态查看系统中所有进程信息<br> top         #动态查看  P M T 分别按照CPU Memory Time排序</p>\n</li>\n<li><p>设置优先级 nice [-n][command][arguments]   #优先级-20 - 19 默认为0 -20最高</p>\n<p> nice  —12 processname   #-12<br> renice          #修改优先级</p>\n</li>\n<li><p>终止进程</p>\n<p> kill[-signal] PID   #不带参数默认15 即终止进程<br> kill -l             #查看可选signal<br> kill -CONT  4385    #重新开始进程<br> kill -9 4385        #强制终止<br> kill -STOP 4385     #停止但不退出</p>\n<p> killall [-signal] [processname]  #终止所有名为processname的进程</p>\n</li>\n</ol>\n<h1 id=\"临时和周期任务安排\"><a href=\"#临时和周期任务安排\" class=\"headerlink\" title=\"临时和周期任务安排\"></a>临时和周期任务安排</h1><p>待补充    </p>\n"},{"title":"Linux + Qt5 + ROS配置Qwtplot3d","date":"2020-05-12T12:09:33.000Z","_content":"\nqwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.\n\n##　Qt项目使用QwtPlot3d\n1. 安装OpenGL(QwtPlot3d需要OpenGL作为基础)\n    这一步网上很多教程,我之前装过,这里略过\n2. 下载QwtPlot3d压缩包两种选择,建议选a\n    \n    a. 下载分支[multiple_curves_0_2_x](https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/) 可以一个画面绘制多个图形\n    \n    b. 下载[qwt-plot3d](https://sourceforge.net/projects/qwtplot3d/) [修改参考](https://blog.csdn.net/eastonwoo/article/details/37658141)\n    \n    第一种方式顺利编译\n    \n    第二种方式,出现的问题 \n    \n        ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);\n    解决方式\n        \n           在include/qwt3d_openglhelper.h这个文件里添加 #include <GL/glu.h>\n           打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            \n3. 打开qwtplot3d.pro, 选择Release\n    \n    两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件\n        \n    复制这四个文件到存放lib文件的目录,可以自己指定,我的是\n    \n        /opt/qt59/lib/x86_64-linux-gnu/qtcreator/\n4. 打开qwtplot3d/examples/simpleplot/simpleplot.pro\n\n        # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置\n        # 其实把库文件放在原本指定的位置../../lib也可以编译成功\n        unix:LIBS += -lqwtplot3d -L../../lib\n        unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d\n        \n    其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),\n    simpleplot只用指定库是因为项目中指定了头文件位置\n            \n    运行程序如下      \n    ![simpleplot](simpleplot_mult.png)    \n       \n## ROS CmakeLists.txt使用QwtPlot3d\n    \n    # 把头文件拷贝到include/qwt 下并包含\n    include_directories(${catkin_INCLUDE_DIRS}\n        include/qwt)\n    # 寻找OpenGL 这是底层库\n    find_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)\n    # 设置库文件路径\n    set(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added\n    # 生成可执行程序并链接库\n    add_executable(qwtdemo  src/traj_graph.cpp)\n    target_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}\n        qwtplot3d ) \n**特别注意:**\n    \n    file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS\n        include/qtgui/*.hpp include/qtgui/*.h\n        )        \n这一句如果直接使用*.h,则会在建立的包内匹配*h(include src...),b方式即使把提供头文件包含进来也没问题,\na方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt\n    \n    #  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)'\n    /home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)'\n    \n          \n注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考[Linux 中的动态链接库和静态链接库是干什么的？](https://www.zhihu.com/question/20484931/answer/69553616)\n    \n1. 指定相对位置(推荐,成功率高)\n        \n        # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置\n        LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径\n\n2. 指定绝对位置\n    \n        # CmakeLists.txt 添加库文件路径(之前存放的路径)\n        LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径\n        \n3. 添加路径到变量LD_LIBRARY_PATH\n    \n        # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功\n        export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}\n4. 修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令\n    \n    这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径\n    以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)\n                        \n## 引用\n1. [Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装](https://blog.csdn.net/qq_41800188/article/details/87891586)\n2. [QT5 r 加入qwtplot3d 三维库](https://blog.csdn.net/EastonWoo/article/details/37658141)\n3. [linux下添加动态链接库路径的方法](https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n                                          ","source":"_posts/Linux-Qt5-ROS配置Qwtplot3d.md","raw":"---\ntitle: Linux + Qt5 + ROS配置Qwtplot3d\ndate: 2020-05-12 20:09:33\ncategories:\n- Linux\ntags:\n- Qt\n- ROS\n---\n\nqwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.\n\n##　Qt项目使用QwtPlot3d\n1. 安装OpenGL(QwtPlot3d需要OpenGL作为基础)\n    这一步网上很多教程,我之前装过,这里略过\n2. 下载QwtPlot3d压缩包两种选择,建议选a\n    \n    a. 下载分支[multiple_curves_0_2_x](https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/) 可以一个画面绘制多个图形\n    \n    b. 下载[qwt-plot3d](https://sourceforge.net/projects/qwtplot3d/) [修改参考](https://blog.csdn.net/eastonwoo/article/details/37658141)\n    \n    第一种方式顺利编译\n    \n    第二种方式,出现的问题 \n    \n        ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);\n    解决方式\n        \n           在include/qwt3d_openglhelper.h这个文件里添加 #include <GL/glu.h>\n           打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            \n3. 打开qwtplot3d.pro, 选择Release\n    \n    两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件\n        \n    复制这四个文件到存放lib文件的目录,可以自己指定,我的是\n    \n        /opt/qt59/lib/x86_64-linux-gnu/qtcreator/\n4. 打开qwtplot3d/examples/simpleplot/simpleplot.pro\n\n        # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置\n        # 其实把库文件放在原本指定的位置../../lib也可以编译成功\n        unix:LIBS += -lqwtplot3d -L../../lib\n        unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d\n        \n    其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),\n    simpleplot只用指定库是因为项目中指定了头文件位置\n            \n    运行程序如下      \n    ![simpleplot](simpleplot_mult.png)    \n       \n## ROS CmakeLists.txt使用QwtPlot3d\n    \n    # 把头文件拷贝到include/qwt 下并包含\n    include_directories(${catkin_INCLUDE_DIRS}\n        include/qwt)\n    # 寻找OpenGL 这是底层库\n    find_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)\n    # 设置库文件路径\n    set(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added\n    # 生成可执行程序并链接库\n    add_executable(qwtdemo  src/traj_graph.cpp)\n    target_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}\n        qwtplot3d ) \n**特别注意:**\n    \n    file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS\n        include/qtgui/*.hpp include/qtgui/*.h\n        )        \n这一句如果直接使用*.h,则会在建立的包内匹配*h(include src...),b方式即使把提供头文件包含进来也没问题,\na方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt\n    \n    #  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)'\n    /home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)'\n    \n          \n注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考[Linux 中的动态链接库和静态链接库是干什么的？](https://www.zhihu.com/question/20484931/answer/69553616)\n    \n1. 指定相对位置(推荐,成功率高)\n        \n        # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置\n        LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径\n\n2. 指定绝对位置\n    \n        # CmakeLists.txt 添加库文件路径(之前存放的路径)\n        LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径\n        \n3. 添加路径到变量LD_LIBRARY_PATH\n    \n        # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功\n        export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}\n4. 修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令\n    \n    这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径\n    以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)\n                        \n## 引用\n1. [Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装](https://blog.csdn.net/qq_41800188/article/details/87891586)\n2. [QT5 r 加入qwtplot3d 三维库](https://blog.csdn.net/EastonWoo/article/details/37658141)\n3. [linux下添加动态链接库路径的方法](https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)\n                                          ","slug":"Linux-Qt5-ROS配置Qwtplot3d","published":1,"updated":"2020-09-23T14:42:00.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ch60006mxka5dgtb46g","content":"<p>qwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.</p>\n<h2 id=\"Qt项目使用QwtPlot3d\"><a href=\"#Qt项目使用QwtPlot3d\" class=\"headerlink\" title=\"　Qt项目使用QwtPlot3d\"></a>　Qt项目使用QwtPlot3d</h2><ol>\n<li>安装OpenGL(QwtPlot3d需要OpenGL作为基础)<br> 这一步网上很多教程,我之前装过,这里略过</li>\n<li><p>下载QwtPlot3d压缩包两种选择,建议选a</p>\n<p> a. 下载分支<a href=\"https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/\" target=\"_blank\" rel=\"noopener\">multiple_curves_0_2_x</a> 可以一个画面绘制多个图形</p>\n<p> b. 下载<a href=\"https://sourceforge.net/projects/qwtplot3d/\" target=\"_blank\" rel=\"noopener\">qwt-plot3d</a> <a href=\"https://blog.csdn.net/eastonwoo/article/details/37658141\" target=\"_blank\" rel=\"noopener\">修改参考</a></p>\n<p> 第一种方式顺利编译</p>\n<p> 第二种方式,出现的问题 </p>\n<pre><code> ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);\n</code></pre><p> 解决方式</p>\n<pre><code>    在include/qwt3d_openglhelper.h这个文件里添加 #include &lt;GL/glu.h&gt;\n    打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            \n</code></pre></li>\n<li><p>打开qwtplot3d.pro, 选择Release</p>\n<p> 两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件</p>\n<p> 复制这四个文件到存放lib文件的目录,可以自己指定,我的是</p>\n<pre><code> /opt/qt59/lib/x86_64-linux-gnu/qtcreator/\n</code></pre></li>\n<li><p>打开qwtplot3d/examples/simpleplot/simpleplot.pro</p>\n<pre><code> # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置\n # 其实把库文件放在原本指定的位置../../lib也可以编译成功\n unix:LIBS += -lqwtplot3d -L../../lib\n unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d\n</code></pre><p> 其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),<br> simpleplot只用指定库是因为项目中指定了头文件位置</p>\n<p> 运行程序如下<br> <img src=\"/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png\" alt=\"simpleplot\">    </p>\n</li>\n</ol>\n<h2 id=\"ROS-CmakeLists-txt使用QwtPlot3d\"><a href=\"#ROS-CmakeLists-txt使用QwtPlot3d\" class=\"headerlink\" title=\"ROS CmakeLists.txt使用QwtPlot3d\"></a>ROS CmakeLists.txt使用QwtPlot3d</h2><pre><code># 把头文件拷贝到include/qwt 下并包含\ninclude_directories(${catkin_INCLUDE_DIRS}\n    include/qwt)\n# 寻找OpenGL 这是底层库\nfind_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)\n# 设置库文件路径\nset(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added\n# 生成可执行程序并链接库\nadd_executable(qwtdemo  src/traj_graph.cpp)\ntarget_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}\n    qwtplot3d ) \n</code></pre><p><strong>特别注意:</strong></p>\n<pre><code>file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS\n    include/qtgui/*.hpp include/qtgui/*.h\n    )        \n</code></pre><p>这一句如果直接使用<em>.h,则会在建立的包内匹配</em>h(include src…),b方式即使把提供头文件包含进来也没问题,<br>a方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt</p>\n<pre><code>#  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;\n/home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;\n</code></pre><p>注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考<a href=\"https://www.zhihu.com/question/20484931/answer/69553616\" target=\"_blank\" rel=\"noopener\">Linux 中的动态链接库和静态链接库是干什么的？</a></p>\n<ol>\n<li><p>指定相对位置(推荐,成功率高)</p>\n<pre><code> # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置\n LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径\n</code></pre></li>\n<li><p>指定绝对位置</p>\n<pre><code> # CmakeLists.txt 添加库文件路径(之前存放的路径)\n LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径\n</code></pre></li>\n<li><p>添加路径到变量LD_LIBRARY_PATH</p>\n<pre><code> # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功\n export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}\n</code></pre></li>\n<li><p>修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令</p>\n<p> 这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径<br> 以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)</p>\n</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/qq_41800188/article/details/87891586\" target=\"_blank\" rel=\"noopener\">Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装</a></li>\n<li><a href=\"https://blog.csdn.net/EastonWoo/article/details/37658141\" target=\"_blank\" rel=\"noopener\">QT5 r 加入qwtplot3d 三维库</a></li>\n<li><a href=\"https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\" target=\"_blank\" rel=\"noopener\">linux下添加动态链接库路径的方法</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>qwtplot3D是一个Qt第三方库,在OpenGL基础上封装了一层可以用来三维绘图.</p>\n<h2 id=\"Qt项目使用QwtPlot3d\"><a href=\"#Qt项目使用QwtPlot3d\" class=\"headerlink\" title=\"　Qt项目使用QwtPlot3d\"></a>　Qt项目使用QwtPlot3d</h2><ol>\n<li>安装OpenGL(QwtPlot3d需要OpenGL作为基础)<br> 这一步网上很多教程,我之前装过,这里略过</li>\n<li><p>下载QwtPlot3d压缩包两种选择,建议选a</p>\n<p> a. 下载分支<a href=\"https://sourceforge.net/p/qwtplot3d/code/HEAD/tree/branches/multiple_curves_0_2_x/\" target=\"_blank\" rel=\"noopener\">multiple_curves_0_2_x</a> 可以一个画面绘制多个图形</p>\n<p> b. 下载<a href=\"https://sourceforge.net/projects/qwtplot3d/\" target=\"_blank\" rel=\"noopener\">qwt-plot3d</a> <a href=\"https://blog.csdn.net/eastonwoo/article/details/37658141\" target=\"_blank\" rel=\"noopener\">修改参考</a></p>\n<p> 第一种方式顺利编译</p>\n<p> 第二种方式,出现的问题 </p>\n<pre><code> ‘gluErrorString’ was not declared in this scope err = gluErrorString(errcode);\n</code></pre><p> 解决方式</p>\n<pre><code>    在include/qwt3d_openglhelper.h这个文件里添加 #include &lt;GL/glu.h&gt;\n    打开 qwtplot3d.pro , 在最前面输入下面这一句  LIBS += -lGLU            \n</code></pre></li>\n<li><p>打开qwtplot3d.pro, 选择Release</p>\n<p> 两种方式都可以编译后在编译文件夹找到4个libqwtplot3d.so*文件</p>\n<p> 复制这四个文件到存放lib文件的目录,可以自己指定,我的是</p>\n<pre><code> /opt/qt59/lib/x86_64-linux-gnu/qtcreator/\n</code></pre></li>\n<li><p>打开qwtplot3d/examples/simpleplot/simpleplot.pro</p>\n<pre><code> # 将第一句改为这二句 其实就是指定刚才生成的动态链接库的位置\n # 其实把库文件放在原本指定的位置../../lib也可以编译成功\n unix:LIBS += -lqwtplot3d -L../../lib\n unix:LIBS += -L/opt/qt59/lib/x86_64-linux-gnu/qtcreator/ -lqwtplot3d\n</code></pre><p> 其他项目使用需要生成的库文件.so 以及头文件 .h(qwtplot3d/include下),<br> simpleplot只用指定库是因为项目中指定了头文件位置</p>\n<p> 运行程序如下<br> <img src=\"/2020/05/12/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png\" alt=\"simpleplot\">    </p>\n</li>\n</ol>\n<h2 id=\"ROS-CmakeLists-txt使用QwtPlot3d\"><a href=\"#ROS-CmakeLists-txt使用QwtPlot3d\" class=\"headerlink\" title=\"ROS CmakeLists.txt使用QwtPlot3d\"></a>ROS CmakeLists.txt使用QwtPlot3d</h2><pre><code># 把头文件拷贝到include/qwt 下并包含\ninclude_directories(${catkin_INCLUDE_DIRS}\n    include/qwt)\n# 寻找OpenGL 这是底层库\nfind_package(Qt5 COMPONENTS Core Widgets OpenGL REQUIRED)\n# 设置库文件路径\nset(QT_LIBRARIES Qt5::Widgets Qt5::OpenGL)#added\n# 生成可执行程序并链接库\nadd_executable(qwtdemo  src/traj_graph.cpp)\ntarget_link_libraries(qwtdemo ${QT_LIBRARIES} ${catkin_LIBRARIES}\n    qwtplot3d ) \n</code></pre><p><strong>特别注意:</strong></p>\n<pre><code>file(GLOB_RECURSE QT_MOC RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} FOLLOW_SYMLINKS\n    include/qtgui/*.hpp include/qtgui/*.h\n    )        \n</code></pre><p>这一句如果直接使用<em>.h,则会在建立的包内匹配</em>h(include src…),b方式即使把提供头文件包含进来也没问题,<br>a方式出错 需要排除qwtplot3d提供的头文件 这里我新建了一个文件include/qwt</p>\n<pre><code>#  a方式出错 error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;\n/home/yang/project/cam/test/build/qtgui/include/qwt/moc_qwt3d_surfaceplot.cpp:78: error: undefined reference to `Qwt3D::SurfacePlot::setResolution(int)&#39;\n</code></pre><p>注意到上面只处理了头文件包含,对于库文件有多种处理方式,库文件又分为静态库和动态库,可参考<a href=\"https://www.zhihu.com/question/20484931/answer/69553616\" target=\"_blank\" rel=\"noopener\">Linux 中的动态链接库和静态链接库是干什么的？</a></p>\n<ol>\n<li><p>指定相对位置(推荐,成功率高)</p>\n<pre><code> # 把库文件.so复制到项目内与src同级目录lib, 然后在CmakeLists.txt指定相对位置\n LINK_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/lib)   ## 添加动态库路径\n</code></pre></li>\n<li><p>指定绝对位置</p>\n<pre><code> # CmakeLists.txt 添加库文件路径(之前存放的路径)\n LINK_DIRECTORIES(/opt/qt59/lib/x86_64-linux-gnu/qtcreator/)   ## 添加动态库路径\n</code></pre></li>\n<li><p>添加路径到变量LD_LIBRARY_PATH</p>\n<pre><code> # ~/.bashrc 下添加下面这句,然后重开终端启动qtcreator 但是我没成功\n export LD_LIBRARY_PATH=/opt/qt59/lib/x86_64-linux-gnu/qtcreator:${LD_LIBRARY_PATH}\n</code></pre></li>\n<li><p>修改/etc/ld.so.conf,添加路径,运行sudo ldconfig命令</p>\n<p> 这是一个系统动态链接库路径配置文件,我尝试过/etc/ld.so.conf 添加库文件路径<br> 以及在指定的目录下增加XXX.conf都不行,最后是直接拷贝到包含的一个目录下成功的(/usr/lib/x86_64-linux-gnu/)</p>\n</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/qq_41800188/article/details/87891586\" target=\"_blank\" rel=\"noopener\">Ubuntu Linux 16.04 LTS + Qt5.5.1 + Qwtplot3d配置安装</a></li>\n<li><a href=\"https://blog.csdn.net/EastonWoo/article/details/37658141\" target=\"_blank\" rel=\"noopener\">QT5 r 加入qwtplot3d 三维库</a></li>\n<li><a href=\"https://blog.csdn.net/zxh2075/article/details/54629318?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase\" target=\"_blank\" rel=\"noopener\">linux下添加动态链接库路径的方法</a></li>\n</ol>\n"},{"title":"Markdown语法","date":"2019-07-14T08:44:31.000Z","_content":"\n区块元素\n===\n\n标题\n---\nMarkdown常用语法 =（最高级标题），-（第二阶标题）\n\n\t最高级标题\n\t=\n\t二级标题\n\t-\n\t\n\n区块引用\n---\n先断好行，< 放在句首  一般标识符和后面内容之间需要**空格**\n\n\t> tab 缩进\n\t> \n\t> >支持嵌套\n\t\n\n\n列表\n---\n无序列表使用 * + -，有序列表 数字 + .\n\n\t* 无序列表\n\t1. 有序列表\n\t\n\n行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n\t<1986\\. What a great season.\n\t\n代码区块\n---\n缩进4个空格或者1个制表符，显示成原来的样子\n\n\t这是一个普通段落：\n    \t这是一个代码区块。\n\t\n\t\n分割线\n---\n三个以上的* 、 - 、底线 建立分割线，行内没有其它东西，中间可以有空格\n\n\t- - -\n\t***\n\t——————\n\t\n\n区段元素\n===\n链接\n---\n\n\tThis is [an example](http://example.com/ \"Title\") inline link.\n\t\n\t[This link](http://example.net/) has no title attribute.\n\n\t\n\tThis is [an example] [1] reference-style link.\n然后在文件任意处\n\n\t[1]:http://example.com/  \"Optional Title Here\"\n\n隐式链接\n\n\t[Google][]\n\n\t[Google]: http://google.com/\n\t\n\t\n强调\n---\n使用 * 和 _\t包围，**如果强调两边都有空格，就会被当成普通的符号**\n\t\n\t**强调文字**\n\n\t_strong_\n\t\n\n代码\n---\n标记一小段，用  `\n\n\tUse the `printf()` function.\n\n代码中间有反引号，可用多个反引开启或者结束代码区域\n\n\t``There is a literal backtick ` here.``\n\t\n\n图片\n---\n\t![Alt text](/path/to/img.jpg)\n\n\t![Alt text](/path/to/img.jpg \"Optional title\")\n\t\n\n其它\n===\n\n自动链接\n---\n\n\t<http://example.com/>\n\t\n\n反斜杠\n---\n输出含有其他意义符号原本符号\n\n\t\\*literal asterisks\\*\n\n\n引用\n===\n1. [Markdown 语法说明 (简体中文版)](http://wow.kuapp.com/markdown/)，以及[github 地址](https://github.com/riku/Markdown-Syntax-CN/)\n2. [Markdown中文文档](https://markdown-zh.readthedocs.io/en/latest/)","source":"_posts/Markdown语法.md","raw":"---\ntitle: Markdown语法\ndate: 2019-07-14 16:44:31\ncategories:\n- program\ntags:\n- program\n- blog\n\n---\n\n区块元素\n===\n\n标题\n---\nMarkdown常用语法 =（最高级标题），-（第二阶标题）\n\n\t最高级标题\n\t=\n\t二级标题\n\t-\n\t\n\n区块引用\n---\n先断好行，< 放在句首  一般标识符和后面内容之间需要**空格**\n\n\t> tab 缩进\n\t> \n\t> >支持嵌套\n\t\n\n\n列表\n---\n无序列表使用 * + -，有序列表 数字 + .\n\n\t* 无序列表\n\t1. 有序列表\n\t\n\n行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n\t<1986\\. What a great season.\n\t\n代码区块\n---\n缩进4个空格或者1个制表符，显示成原来的样子\n\n\t这是一个普通段落：\n    \t这是一个代码区块。\n\t\n\t\n分割线\n---\n三个以上的* 、 - 、底线 建立分割线，行内没有其它东西，中间可以有空格\n\n\t- - -\n\t***\n\t——————\n\t\n\n区段元素\n===\n链接\n---\n\n\tThis is [an example](http://example.com/ \"Title\") inline link.\n\t\n\t[This link](http://example.net/) has no title attribute.\n\n\t\n\tThis is [an example] [1] reference-style link.\n然后在文件任意处\n\n\t[1]:http://example.com/  \"Optional Title Here\"\n\n隐式链接\n\n\t[Google][]\n\n\t[Google]: http://google.com/\n\t\n\t\n强调\n---\n使用 * 和 _\t包围，**如果强调两边都有空格，就会被当成普通的符号**\n\t\n\t**强调文字**\n\n\t_strong_\n\t\n\n代码\n---\n标记一小段，用  `\n\n\tUse the `printf()` function.\n\n代码中间有反引号，可用多个反引开启或者结束代码区域\n\n\t``There is a literal backtick ` here.``\n\t\n\n图片\n---\n\t![Alt text](/path/to/img.jpg)\n\n\t![Alt text](/path/to/img.jpg \"Optional title\")\n\t\n\n其它\n===\n\n自动链接\n---\n\n\t<http://example.com/>\n\t\n\n反斜杠\n---\n输出含有其他意义符号原本符号\n\n\t\\*literal asterisks\\*\n\n\n引用\n===\n1. [Markdown 语法说明 (简体中文版)](http://wow.kuapp.com/markdown/)，以及[github 地址](https://github.com/riku/Markdown-Syntax-CN/)\n2. [Markdown中文文档](https://markdown-zh.readthedocs.io/en/latest/)","slug":"Markdown语法","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cha000amxkalkzlp26a","content":"<h1 id=\"区块元素\"><a href=\"#区块元素\" class=\"headerlink\" title=\"区块元素\"></a>区块元素</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>Markdown常用语法 =（最高级标题），-（第二阶标题）</p>\n<pre><code>最高级标题\n=\n二级标题\n-\n</code></pre><h2 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h2><p>先断好行，&lt; 放在句首  一般标识符和后面内容之间需要<strong>空格</strong></p>\n<pre><code>&gt; tab 缩进\n&gt; \n&gt; &gt;支持嵌套\n</code></pre><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表使用 * + -，有序列表 数字 + .</p>\n<pre><code>* 无序列表\n1. 有序列表\n</code></pre><p>行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。</p>\n<pre><code>&lt;1986\\. What a great season.\n</code></pre><h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>缩进4个空格或者1个制表符，显示成原来的样子</p>\n<pre><code>这是一个普通段落：\n    这是一个代码区块。\n</code></pre><h2 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h2><p>三个以上的* 、 - 、底线 建立分割线，行内没有其它东西，中间可以有空格</p>\n<pre><code>- - -\n***\n——————\n</code></pre><h1 id=\"区段元素\"><a href=\"#区段元素\" class=\"headerlink\" title=\"区段元素\"></a>区段元素</h1><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n\nThis is [an example] [1] reference-style link.\n</code></pre><p>然后在文件任意处</p>\n<pre><code>[1]:http://example.com/  &quot;Optional Title Here&quot;\n</code></pre><p>隐式链接</p>\n<pre><code>[Google][]\n\n[Google]: http://google.com/\n</code></pre><h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>使用 <em> 和 _    包围，<em>*如果强调两边都有空格，就会被当成普通的符号</em></em></p>\n<pre><code>**强调文字**\n\n_strong_\n</code></pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>标记一小段，用  `</p>\n<pre><code>Use the `printf()` function.\n</code></pre><p>代码中间有反引号，可用多个反引开启或者结束代码区域</p>\n<pre><code>``There is a literal backtick ` here.``\n</code></pre><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><pre><code>![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n</code></pre><h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h2><pre><code>&lt;http://example.com/&gt;\n</code></pre><h2 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h2><p>输出含有其他意义符号原本符号</p>\n<pre><code>\\*literal asterisks\\*\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://wow.kuapp.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明 (简体中文版)</a>，以及<a href=\"https://github.com/riku/Markdown-Syntax-CN/\" target=\"_blank\" rel=\"noopener\">github 地址</a></li>\n<li><a href=\"https://markdown-zh.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Markdown中文文档</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"区块元素\"><a href=\"#区块元素\" class=\"headerlink\" title=\"区块元素\"></a>区块元素</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>Markdown常用语法 =（最高级标题），-（第二阶标题）</p>\n<pre><code>最高级标题\n=\n二级标题\n-\n</code></pre><h2 id=\"区块引用\"><a href=\"#区块引用\" class=\"headerlink\" title=\"区块引用\"></a>区块引用</h2><p>先断好行，&lt; 放在句首  一般标识符和后面内容之间需要<strong>空格</strong></p>\n<pre><code>&gt; tab 缩进\n&gt; \n&gt; &gt;支持嵌套\n</code></pre><h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表使用 * + -，有序列表 数字 + .</p>\n<pre><code>* 无序列表\n1. 有序列表\n</code></pre><p>行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。</p>\n<pre><code>&lt;1986\\. What a great season.\n</code></pre><h2 id=\"代码区块\"><a href=\"#代码区块\" class=\"headerlink\" title=\"代码区块\"></a>代码区块</h2><p>缩进4个空格或者1个制表符，显示成原来的样子</p>\n<pre><code>这是一个普通段落：\n    这是一个代码区块。\n</code></pre><h2 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h2><p>三个以上的* 、 - 、底线 建立分割线，行内没有其它东西，中间可以有空格</p>\n<pre><code>- - -\n***\n——————\n</code></pre><h1 id=\"区段元素\"><a href=\"#区段元素\" class=\"headerlink\" title=\"区段元素\"></a>区段元素</h1><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n\nThis is [an example] [1] reference-style link.\n</code></pre><p>然后在文件任意处</p>\n<pre><code>[1]:http://example.com/  &quot;Optional Title Here&quot;\n</code></pre><p>隐式链接</p>\n<pre><code>[Google][]\n\n[Google]: http://google.com/\n</code></pre><h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>使用 <em> 和 _    包围，<em>*如果强调两边都有空格，就会被当成普通的符号</em></em></p>\n<pre><code>**强调文字**\n\n_strong_\n</code></pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>标记一小段，用  `</p>\n<pre><code>Use the `printf()` function.\n</code></pre><p>代码中间有反引号，可用多个反引开启或者结束代码区域</p>\n<pre><code>``There is a literal backtick ` here.``\n</code></pre><h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><pre><code>![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n</code></pre><h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"自动链接\"><a href=\"#自动链接\" class=\"headerlink\" title=\"自动链接\"></a>自动链接</h2><pre><code>&lt;http://example.com/&gt;\n</code></pre><h2 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h2><p>输出含有其他意义符号原本符号</p>\n<pre><code>\\*literal asterisks\\*\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://wow.kuapp.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明 (简体中文版)</a>，以及<a href=\"https://github.com/riku/Markdown-Syntax-CN/\" target=\"_blank\" rel=\"noopener\">github 地址</a></li>\n<li><a href=\"https://markdown-zh.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">Markdown中文文档</a></li>\n</ol>\n"},{"title":"QT事件","date":"2020-02-01T13:46:32.000Z","_content":"\nQt 的事件是整个 Qt 框架的核心机制之一\n\n包括很多事件:鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等.\n\n每个事件都对应一个处理函数 mouseEvent(),keyPressEvent()...\n\n如此多的事件处理函数,必定有个地方对其分发 event()\n\n# 事件处理函数\n**当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！**\n\nQt 的事件对象有两个函数：accept()和ignore().一般很少使用\n\n1. 如果一个事件处理函数调用了一个事件对象的accept()函数，\n这个事件就不会被继续传播给其**父组件**；\n如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者.\n\n2. 事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，\n你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。\n\n**事件的传播是在组件层次上面的,而不是依靠类继承机制.**\n(CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton)\n\n# 事件分发 event()\nevent()不负责事件处理,负责把事件分发给对应的事件处理函数(switch)\n\n如果返回值为true,并且设置了accept(),那么qt认为这个事件已经处理完毕，\n不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n\n**注意:在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播.**\n\n继承类的event()函数处理之后对应其他事件需要调用父类的的event()函数,否则处理不了其他函数\n\n# 事件过滤器 eventFilter()\n需要先安装对应的事件过滤器\n\n    textEdit->installEventFilter(this);\n如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序.    \n\n返回true则表示过滤,返回false表示不过滤.保险起见需要调用父类的eventFilter()\n\n**注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，\nQt 还是会将事件分发给这个接收组件，从而导致程序崩溃.**\n\n事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。\n\n# 事件处理顺序\n1. 重写paintEvent()、mousePressEvent()等事件处理函数.这是最普通、最简单的形式，同时功能也最简单.\n2. 重写event()函数.event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数.\n3. 在特定对象上面安装事件过滤器.该过滤器仅过滤该对象接收到的事件.\n4. 在QCoreApplication::instance()上面安装事件过滤器.该过滤器将过滤所有对象的所有事件，\n因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器.全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件.\n全局过滤器有一个问题：只能用在主线程.\n5. 重写QCoreApplication::notify()函数.这是最强大的,和全局事件过滤器一样提供完全控制，\n并且不受线程的限制.但是全局范围内只能有一个被使用(因为QCoreApplication是单例的).(一般不推荐用`)\n\n# 引用\n1. [Qt 学习之路 2（22）：事件总结](https://www.devbean.net/2012/10/qt-study-road-2-event-summary/)","source":"_posts/QT事件.md","raw":"---\ntitle: QT事件\ndate: 2020-02-01 21:46:32\ncategories:\n- program\ntags:\n- qt\n---\n\nQt 的事件是整个 Qt 框架的核心机制之一\n\n包括很多事件:鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等.\n\n每个事件都对应一个处理函数 mouseEvent(),keyPressEvent()...\n\n如此多的事件处理函数,必定有个地方对其分发 event()\n\n# 事件处理函数\n**当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！**\n\nQt 的事件对象有两个函数：accept()和ignore().一般很少使用\n\n1. 如果一个事件处理函数调用了一个事件对象的accept()函数，\n这个事件就不会被继续传播给其**父组件**；\n如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者.\n\n2. 事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，\n你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。\n\n**事件的传播是在组件层次上面的,而不是依靠类继承机制.**\n(CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton)\n\n# 事件分发 event()\nevent()不负责事件处理,负责把事件分发给对应的事件处理函数(switch)\n\n如果返回值为true,并且设置了accept(),那么qt认为这个事件已经处理完毕，\n不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n\n**注意:在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播.**\n\n继承类的event()函数处理之后对应其他事件需要调用父类的的event()函数,否则处理不了其他函数\n\n# 事件过滤器 eventFilter()\n需要先安装对应的事件过滤器\n\n    textEdit->installEventFilter(this);\n如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序.    \n\n返回true则表示过滤,返回false表示不过滤.保险起见需要调用父类的eventFilter()\n\n**注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，\nQt 还是会将事件分发给这个接收组件，从而导致程序崩溃.**\n\n事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。\n\n# 事件处理顺序\n1. 重写paintEvent()、mousePressEvent()等事件处理函数.这是最普通、最简单的形式，同时功能也最简单.\n2. 重写event()函数.event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数.\n3. 在特定对象上面安装事件过滤器.该过滤器仅过滤该对象接收到的事件.\n4. 在QCoreApplication::instance()上面安装事件过滤器.该过滤器将过滤所有对象的所有事件，\n因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器.全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件.\n全局过滤器有一个问题：只能用在主线程.\n5. 重写QCoreApplication::notify()函数.这是最强大的,和全局事件过滤器一样提供完全控制，\n并且不受线程的限制.但是全局范围内只能有一个被使用(因为QCoreApplication是单例的).(一般不推荐用`)\n\n# 引用\n1. [Qt 学习之路 2（22）：事件总结](https://www.devbean.net/2012/10/qt-study-road-2-event-summary/)","slug":"QT事件","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chc000bmxkadyz6g5e5","content":"<p>Qt 的事件是整个 Qt 框架的核心机制之一</p>\n<p>包括很多事件:鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等.</p>\n<p>每个事件都对应一个处理函数 mouseEvent(),keyPressEvent()…</p>\n<p>如此多的事件处理函数,必定有个地方对其分发 event()</p>\n<h1 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h1><p><strong>当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！</strong></p>\n<p>Qt 的事件对象有两个函数：accept()和ignore().一般很少使用</p>\n<ol>\n<li><p>如果一个事件处理函数调用了一个事件对象的accept()函数，<br>这个事件就不会被继续传播给其<strong>父组件</strong>；<br>如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者.</p>\n</li>\n<li><p>事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，<br>你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。</p>\n</li>\n</ol>\n<p><strong>事件的传播是在组件层次上面的,而不是依靠类继承机制.</strong><br>(CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton)</p>\n<h1 id=\"事件分发-event\"><a href=\"#事件分发-event\" class=\"headerlink\" title=\"事件分发 event()\"></a>事件分发 event()</h1><p>event()不负责事件处理,负责把事件分发给对应的事件处理函数(switch)</p>\n<p>如果返回值为true,并且设置了accept(),那么qt认为这个事件已经处理完毕，<br>不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p>\n<p><strong>注意:在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播.</strong></p>\n<p>继承类的event()函数处理之后对应其他事件需要调用父类的的event()函数,否则处理不了其他函数</p>\n<h1 id=\"事件过滤器-eventFilter\"><a href=\"#事件过滤器-eventFilter\" class=\"headerlink\" title=\"事件过滤器 eventFilter()\"></a>事件过滤器 eventFilter()</h1><p>需要先安装对应的事件过滤器</p>\n<pre><code>textEdit-&gt;installEventFilter(this);\n</code></pre><p>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序.    </p>\n<p>返回true则表示过滤,返回false表示不过滤.保险起见需要调用父类的eventFilter()</p>\n<p><strong>注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，<br>Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃.</strong></p>\n<p>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>\n<h1 id=\"事件处理顺序\"><a href=\"#事件处理顺序\" class=\"headerlink\" title=\"事件处理顺序\"></a>事件处理顺序</h1><ol>\n<li>重写paintEvent()、mousePressEvent()等事件处理函数.这是最普通、最简单的形式，同时功能也最简单.</li>\n<li>重写event()函数.event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数.</li>\n<li>在特定对象上面安装事件过滤器.该过滤器仅过滤该对象接收到的事件.</li>\n<li>在QCoreApplication::instance()上面安装事件过滤器.该过滤器将过滤所有对象的所有事件，<br>因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器.全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件.<br>全局过滤器有一个问题：只能用在主线程.</li>\n<li>重写QCoreApplication::notify()函数.这是最强大的,和全局事件过滤器一样提供完全控制，<br>并且不受线程的限制.但是全局范围内只能有一个被使用(因为QCoreApplication是单例的).(一般不推荐用`)</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.devbean.net/2012/10/qt-study-road-2-event-summary/\" target=\"_blank\" rel=\"noopener\">Qt 学习之路 2（22）：事件总结</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>Qt 的事件是整个 Qt 框架的核心机制之一</p>\n<p>包括很多事件:鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等.</p>\n<p>每个事件都对应一个处理函数 mouseEvent(),keyPressEvent()…</p>\n<p>如此多的事件处理函数,必定有个地方对其分发 event()</p>\n<h1 id=\"事件处理函数\"><a href=\"#事件处理函数\" class=\"headerlink\" title=\"事件处理函数\"></a>事件处理函数</h1><p><strong>当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行！</strong></p>\n<p>Qt 的事件对象有两个函数：accept()和ignore().一般很少使用</p>\n<ol>\n<li><p>如果一个事件处理函数调用了一个事件对象的accept()函数，<br>这个事件就不会被继续传播给其<strong>父组件</strong>；<br>如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者.</p>\n</li>\n<li><p>事件对象默认是 accept 的，而作为所有组件的父类QWidget的默认实现则是调用ignore()。这么一来，如果你自己实现事件处理函数，不调用QWidget的默认实现，<br>你就等于是接受了事件；如果你要忽略事件，只需调用QWidget的默认实现。</p>\n</li>\n</ol>\n<p><strong>事件的传播是在组件层次上面的,而不是依靠类继承机制.</strong><br>(CustomButtonEx的事件传播给了父组件CustomWidget，而不是它的父类CustomButton)</p>\n<h1 id=\"事件分发-event\"><a href=\"#事件分发-event\" class=\"headerlink\" title=\"事件分发 event()\"></a>事件分发 event()</h1><p>event()不负责事件处理,负责把事件分发给对应的事件处理函数(switch)</p>\n<p>如果返回值为true,并且设置了accept(),那么qt认为这个事件已经处理完毕，<br>不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p>\n<p><strong>注意:在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播.</strong></p>\n<p>继承类的event()函数处理之后对应其他事件需要调用父类的的event()函数,否则处理不了其他函数</p>\n<h1 id=\"事件过滤器-eventFilter\"><a href=\"#事件过滤器-eventFilter\" class=\"headerlink\" title=\"事件过滤器 eventFilter()\"></a>事件过滤器 eventFilter()</h1><p>需要先安装对应的事件过滤器</p>\n<pre><code>textEdit-&gt;installEventFilter(this);\n</code></pre><p>如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序.    </p>\n<p>返回true则表示过滤,返回false表示不过滤.保险起见需要调用父类的eventFilter()</p>\n<p><strong>注意，如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true。否则，<br>Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃.</strong></p>\n<p>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>\n<h1 id=\"事件处理顺序\"><a href=\"#事件处理顺序\" class=\"headerlink\" title=\"事件处理顺序\"></a>事件处理顺序</h1><ol>\n<li>重写paintEvent()、mousePressEvent()等事件处理函数.这是最普通、最简单的形式，同时功能也最简单.</li>\n<li>重写event()函数.event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数.</li>\n<li>在特定对象上面安装事件过滤器.该过滤器仅过滤该对象接收到的事件.</li>\n<li>在QCoreApplication::instance()上面安装事件过滤器.该过滤器将过滤所有对象的所有事件，<br>因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器.全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件.<br>全局过滤器有一个问题：只能用在主线程.</li>\n<li>重写QCoreApplication::notify()函数.这是最强大的,和全局事件过滤器一样提供完全控制，<br>并且不受线程的限制.但是全局范围内只能有一个被使用(因为QCoreApplication是单例的).(一般不推荐用`)</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.devbean.net/2012/10/qt-study-road-2-event-summary/\" target=\"_blank\" rel=\"noopener\">Qt 学习之路 2（22）：事件总结</a></li>\n</ol>\n"},{"title":"QT坐标系统 ","date":"2020-02-03T09:31:33.000Z","_content":"\nQPaintDevice、QPaintEngine和QPainter是 Qt 绘制系统的三个核心类\n\n坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）.\n\n为了避免获取不到真实的坐标值,建议使用QRectF.这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。\n\nQPainter是一个状态机.QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复.\n\n# 坐标变换\nQPainter:逻辑坐标 QPaintDevice:物理坐标\n\nQPainter,window代表窗口坐标,viewport代表物理坐标,这两个是映射关系(坐标scale)\n\nsetWindow() 设置窗口,实际绘制窗口;\nsetViewport() 设置物理绘制区域\n\n**QPainter使用的都是逻辑坐标,注意和物理坐标的对应关系**\n\n![坐标变换关系](coordinate.png)\n\nQPainter传入的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）.\n\n整个回执流程可以看成直接在设置的setWindow()里面绘制,可能需要平移旋转绘制坐标系,所得图像经过物理坐标和窗口坐标的缩放比例进行缩放得到\n    \n    painter.translate(400, 0); // 绘制用坐标系向右平移 400px\n     \n# 引用\n1. [坐标系统](https://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/)\n","source":"_posts/QT坐标系统.md","raw":"---\ntitle: 'QT坐标系统 '\ndate: 2020-02-03 17:31:33\ncategories:\n- program\ntags:\n- qt\n---\n\nQPaintDevice、QPaintEngine和QPainter是 Qt 绘制系统的三个核心类\n\n坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）.\n\n为了避免获取不到真实的坐标值,建议使用QRectF.这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。\n\nQPainter是一个状态机.QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复.\n\n# 坐标变换\nQPainter:逻辑坐标 QPaintDevice:物理坐标\n\nQPainter,window代表窗口坐标,viewport代表物理坐标,这两个是映射关系(坐标scale)\n\nsetWindow() 设置窗口,实际绘制窗口;\nsetViewport() 设置物理绘制区域\n\n**QPainter使用的都是逻辑坐标,注意和物理坐标的对应关系**\n\n![坐标变换关系](coordinate.png)\n\nQPainter传入的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）.\n\n整个回执流程可以看成直接在设置的setWindow()里面绘制,可能需要平移旋转绘制坐标系,所得图像经过物理坐标和窗口坐标的缩放比例进行缩放得到\n    \n    painter.translate(400, 0); // 绘制用坐标系向右平移 400px\n     \n# 引用\n1. [坐标系统](https://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/)\n","slug":"QT坐标系统","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chd000fmxka9lofpi4t","content":"<p>QPaintDevice、QPaintEngine和QPainter是 Qt 绘制系统的三个核心类</p>\n<p>坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）.</p>\n<p>为了避免获取不到真实的坐标值,建议使用QRectF.这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。</p>\n<p>QPainter是一个状态机.QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复.</p>\n<h1 id=\"坐标变换\"><a href=\"#坐标变换\" class=\"headerlink\" title=\"坐标变换\"></a>坐标变换</h1><p>QPainter:逻辑坐标 QPaintDevice:物理坐标</p>\n<p>QPainter,window代表窗口坐标,viewport代表物理坐标,这两个是映射关系(坐标scale)</p>\n<p>setWindow() 设置窗口,实际绘制窗口;<br>setViewport() 设置物理绘制区域</p>\n<p><strong>QPainter使用的都是逻辑坐标,注意和物理坐标的对应关系</strong></p>\n<p><img src=\"/2020/02/03/QT坐标系统/coordinate.png\" alt=\"坐标变换关系\"></p>\n<p>QPainter传入的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）.</p>\n<p>整个回执流程可以看成直接在设置的setWindow()里面绘制,可能需要平移旋转绘制坐标系,所得图像经过物理坐标和窗口坐标的缩放比例进行缩放得到</p>\n<pre><code>painter.translate(400, 0); // 绘制用坐标系向右平移 400px\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/\" target=\"_blank\" rel=\"noopener\">坐标系统</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>QPaintDevice、QPaintEngine和QPainter是 Qt 绘制系统的三个核心类</p>\n<p>坐标系统，也就是QPaintDevice上面的坐标。默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)。x 轴方向向右；y 轴方向向下。在基于像素的设备上（比如显示器），坐标的默认单位是像素，在打印机上则是点（1/72 英寸）.</p>\n<p>为了避免获取不到真实的坐标值,建议使用QRectF.这个类的两个函数QRectF::right()和QRectF::bottom()是正确的。</p>\n<p>QPainter是一个状态机.QPainter提供了内置的函数：save()和restore()。save()就是保存下当前状态；restore()则恢复上一次保存的结果。这两个函数必须成对出现：QPainter使用栈来保存数据，每一次save()，将当前状态压入栈顶，restore()则弹出栈顶进行恢复.</p>\n<h1 id=\"坐标变换\"><a href=\"#坐标变换\" class=\"headerlink\" title=\"坐标变换\"></a>坐标变换</h1><p>QPainter:逻辑坐标 QPaintDevice:物理坐标</p>\n<p>QPainter,window代表窗口坐标,viewport代表物理坐标,这两个是映射关系(坐标scale)</p>\n<p>setWindow() 设置窗口,实际绘制窗口;<br>setViewport() 设置物理绘制区域</p>\n<p><strong>QPainter使用的都是逻辑坐标,注意和物理坐标的对应关系</strong></p>\n<p><img src=\"/2020/02/03/QT坐标系统/coordinate.png\" alt=\"坐标变换关系\"></p>\n<p>QPainter传入的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）.</p>\n<p>整个回执流程可以看成直接在设置的setWindow()里面绘制,可能需要平移旋转绘制坐标系,所得图像经过物理坐标和窗口坐标的缩放比例进行缩放得到</p>\n<pre><code>painter.translate(400, 0); // 绘制用坐标系向右平移 400px\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.devbean.net/2012/11/qt-study-road-2-coordinate-system/\" target=\"_blank\" rel=\"noopener\">坐标系统</a></li>\n</ol>\n"},{"title":"ROS记录","date":"2019-10-07T03:32:36.000Z","_content":"\n## 私有名称\nNodeHandle创建时有自己的命名空间,访问私有名称\n\n    ros::init(argc, argv, \"my_node_name\");\n    ros::NodeHandle nh1(\"~\");               //    命名空间/my_node_name\n    ros::NodeHandle nh2(\"~foo\");            //    命名空间/my_node_name/foo\n    \n    // 可以把这两行换成下面的\n    ros::NodeHandle nh;\n    nh.getParam(\"~name\", ... );\n    \n    ros::NodeHandle nh(\"~\");\n    nh.getParam(\"name\", ... );     //  /my_node_name/name\n常用参数设置\n    \n    getParam()   \n    param()\n    setParam()\n    deleteParam() \n    hasParam()\n    searchParam()\n    // 有时需要提示类型\n    n.param<std::string>(\"my_param\", s, \"default_value\");\n如果参数服务器存在/a/b的参数，你的NodeHandle在/a/c工作空间，searchParam()搜索b会得到/a/b. \n如果/a/c/b参数增加，搜索就会得到/a/c/b参数。\n# 设置消息级别\n1. 源代码加入\n        \n        #define ROSCONSOLE_MIN_SEVERITY ROSSONSOLE_SEVERITY_ERROR   //error等级\n2. CmakeLists.txt\n    \n        add_definition(-ROSCONSOLE_MIN_SEVERITY = ROSSONSOLE_SEVERITY_ERROR)\n3. 配置文件内容 比较灵活　不需要重新编译\n        \n        log4j.logger.ros.package_name=ERROR\n        <env name=\"ROSCONSOLE_CONFIG_FILE\" value = \"$(find package_name)/config/xxx.config\" />                                \n4. 命名的消息可以单独设置日志级别　名字可以是一个模块或者其他\n\n        ROS_INFO_STREAM_NAMED(\"named_msg\", \"my message\");\n        log4j.logger.ros.package_name.named_msg=ERROR\n5. 按条件显示消息和过滤\n\n        ROS_INFO_STREAM_COND(val<0, \"my message\");\n        ROS_INFO_STREAM_FILTER()    #暂时用不到　待补充\n6. 显示消息的方式　单次　可调(频率)　组合\n\n        ROS_INFO_STREAM_ONCE(\"my message\");\n        ROS_INFO_STREAM_THROTTLE(2, \"my message\");  //每隔两秒输出\n7. rqt_console  rqt_logger_level　运行时修改级别  \n# 出现异常情况 roswtf\n检测功能包所有原件潜在问题    \n    \n    roscd package_name\n    roswtf    \n8. 消息记录\n    \n        rosbag record -a   #记录所有\n        <node pkg=\"rosbag\" type=\"record\" name=\"bag_record\" args=\"/topic_name\" />  #消息记录包默认在~/.ros路劲下　除非使用-o(前缀) -O(文件命名)\n        rosbag play xxx.bag\n\n# 节点生命周期\n- 当第一个ros::NodeHandle创建时候，会调用ros::start()\n- 最后一个ros::NodeHandle销毁时，会调用 ros::shutdown() (这将关闭所有打开的订阅、发布、服务调用和服务服务器)\n\n\n\n# 遇到的问题        \n## remap 重映射\n这个坑了我好久\n\n**作用范围**：范围内随后的所有声明(<launch> <node> <group>)\n\n1. 重命名已经存在的话题\n        \n        <!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states-->\n        <launch>\n            <node pkg=\"catch_control\" type=\"joint_state_maintain_node\" name=\"joined_joint_state_publisher\" respawn=\"true\" output=\"screen\">\n                    <remap from=\"moveit_group/joint_states\" to=\"joint_states\"/>\n            </node>\n        </launch>\n\n2. 将别的话题映射到自己的订阅的主题上\n特别要注意这种方式的使用　**作用范围很大**\n        \n        <!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states-->\n        <launch>\n            <remap from=\"joint_states\" to=\"moveit_group/joint_states\"/>\n            <include file=\"$(find UR5e_robotiq_moveit_config)/launch/move_group.launch\" />\n        </launch>\n这种方式还是出现了下面问题　但是用第一种结合异步更新没有出现\n\n    Failed to fetch current robot state\n    \n    Didn't received robot state (joint angles) with recent timestamp within 1 seconds.\n    Check clock synchronization if your are running ROS across multiple machines!       \n        \n简单理解：**remap就是把作用范围内的名称直接替换掉 用替换掉的名称对外开放 实现两个话题通信**        \n\n    \n## Failed to fetch current robot state\n\n    ros::AsyncSpinner async_spinner(6);\n    async_spinner.start();\n    \n    async_spinner.stop();   #需要关闭的时候用\n节点初始化时加上这句　异步处理更新回调函数　感觉可能是moveit内部节点回调函数处理  \n\n## clion编译经常卡死\n查看内存和cpu使用率都有盈余，后来发现是因为launch了很多节点，发布了很多数据，关闭就好了  \n\n\n# 引用\n1. [ROS中Remap标签详解,举例说明其两种用法](https://blog.csdn.net/xingdou520/article/details/85686752)\n\n\n        \n\n               \n                              \n\n\n                 \n    \n    ","source":"_posts/ROS记录.md","raw":"---\ntitle: ROS记录\ndate: 2019-10-07 11:32:36\ncategories:\n- ROS\ntags:\n- NodeHandle\n---\n\n## 私有名称\nNodeHandle创建时有自己的命名空间,访问私有名称\n\n    ros::init(argc, argv, \"my_node_name\");\n    ros::NodeHandle nh1(\"~\");               //    命名空间/my_node_name\n    ros::NodeHandle nh2(\"~foo\");            //    命名空间/my_node_name/foo\n    \n    // 可以把这两行换成下面的\n    ros::NodeHandle nh;\n    nh.getParam(\"~name\", ... );\n    \n    ros::NodeHandle nh(\"~\");\n    nh.getParam(\"name\", ... );     //  /my_node_name/name\n常用参数设置\n    \n    getParam()   \n    param()\n    setParam()\n    deleteParam() \n    hasParam()\n    searchParam()\n    // 有时需要提示类型\n    n.param<std::string>(\"my_param\", s, \"default_value\");\n如果参数服务器存在/a/b的参数，你的NodeHandle在/a/c工作空间，searchParam()搜索b会得到/a/b. \n如果/a/c/b参数增加，搜索就会得到/a/c/b参数。\n# 设置消息级别\n1. 源代码加入\n        \n        #define ROSCONSOLE_MIN_SEVERITY ROSSONSOLE_SEVERITY_ERROR   //error等级\n2. CmakeLists.txt\n    \n        add_definition(-ROSCONSOLE_MIN_SEVERITY = ROSSONSOLE_SEVERITY_ERROR)\n3. 配置文件内容 比较灵活　不需要重新编译\n        \n        log4j.logger.ros.package_name=ERROR\n        <env name=\"ROSCONSOLE_CONFIG_FILE\" value = \"$(find package_name)/config/xxx.config\" />                                \n4. 命名的消息可以单独设置日志级别　名字可以是一个模块或者其他\n\n        ROS_INFO_STREAM_NAMED(\"named_msg\", \"my message\");\n        log4j.logger.ros.package_name.named_msg=ERROR\n5. 按条件显示消息和过滤\n\n        ROS_INFO_STREAM_COND(val<0, \"my message\");\n        ROS_INFO_STREAM_FILTER()    #暂时用不到　待补充\n6. 显示消息的方式　单次　可调(频率)　组合\n\n        ROS_INFO_STREAM_ONCE(\"my message\");\n        ROS_INFO_STREAM_THROTTLE(2, \"my message\");  //每隔两秒输出\n7. rqt_console  rqt_logger_level　运行时修改级别  \n# 出现异常情况 roswtf\n检测功能包所有原件潜在问题    \n    \n    roscd package_name\n    roswtf    \n8. 消息记录\n    \n        rosbag record -a   #记录所有\n        <node pkg=\"rosbag\" type=\"record\" name=\"bag_record\" args=\"/topic_name\" />  #消息记录包默认在~/.ros路劲下　除非使用-o(前缀) -O(文件命名)\n        rosbag play xxx.bag\n\n# 节点生命周期\n- 当第一个ros::NodeHandle创建时候，会调用ros::start()\n- 最后一个ros::NodeHandle销毁时，会调用 ros::shutdown() (这将关闭所有打开的订阅、发布、服务调用和服务服务器)\n\n\n\n# 遇到的问题        \n## remap 重映射\n这个坑了我好久\n\n**作用范围**：范围内随后的所有声明(<launch> <node> <group>)\n\n1. 重命名已经存在的话题\n        \n        <!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states-->\n        <launch>\n            <node pkg=\"catch_control\" type=\"joint_state_maintain_node\" name=\"joined_joint_state_publisher\" respawn=\"true\" output=\"screen\">\n                    <remap from=\"moveit_group/joint_states\" to=\"joint_states\"/>\n            </node>\n        </launch>\n\n2. 将别的话题映射到自己的订阅的主题上\n特别要注意这种方式的使用　**作用范围很大**\n        \n        <!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states-->\n        <launch>\n            <remap from=\"joint_states\" to=\"moveit_group/joint_states\"/>\n            <include file=\"$(find UR5e_robotiq_moveit_config)/launch/move_group.launch\" />\n        </launch>\n这种方式还是出现了下面问题　但是用第一种结合异步更新没有出现\n\n    Failed to fetch current robot state\n    \n    Didn't received robot state (joint angles) with recent timestamp within 1 seconds.\n    Check clock synchronization if your are running ROS across multiple machines!       \n        \n简单理解：**remap就是把作用范围内的名称直接替换掉 用替换掉的名称对外开放 实现两个话题通信**        \n\n    \n## Failed to fetch current robot state\n\n    ros::AsyncSpinner async_spinner(6);\n    async_spinner.start();\n    \n    async_spinner.stop();   #需要关闭的时候用\n节点初始化时加上这句　异步处理更新回调函数　感觉可能是moveit内部节点回调函数处理  \n\n## clion编译经常卡死\n查看内存和cpu使用率都有盈余，后来发现是因为launch了很多节点，发布了很多数据，关闭就好了  \n\n\n# 引用\n1. [ROS中Remap标签详解,举例说明其两种用法](https://blog.csdn.net/xingdou520/article/details/85686752)\n\n\n        \n\n               \n                              \n\n\n                 \n    \n    ","slug":"ROS记录","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3che000hmxka1ed4kpp4","content":"<h2 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h2><p>NodeHandle创建时有自己的命名空间,访问私有名称</p>\n<pre><code>ros::init(argc, argv, &quot;my_node_name&quot;);\nros::NodeHandle nh1(&quot;~&quot;);               //    命名空间/my_node_name\nros::NodeHandle nh2(&quot;~foo&quot;);            //    命名空间/my_node_name/foo\n\n// 可以把这两行换成下面的\nros::NodeHandle nh;\nnh.getParam(&quot;~name&quot;, ... );\n\nros::NodeHandle nh(&quot;~&quot;);\nnh.getParam(&quot;name&quot;, ... );     //  /my_node_name/name\n</code></pre><p>常用参数设置</p>\n<pre><code>getParam()   \nparam()\nsetParam()\ndeleteParam() \nhasParam()\nsearchParam()\n// 有时需要提示类型\nn.param&lt;std::string&gt;(&quot;my_param&quot;, s, &quot;default_value&quot;);\n</code></pre><p>如果参数服务器存在/a/b的参数，你的NodeHandle在/a/c工作空间，searchParam()搜索b会得到/a/b.<br>如果/a/c/b参数增加，搜索就会得到/a/c/b参数。</p>\n<h1 id=\"设置消息级别\"><a href=\"#设置消息级别\" class=\"headerlink\" title=\"设置消息级别\"></a>设置消息级别</h1><ol>\n<li><p>源代码加入</p>\n<pre><code> #define ROSCONSOLE_MIN_SEVERITY ROSSONSOLE_SEVERITY_ERROR   //error等级\n</code></pre></li>\n<li><p>CmakeLists.txt</p>\n<pre><code> add_definition(-ROSCONSOLE_MIN_SEVERITY = ROSSONSOLE_SEVERITY_ERROR)\n</code></pre></li>\n<li><p>配置文件内容 比较灵活　不需要重新编译</p>\n<pre><code> log4j.logger.ros.package_name=ERROR\n &lt;env name=&quot;ROSCONSOLE_CONFIG_FILE&quot; value = &quot;$(find package_name)/config/xxx.config&quot; /&gt;                                \n</code></pre></li>\n<li><p>命名的消息可以单独设置日志级别　名字可以是一个模块或者其他</p>\n<pre><code> ROS_INFO_STREAM_NAMED(&quot;named_msg&quot;, &quot;my message&quot;);\n log4j.logger.ros.package_name.named_msg=ERROR\n</code></pre></li>\n<li><p>按条件显示消息和过滤</p>\n<pre><code> ROS_INFO_STREAM_COND(val&lt;0, &quot;my message&quot;);\n ROS_INFO_STREAM_FILTER()    #暂时用不到　待补充\n</code></pre></li>\n<li><p>显示消息的方式　单次　可调(频率)　组合</p>\n<pre><code> ROS_INFO_STREAM_ONCE(&quot;my message&quot;);\n ROS_INFO_STREAM_THROTTLE(2, &quot;my message&quot;);  //每隔两秒输出\n</code></pre></li>\n<li><p>rqt_console  rqt_logger_level　运行时修改级别  </p>\n<h1 id=\"出现异常情况-roswtf\"><a href=\"#出现异常情况-roswtf\" class=\"headerlink\" title=\"出现异常情况 roswtf\"></a>出现异常情况 roswtf</h1><p>检测功能包所有原件潜在问题    </p>\n<p> roscd package_name<br> roswtf    </p>\n</li>\n<li><p>消息记录</p>\n<pre><code> rosbag record -a   #记录所有\n &lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic_name&quot; /&gt;  #消息记录包默认在~/.ros路劲下　除非使用-o(前缀) -O(文件命名)\n rosbag play xxx.bag\n</code></pre></li>\n</ol>\n<h1 id=\"节点生命周期\"><a href=\"#节点生命周期\" class=\"headerlink\" title=\"节点生命周期\"></a>节点生命周期</h1><ul>\n<li>当第一个ros::NodeHandle创建时候，会调用ros::start()</li>\n<li>最后一个ros::NodeHandle销毁时，会调用 ros::shutdown() (这将关闭所有打开的订阅、发布、服务调用和服务服务器)</li>\n</ul>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"remap-重映射\"><a href=\"#remap-重映射\" class=\"headerlink\" title=\"remap 重映射\"></a>remap 重映射</h2><p>这个坑了我好久</p>\n<p><strong>作用范围</strong>：范围内随后的所有声明(<launch> <node> <group>)</group></node></launch></p>\n<ol>\n<li><p>重命名已经存在的话题</p>\n<pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt;\n &lt;launch&gt;\n     &lt;node pkg=&quot;catch_control&quot; type=&quot;joint_state_maintain_node&quot; name=&quot;joined_joint_state_publisher&quot; respawn=&quot;true&quot; output=&quot;screen&quot;&gt;\n             &lt;remap from=&quot;moveit_group/joint_states&quot; to=&quot;joint_states&quot;/&gt;\n     &lt;/node&gt;\n &lt;/launch&gt;\n</code></pre></li>\n<li><p>将别的话题映射到自己的订阅的主题上<br>特别要注意这种方式的使用　<strong>作用范围很大</strong></p>\n<pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt;\n &lt;launch&gt;\n     &lt;remap from=&quot;joint_states&quot; to=&quot;moveit_group/joint_states&quot;/&gt;\n     &lt;include file=&quot;$(find UR5e_robotiq_moveit_config)/launch/move_group.launch&quot; /&gt;\n &lt;/launch&gt;\n</code></pre><p>这种方式还是出现了下面问题　但是用第一种结合异步更新没有出现</p>\n<p> Failed to fetch current robot state</p>\n<p> Didn’t received robot state (joint angles) with recent timestamp within 1 seconds.<br> Check clock synchronization if your are running ROS across multiple machines!       </p>\n</li>\n</ol>\n<p>简单理解：<strong>remap就是把作用范围内的名称直接替换掉 用替换掉的名称对外开放 实现两个话题通信</strong>        </p>\n<h2 id=\"Failed-to-fetch-current-robot-state\"><a href=\"#Failed-to-fetch-current-robot-state\" class=\"headerlink\" title=\"Failed to fetch current robot state\"></a>Failed to fetch current robot state</h2><pre><code>ros::AsyncSpinner async_spinner(6);\nasync_spinner.start();\n\nasync_spinner.stop();   #需要关闭的时候用\n</code></pre><p>节点初始化时加上这句　异步处理更新回调函数　感觉可能是moveit内部节点回调函数处理  </p>\n<h2 id=\"clion编译经常卡死\"><a href=\"#clion编译经常卡死\" class=\"headerlink\" title=\"clion编译经常卡死\"></a>clion编译经常卡死</h2><p>查看内存和cpu使用率都有盈余，后来发现是因为launch了很多节点，发布了很多数据，关闭就好了  </p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/xingdou520/article/details/85686752\" target=\"_blank\" rel=\"noopener\">ROS中Remap标签详解,举例说明其两种用法</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h2><p>NodeHandle创建时有自己的命名空间,访问私有名称</p>\n<pre><code>ros::init(argc, argv, &quot;my_node_name&quot;);\nros::NodeHandle nh1(&quot;~&quot;);               //    命名空间/my_node_name\nros::NodeHandle nh2(&quot;~foo&quot;);            //    命名空间/my_node_name/foo\n\n// 可以把这两行换成下面的\nros::NodeHandle nh;\nnh.getParam(&quot;~name&quot;, ... );\n\nros::NodeHandle nh(&quot;~&quot;);\nnh.getParam(&quot;name&quot;, ... );     //  /my_node_name/name\n</code></pre><p>常用参数设置</p>\n<pre><code>getParam()   \nparam()\nsetParam()\ndeleteParam() \nhasParam()\nsearchParam()\n// 有时需要提示类型\nn.param&lt;std::string&gt;(&quot;my_param&quot;, s, &quot;default_value&quot;);\n</code></pre><p>如果参数服务器存在/a/b的参数，你的NodeHandle在/a/c工作空间，searchParam()搜索b会得到/a/b.<br>如果/a/c/b参数增加，搜索就会得到/a/c/b参数。</p>\n<h1 id=\"设置消息级别\"><a href=\"#设置消息级别\" class=\"headerlink\" title=\"设置消息级别\"></a>设置消息级别</h1><ol>\n<li><p>源代码加入</p>\n<pre><code> #define ROSCONSOLE_MIN_SEVERITY ROSSONSOLE_SEVERITY_ERROR   //error等级\n</code></pre></li>\n<li><p>CmakeLists.txt</p>\n<pre><code> add_definition(-ROSCONSOLE_MIN_SEVERITY = ROSSONSOLE_SEVERITY_ERROR)\n</code></pre></li>\n<li><p>配置文件内容 比较灵活　不需要重新编译</p>\n<pre><code> log4j.logger.ros.package_name=ERROR\n &lt;env name=&quot;ROSCONSOLE_CONFIG_FILE&quot; value = &quot;$(find package_name)/config/xxx.config&quot; /&gt;                                \n</code></pre></li>\n<li><p>命名的消息可以单独设置日志级别　名字可以是一个模块或者其他</p>\n<pre><code> ROS_INFO_STREAM_NAMED(&quot;named_msg&quot;, &quot;my message&quot;);\n log4j.logger.ros.package_name.named_msg=ERROR\n</code></pre></li>\n<li><p>按条件显示消息和过滤</p>\n<pre><code> ROS_INFO_STREAM_COND(val&lt;0, &quot;my message&quot;);\n ROS_INFO_STREAM_FILTER()    #暂时用不到　待补充\n</code></pre></li>\n<li><p>显示消息的方式　单次　可调(频率)　组合</p>\n<pre><code> ROS_INFO_STREAM_ONCE(&quot;my message&quot;);\n ROS_INFO_STREAM_THROTTLE(2, &quot;my message&quot;);  //每隔两秒输出\n</code></pre></li>\n<li><p>rqt_console  rqt_logger_level　运行时修改级别  </p>\n<h1 id=\"出现异常情况-roswtf\"><a href=\"#出现异常情况-roswtf\" class=\"headerlink\" title=\"出现异常情况 roswtf\"></a>出现异常情况 roswtf</h1><p>检测功能包所有原件潜在问题    </p>\n<p> roscd package_name<br> roswtf    </p>\n</li>\n<li><p>消息记录</p>\n<pre><code> rosbag record -a   #记录所有\n &lt;node pkg=&quot;rosbag&quot; type=&quot;record&quot; name=&quot;bag_record&quot; args=&quot;/topic_name&quot; /&gt;  #消息记录包默认在~/.ros路劲下　除非使用-o(前缀) -O(文件命名)\n rosbag play xxx.bag\n</code></pre></li>\n</ol>\n<h1 id=\"节点生命周期\"><a href=\"#节点生命周期\" class=\"headerlink\" title=\"节点生命周期\"></a>节点生命周期</h1><ul>\n<li>当第一个ros::NodeHandle创建时候，会调用ros::start()</li>\n<li>最后一个ros::NodeHandle销毁时，会调用 ros::shutdown() (这将关闭所有打开的订阅、发布、服务调用和服务服务器)</li>\n</ul>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"remap-重映射\"><a href=\"#remap-重映射\" class=\"headerlink\" title=\"remap 重映射\"></a>remap 重映射</h2><p>这个坑了我好久</p>\n<p><strong>作用范围</strong>：范围内随后的所有声明(<launch> <node> <group>)</group></node></launch></p>\n<ol>\n<li><p>重命名已经存在的话题</p>\n<pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt;\n &lt;launch&gt;\n     &lt;node pkg=&quot;catch_control&quot; type=&quot;joint_state_maintain_node&quot; name=&quot;joined_joint_state_publisher&quot; respawn=&quot;true&quot; output=&quot;screen&quot;&gt;\n             &lt;remap from=&quot;moveit_group/joint_states&quot; to=&quot;joint_states&quot;/&gt;\n     &lt;/node&gt;\n &lt;/launch&gt;\n</code></pre></li>\n<li><p>将别的话题映射到自己的订阅的主题上<br>特别要注意这种方式的使用　<strong>作用范围很大</strong></p>\n<pre><code> &lt;!-- 已经存在话题moveit_group/joint_states move_group需要订阅joint_states--&gt;\n &lt;launch&gt;\n     &lt;remap from=&quot;joint_states&quot; to=&quot;moveit_group/joint_states&quot;/&gt;\n     &lt;include file=&quot;$(find UR5e_robotiq_moveit_config)/launch/move_group.launch&quot; /&gt;\n &lt;/launch&gt;\n</code></pre><p>这种方式还是出现了下面问题　但是用第一种结合异步更新没有出现</p>\n<p> Failed to fetch current robot state</p>\n<p> Didn’t received robot state (joint angles) with recent timestamp within 1 seconds.<br> Check clock synchronization if your are running ROS across multiple machines!       </p>\n</li>\n</ol>\n<p>简单理解：<strong>remap就是把作用范围内的名称直接替换掉 用替换掉的名称对外开放 实现两个话题通信</strong>        </p>\n<h2 id=\"Failed-to-fetch-current-robot-state\"><a href=\"#Failed-to-fetch-current-robot-state\" class=\"headerlink\" title=\"Failed to fetch current robot state\"></a>Failed to fetch current robot state</h2><pre><code>ros::AsyncSpinner async_spinner(6);\nasync_spinner.start();\n\nasync_spinner.stop();   #需要关闭的时候用\n</code></pre><p>节点初始化时加上这句　异步处理更新回调函数　感觉可能是moveit内部节点回调函数处理  </p>\n<h2 id=\"clion编译经常卡死\"><a href=\"#clion编译经常卡死\" class=\"headerlink\" title=\"clion编译经常卡死\"></a>clion编译经常卡死</h2><p>查看内存和cpu使用率都有盈余，后来发现是因为launch了很多节点，发布了很多数据，关闭就好了  </p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/xingdou520/article/details/85686752\" target=\"_blank\" rel=\"noopener\">ROS中Remap标签详解,举例说明其两种用法</a></li>\n</ol>\n"},{"title":"ROS遇到的问题","date":"2019-12-21T03:54:38.000Z","_content":"\n# 终端结束所有节点之后显示仍有节点\n清理node,否则影响查看节点通信\n    \n    rosnode list\n    rosnode cleanup\n\n# 程序排错\n\n首先看**循环**,是否调用ros::spinOnce(),对应的数据是否更新\n\n好几次是因为循环没有更新数据,排错废了不少时间\n\n- 没有调用ros::spinOnce(),导致没有处理回调函数,也就没有更新数据\n- 回调函数处理后的数据是否放入对应变量,有时候用的是中间变量,导致更新的数据没有放进去\n\nROS也有异步更新的机制,之前用过,出过一次问题,可以根据需要选择更新的机制\n\n# KDL和trac-ik库使用\n在ubuntu16+ros kinetic 和ubuntu18+ros melodic中不一样\n后一版本中需要用于初始化正逆解对象的KDL::Chain一直存在，可作为类成员变量，可能是后一版本中进行了优化，减少了拷贝的次数","source":"_posts/ROS遇到的问题.md","raw":"---\ntitle: ROS遇到的问题\ndate: 2019-12-21 11:54:38\ncategories:\n- ROS\ntags:\n- ROS\n---\n\n# 终端结束所有节点之后显示仍有节点\n清理node,否则影响查看节点通信\n    \n    rosnode list\n    rosnode cleanup\n\n# 程序排错\n\n首先看**循环**,是否调用ros::spinOnce(),对应的数据是否更新\n\n好几次是因为循环没有更新数据,排错废了不少时间\n\n- 没有调用ros::spinOnce(),导致没有处理回调函数,也就没有更新数据\n- 回调函数处理后的数据是否放入对应变量,有时候用的是中间变量,导致更新的数据没有放进去\n\nROS也有异步更新的机制,之前用过,出过一次问题,可以根据需要选择更新的机制\n\n# KDL和trac-ik库使用\n在ubuntu16+ros kinetic 和ubuntu18+ros melodic中不一样\n后一版本中需要用于初始化正逆解对象的KDL::Chain一直存在，可作为类成员变量，可能是后一版本中进行了优化，减少了拷贝的次数","slug":"ROS遇到的问题","published":1,"updated":"2020-10-27T06:50:04.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3che000lmxka2shdrq9u","content":"<h1 id=\"终端结束所有节点之后显示仍有节点\"><a href=\"#终端结束所有节点之后显示仍有节点\" class=\"headerlink\" title=\"终端结束所有节点之后显示仍有节点\"></a>终端结束所有节点之后显示仍有节点</h1><p>清理node,否则影响查看节点通信</p>\n<pre><code>rosnode list\nrosnode cleanup\n</code></pre><h1 id=\"程序排错\"><a href=\"#程序排错\" class=\"headerlink\" title=\"程序排错\"></a>程序排错</h1><p>首先看<strong>循环</strong>,是否调用ros::spinOnce(),对应的数据是否更新</p>\n<p>好几次是因为循环没有更新数据,排错废了不少时间</p>\n<ul>\n<li>没有调用ros::spinOnce(),导致没有处理回调函数,也就没有更新数据</li>\n<li>回调函数处理后的数据是否放入对应变量,有时候用的是中间变量,导致更新的数据没有放进去</li>\n</ul>\n<p>ROS也有异步更新的机制,之前用过,出过一次问题,可以根据需要选择更新的机制</p>\n<h1 id=\"KDL和trac-ik库使用\"><a href=\"#KDL和trac-ik库使用\" class=\"headerlink\" title=\"KDL和trac-ik库使用\"></a>KDL和trac-ik库使用</h1><p>在ubuntu16+ros kinetic 和ubuntu18+ros melodic中不一样<br>后一版本中需要用于初始化正逆解对象的KDL::Chain一直存在，可作为类成员变量，可能是后一版本中进行了优化，减少了拷贝的次数</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"终端结束所有节点之后显示仍有节点\"><a href=\"#终端结束所有节点之后显示仍有节点\" class=\"headerlink\" title=\"终端结束所有节点之后显示仍有节点\"></a>终端结束所有节点之后显示仍有节点</h1><p>清理node,否则影响查看节点通信</p>\n<pre><code>rosnode list\nrosnode cleanup\n</code></pre><h1 id=\"程序排错\"><a href=\"#程序排错\" class=\"headerlink\" title=\"程序排错\"></a>程序排错</h1><p>首先看<strong>循环</strong>,是否调用ros::spinOnce(),对应的数据是否更新</p>\n<p>好几次是因为循环没有更新数据,排错废了不少时间</p>\n<ul>\n<li>没有调用ros::spinOnce(),导致没有处理回调函数,也就没有更新数据</li>\n<li>回调函数处理后的数据是否放入对应变量,有时候用的是中间变量,导致更新的数据没有放进去</li>\n</ul>\n<p>ROS也有异步更新的机制,之前用过,出过一次问题,可以根据需要选择更新的机制</p>\n<h1 id=\"KDL和trac-ik库使用\"><a href=\"#KDL和trac-ik库使用\" class=\"headerlink\" title=\"KDL和trac-ik库使用\"></a>KDL和trac-ik库使用</h1><p>在ubuntu16+ros kinetic 和ubuntu18+ros melodic中不一样<br>后一版本中需要用于初始化正逆解对象的KDL::Chain一直存在，可作为类成员变量，可能是后一版本中进行了优化，减少了拷贝的次数</p>\n"},{"title":"SAMBA服务简单搭建","date":"2019-10-01T13:00:55.000Z","_content":"\n# SAMBA简介\nSamba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。\nSMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，\n它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。\n\n可以实现Windows和Linux主机之间共享资源互访功能\n\n实验室小范围使用 直接采用匿名共享资源 简单快捷\n\n#  配置\n\nserver 服务器\n    \n    sudo apt install samba    # samba-common 会自动安装\n    sudo vi /etc/samba/smb.conf\n    \n    [share]             #共享目录\n    comment=Linux share     #共享目录描述，给自己看的\n    path=/home/share    #共享目录路径\n    public=yes\n    writeable=yes   #可写\n    browseable=yes  #共享在Windows中网上邻居可见 结合public\n    guest ok=yes    #允许匿名访问\n    \n        \n    sudo /etc/init.d/samba start  # 开启服务器\n    \nclient ubuntu\n    \n    sudo apt install smbclient\n    smbclient -L 192.168.10.100   #查看共享目录\n    smbclient //192.168.10.100/share  # IP地址后接共享目录  访问\n    \n    sudo apt-get install cifs-utils   #下载相应组件\n    sudo mount -t cifs //192.168.10.100/share  /home/yang/share  # 使用这句或者下面一句\n    sudo mount -t cifs -o passward=123,dir_mode=0777,file_mode=0777 //192.168.10.100/share  /home/yang/share  #有写权限 passward 为对应服务器的密码\n    \n    # vi /etc/fstab 开机自动挂载 具有写权限 注意逗号 之前就是用的空格导致不行\n    # cifs 文件系统  备份 0:不需要 1:每天 2:每两天  fsck 0:不需要 1:需要\n    # blkid 查询UUID\n    //192.168.10.100/share\t/home/yang/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  \n              \nclient Windows\n\n    \"运行\"对话框输入\\\\192.168.10.100 回车\n    选中共享文件夹 右键映射网络驱动器 即可像本地磁盘使用\n# 服务器开机自启动\n\n    sudo vi /etc/rc.loca\n    \n    /etc/init.d/ssh start # 末尾添加 exit 0 之前\n    /etc/init.d/smbd start    \n    \n# 引用\n1. [Ubuntu终端访问samba服务器](https://blog.csdn.net/qq_43682605/article/details/86562212)    \n2. [如何配置使Ubuntu启动后samba服务与ssh服务开机自动启动](https://www.cnblogs.com/torres-9/p/5880188.html?utm_source=itdadao&utm_medium=referral)","source":"_posts/SAMBA服务简单搭建.md","raw":"---\ntitle: SAMBA服务简单搭建\ndate: 2019-10-01 21:00:55\ncategories:\n- Linux\n\ntags:\n- 文件共享\n\n---\n\n# SAMBA简介\nSamba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。\nSMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，\n它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。\n\n可以实现Windows和Linux主机之间共享资源互访功能\n\n实验室小范围使用 直接采用匿名共享资源 简单快捷\n\n#  配置\n\nserver 服务器\n    \n    sudo apt install samba    # samba-common 会自动安装\n    sudo vi /etc/samba/smb.conf\n    \n    [share]             #共享目录\n    comment=Linux share     #共享目录描述，给自己看的\n    path=/home/share    #共享目录路径\n    public=yes\n    writeable=yes   #可写\n    browseable=yes  #共享在Windows中网上邻居可见 结合public\n    guest ok=yes    #允许匿名访问\n    \n        \n    sudo /etc/init.d/samba start  # 开启服务器\n    \nclient ubuntu\n    \n    sudo apt install smbclient\n    smbclient -L 192.168.10.100   #查看共享目录\n    smbclient //192.168.10.100/share  # IP地址后接共享目录  访问\n    \n    sudo apt-get install cifs-utils   #下载相应组件\n    sudo mount -t cifs //192.168.10.100/share  /home/yang/share  # 使用这句或者下面一句\n    sudo mount -t cifs -o passward=123,dir_mode=0777,file_mode=0777 //192.168.10.100/share  /home/yang/share  #有写权限 passward 为对应服务器的密码\n    \n    # vi /etc/fstab 开机自动挂载 具有写权限 注意逗号 之前就是用的空格导致不行\n    # cifs 文件系统  备份 0:不需要 1:每天 2:每两天  fsck 0:不需要 1:需要\n    # blkid 查询UUID\n    //192.168.10.100/share\t/home/yang/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  \n              \nclient Windows\n\n    \"运行\"对话框输入\\\\192.168.10.100 回车\n    选中共享文件夹 右键映射网络驱动器 即可像本地磁盘使用\n# 服务器开机自启动\n\n    sudo vi /etc/rc.loca\n    \n    /etc/init.d/ssh start # 末尾添加 exit 0 之前\n    /etc/init.d/smbd start    \n    \n# 引用\n1. [Ubuntu终端访问samba服务器](https://blog.csdn.net/qq_43682605/article/details/86562212)    \n2. [如何配置使Ubuntu启动后samba服务与ssh服务开机自动启动](https://www.cnblogs.com/torres-9/p/5880188.html?utm_source=itdadao&utm_medium=referral)","slug":"SAMBA服务简单搭建","published":1,"updated":"2020-09-23T14:42:00.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chf000nmxka4kbkpmhp","content":"<h1 id=\"SAMBA简介\"><a href=\"#SAMBA简介\" class=\"headerlink\" title=\"SAMBA简介\"></a>SAMBA简介</h1><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。<br>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，<br>它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p>\n<p>可以实现Windows和Linux主机之间共享资源互访功能</p>\n<p>实验室小范围使用 直接采用匿名共享资源 简单快捷</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>server 服务器</p>\n<pre><code>sudo apt install samba    # samba-common 会自动安装\nsudo vi /etc/samba/smb.conf\n\n[share]             #共享目录\ncomment=Linux share     #共享目录描述，给自己看的\npath=/home/share    #共享目录路径\npublic=yes\nwriteable=yes   #可写\nbrowseable=yes  #共享在Windows中网上邻居可见 结合public\nguest ok=yes    #允许匿名访问\n\n\nsudo /etc/init.d/samba start  # 开启服务器\n</code></pre><p>client ubuntu</p>\n<pre><code>sudo apt install smbclient\nsmbclient -L 192.168.10.100   #查看共享目录\nsmbclient //192.168.10.100/share  # IP地址后接共享目录  访问\n\nsudo apt-get install cifs-utils   #下载相应组件\nsudo mount -t cifs //192.168.10.100/share  /home/yang/share  # 使用这句或者下面一句\nsudo mount -t cifs -o passward=123,dir_mode=0777,file_mode=0777 //192.168.10.100/share  /home/yang/share  #有写权限 passward 为对应服务器的密码\n\n# vi /etc/fstab 开机自动挂载 具有写权限 注意逗号 之前就是用的空格导致不行\n# cifs 文件系统  备份 0:不需要 1:每天 2:每两天  fsck 0:不需要 1:需要\n# blkid 查询UUID\n//192.168.10.100/share    /home/yang/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  \n</code></pre><p>client Windows</p>\n<pre><code>&quot;运行&quot;对话框输入\\\\192.168.10.100 回车\n选中共享文件夹 右键映射网络驱动器 即可像本地磁盘使用\n</code></pre><h1 id=\"服务器开机自启动\"><a href=\"#服务器开机自启动\" class=\"headerlink\" title=\"服务器开机自启动\"></a>服务器开机自启动</h1><pre><code>sudo vi /etc/rc.loca\n\n/etc/init.d/ssh start # 末尾添加 exit 0 之前\n/etc/init.d/smbd start    \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/qq_43682605/article/details/86562212\" target=\"_blank\" rel=\"noopener\">Ubuntu终端访问samba服务器</a>    </li>\n<li><a href=\"https://www.cnblogs.com/torres-9/p/5880188.html?utm_source=itdadao&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">如何配置使Ubuntu启动后samba服务与ssh服务开机自动启动</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SAMBA简介\"><a href=\"#SAMBA简介\" class=\"headerlink\" title=\"SAMBA简介\"></a>SAMBA简介</h1><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。<br>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，<br>它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。</p>\n<p>可以实现Windows和Linux主机之间共享资源互访功能</p>\n<p>实验室小范围使用 直接采用匿名共享资源 简单快捷</p>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>server 服务器</p>\n<pre><code>sudo apt install samba    # samba-common 会自动安装\nsudo vi /etc/samba/smb.conf\n\n[share]             #共享目录\ncomment=Linux share     #共享目录描述，给自己看的\npath=/home/share    #共享目录路径\npublic=yes\nwriteable=yes   #可写\nbrowseable=yes  #共享在Windows中网上邻居可见 结合public\nguest ok=yes    #允许匿名访问\n\n\nsudo /etc/init.d/samba start  # 开启服务器\n</code></pre><p>client ubuntu</p>\n<pre><code>sudo apt install smbclient\nsmbclient -L 192.168.10.100   #查看共享目录\nsmbclient //192.168.10.100/share  # IP地址后接共享目录  访问\n\nsudo apt-get install cifs-utils   #下载相应组件\nsudo mount -t cifs //192.168.10.100/share  /home/yang/share  # 使用这句或者下面一句\nsudo mount -t cifs -o passward=123,dir_mode=0777,file_mode=0777 //192.168.10.100/share  /home/yang/share  #有写权限 passward 为对应服务器的密码\n\n# vi /etc/fstab 开机自动挂载 具有写权限 注意逗号 之前就是用的空格导致不行\n# cifs 文件系统  备份 0:不需要 1:每天 2:每两天  fsck 0:不需要 1:需要\n# blkid 查询UUID\n//192.168.10.100/share    /home/yang/share cifs passward=123,dir_mode=0777,file_mode=0777 0 0  \n</code></pre><p>client Windows</p>\n<pre><code>&quot;运行&quot;对话框输入\\\\192.168.10.100 回车\n选中共享文件夹 右键映射网络驱动器 即可像本地磁盘使用\n</code></pre><h1 id=\"服务器开机自启动\"><a href=\"#服务器开机自启动\" class=\"headerlink\" title=\"服务器开机自启动\"></a>服务器开机自启动</h1><pre><code>sudo vi /etc/rc.loca\n\n/etc/init.d/ssh start # 末尾添加 exit 0 之前\n/etc/init.d/smbd start    \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/qq_43682605/article/details/86562212\" target=\"_blank\" rel=\"noopener\">Ubuntu终端访问samba服务器</a>    </li>\n<li><a href=\"https://www.cnblogs.com/torres-9/p/5880188.html?utm_source=itdadao&amp;utm_medium=referral\" target=\"_blank\" rel=\"noopener\">如何配置使Ubuntu启动后samba服务与ssh服务开机自动启动</a></li>\n</ol>\n"},{"title":"c++ #pragma once","date":"2020-02-05T01:59:27.000Z","_content":"\n在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式\n1. \\#ifndef指令防止代码块重复引用\n         \n        #ifndef _CODE_BLOCK\n        #define _CODE_BLOCK\n         \n        // code\n         \n        #endif// _CODE_BLOCK \n        \n    保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次\n    **(编译时需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef会使得编译时间相对较长)**\n2. \\#pragma once指令，在想要保护的文件开头写入\n    \n        #pragma once   \n    只能针对一个文件(物理上的一个文件,而不是指内容相同的两个文件),不能针对一个头文件中的一段代码.\n    如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。\n    \n    不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度较快\n    \n    \n    \n总结: #ifndef更加灵活，兼容性好，#pragma once操作简单，效率高。         \n","source":"_posts/c-pragma-once.md","raw":"---\ntitle: 'c++ #pragma once'\ndate: 2020-02-05 09:59:27\ncategories:\n- program\ntags:\n- c++\n---\n\n在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式\n1. \\#ifndef指令防止代码块重复引用\n         \n        #ifndef _CODE_BLOCK\n        #define _CODE_BLOCK\n         \n        // code\n         \n        #endif// _CODE_BLOCK \n        \n    保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次\n    **(编译时需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef会使得编译时间相对较长)**\n2. \\#pragma once指令，在想要保护的文件开头写入\n    \n        #pragma once   \n    只能针对一个文件(物理上的一个文件,而不是指内容相同的两个文件),不能针对一个头文件中的一段代码.\n    如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。\n    \n    不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度较快\n    \n    \n    \n总结: #ifndef更加灵活，兼容性好，#pragma once操作简单，效率高。         \n","slug":"c-pragma-once","published":1,"updated":"2020-09-23T14:42:00.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chg000rmxkal1d8gle1","content":"<p>在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式</p>\n<ol>\n<li><p>#ifndef指令防止代码块重复引用</p>\n<pre><code> #ifndef _CODE_BLOCK\n #define _CODE_BLOCK\n\n // code\n\n #endif// _CODE_BLOCK \n</code></pre><p> 保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次<br> <strong>(编译时需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef会使得编译时间相对较长)</strong></p>\n</li>\n<li><p>#pragma once指令，在想要保护的文件开头写入</p>\n<pre><code> #pragma once   \n</code></pre><p> 只能针对一个文件(物理上的一个文件,而不是指内容相同的两个文件),不能针对一个头文件中的一段代码.<br> 如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。</p>\n<p> 不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度较快</p>\n</li>\n</ol>\n<p>总结: #ifndef更加灵活，兼容性好，#pragma once操作简单，效率高。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在C/C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式</p>\n<ol>\n<li><p>#ifndef指令防止代码块重复引用</p>\n<pre><code> #ifndef _CODE_BLOCK\n #define _CODE_BLOCK\n\n // code\n\n #endif// _CODE_BLOCK \n</code></pre><p> 保证同一份文件不会被包含两次，也能够保证不同文件完全相同的内容不会被包含两次<br> <strong>(编译时需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，#ifndef会使得编译时间相对较长)</strong></p>\n</li>\n<li><p>#pragma once指令，在想要保护的文件开头写入</p>\n<pre><code> #pragma once   \n</code></pre><p> 只能针对一个文件(物理上的一个文件,而不是指内容相同的两个文件),不能针对一个头文件中的一段代码.<br> 如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。</p>\n<p> 不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度较快</p>\n</li>\n</ol>\n<p>总结: #ifndef更加灵活，兼容性好，#pragma once操作简单，效率高。         </p>\n"},{"title":"c++函数指针","date":"2019-11-16T08:51:52.000Z","_content":"\n# 定义函数指针\n定义一个指针指向一个无参数无返回值的函数\n\n    void (*funcPtr)();\n**大多数申明都是以右-左-右动作的方式工作**\n\n针对复杂的定义,最好处理方式是从中间开始向外扩展.\n\"中间开始\"(\"funcPtr是一个...\"),向右(没有东西,被括号挡住了),向左发现\"*\"(\"...指针指向一个...\"),向右发现空参数列表(\"...没有带参数的函数...\"),\n向左发现void(\"funcPtr是一个指针,它指向一个不带参数并返回void的函数)\n\n这里*funcPtr需要括号是避免混淆 有void 指针 \n    void *funcPtr();    //一个返回void指针的函数,而不是一个变量\n# 复杂定义\n    void * (*(*fp1)(int))[10];\n    \n    float (*(*fp2)(int,int,float))(int);\n    \n    typedef double (*(*(*fp3)())[10])();\n    fp3 a;    \n    \n    int (*(*fp4())[10])();\n- fp1 是一个指向函数的指针,接受int参数,返回一个指向含有10个void指针数组的指针    \n- fp2 是一个指向函数的指针,该函数接受int,int,double,返回一个指向函数的指针,该函数接受int,返回float\n- fp3 指向函数的指针,该函数无参数,返回一个指向含有10个指向函数指针数组的指针,这些函数不接受参数且返回double 又定义a是ftp3类型的一个\n- fp4 是一个返回指针的函数,改指针指向含有10个函数指针的数组,这些函数返回整型值    \n\n# 使用函数指针\n函数func()的地址 就是func 或者使用更加明显的语法&func()\n    \n    void (*fp)() = func;\n指向函数的指针数组\n    \n    #define DF(N) void N() { cout << \"function \" #N\" called...\" <<endl; }\n    \n    DF(a);DF(b);DF(c);\n    void (*func_table[])() = {a,b,c};\n            \n             \n    \n\n\n# 引用\n1. [C++编程思想](https://book.douban.com/subject/6558198/)","source":"_posts/c-函数指针.md","raw":"---\ntitle: c++函数指针\ndate: 2019-11-16 16:51:52\ncategories:\n- program\ntags:\n- c++\n---\n\n# 定义函数指针\n定义一个指针指向一个无参数无返回值的函数\n\n    void (*funcPtr)();\n**大多数申明都是以右-左-右动作的方式工作**\n\n针对复杂的定义,最好处理方式是从中间开始向外扩展.\n\"中间开始\"(\"funcPtr是一个...\"),向右(没有东西,被括号挡住了),向左发现\"*\"(\"...指针指向一个...\"),向右发现空参数列表(\"...没有带参数的函数...\"),\n向左发现void(\"funcPtr是一个指针,它指向一个不带参数并返回void的函数)\n\n这里*funcPtr需要括号是避免混淆 有void 指针 \n    void *funcPtr();    //一个返回void指针的函数,而不是一个变量\n# 复杂定义\n    void * (*(*fp1)(int))[10];\n    \n    float (*(*fp2)(int,int,float))(int);\n    \n    typedef double (*(*(*fp3)())[10])();\n    fp3 a;    \n    \n    int (*(*fp4())[10])();\n- fp1 是一个指向函数的指针,接受int参数,返回一个指向含有10个void指针数组的指针    \n- fp2 是一个指向函数的指针,该函数接受int,int,double,返回一个指向函数的指针,该函数接受int,返回float\n- fp3 指向函数的指针,该函数无参数,返回一个指向含有10个指向函数指针数组的指针,这些函数不接受参数且返回double 又定义a是ftp3类型的一个\n- fp4 是一个返回指针的函数,改指针指向含有10个函数指针的数组,这些函数返回整型值    \n\n# 使用函数指针\n函数func()的地址 就是func 或者使用更加明显的语法&func()\n    \n    void (*fp)() = func;\n指向函数的指针数组\n    \n    #define DF(N) void N() { cout << \"function \" #N\" called...\" <<endl; }\n    \n    DF(a);DF(b);DF(c);\n    void (*func_table[])() = {a,b,c};\n            \n             \n    \n\n\n# 引用\n1. [C++编程思想](https://book.douban.com/subject/6558198/)","slug":"c-函数指针","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chh000tmxkac3qla6cx","content":"<h1 id=\"定义函数指针\"><a href=\"#定义函数指针\" class=\"headerlink\" title=\"定义函数指针\"></a>定义函数指针</h1><p>定义一个指针指向一个无参数无返回值的函数</p>\n<pre><code>void (*funcPtr)();\n</code></pre><p><strong>大多数申明都是以右-左-右动作的方式工作</strong></p>\n<p>针对复杂的定义,最好处理方式是从中间开始向外扩展.<br>“中间开始”(“funcPtr是一个…”),向右(没有东西,被括号挡住了),向左发现”*”(“…指针指向一个…”),向右发现空参数列表(“…没有带参数的函数…”),<br>向左发现void(“funcPtr是一个指针,它指向一个不带参数并返回void的函数)</p>\n<p>这里<em>funcPtr需要括号是避免混淆 有void 指针<br>    void </em>funcPtr();    //一个返回void指针的函数,而不是一个变量</p>\n<h1 id=\"复杂定义\"><a href=\"#复杂定义\" class=\"headerlink\" title=\"复杂定义\"></a>复杂定义</h1><pre><code>void * (*(*fp1)(int))[10];\n\nfloat (*(*fp2)(int,int,float))(int);\n\ntypedef double (*(*(*fp3)())[10])();\nfp3 a;    \n\nint (*(*fp4())[10])();\n</code></pre><ul>\n<li>fp1 是一个指向函数的指针,接受int参数,返回一个指向含有10个void指针数组的指针    </li>\n<li>fp2 是一个指向函数的指针,该函数接受int,int,double,返回一个指向函数的指针,该函数接受int,返回float</li>\n<li>fp3 指向函数的指针,该函数无参数,返回一个指向含有10个指向函数指针数组的指针,这些函数不接受参数且返回double 又定义a是ftp3类型的一个</li>\n<li>fp4 是一个返回指针的函数,改指针指向含有10个函数指针的数组,这些函数返回整型值    </li>\n</ul>\n<h1 id=\"使用函数指针\"><a href=\"#使用函数指针\" class=\"headerlink\" title=\"使用函数指针\"></a>使用函数指针</h1><p>函数func()的地址 就是func 或者使用更加明显的语法&amp;func()</p>\n<pre><code>void (*fp)() = func;\n</code></pre><p>指向函数的指针数组</p>\n<pre><code>#define DF(N) void N() { cout &lt;&lt; &quot;function &quot; #N&quot; called...&quot; &lt;&lt;endl; }\n\nDF(a);DF(b);DF(c);\nvoid (*func_table[])() = {a,b,c};\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://book.douban.com/subject/6558198/\" target=\"_blank\" rel=\"noopener\">C++编程思想</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义函数指针\"><a href=\"#定义函数指针\" class=\"headerlink\" title=\"定义函数指针\"></a>定义函数指针</h1><p>定义一个指针指向一个无参数无返回值的函数</p>\n<pre><code>void (*funcPtr)();\n</code></pre><p><strong>大多数申明都是以右-左-右动作的方式工作</strong></p>\n<p>针对复杂的定义,最好处理方式是从中间开始向外扩展.<br>“中间开始”(“funcPtr是一个…”),向右(没有东西,被括号挡住了),向左发现”*”(“…指针指向一个…”),向右发现空参数列表(“…没有带参数的函数…”),<br>向左发现void(“funcPtr是一个指针,它指向一个不带参数并返回void的函数)</p>\n<p>这里<em>funcPtr需要括号是避免混淆 有void 指针<br>    void </em>funcPtr();    //一个返回void指针的函数,而不是一个变量</p>\n<h1 id=\"复杂定义\"><a href=\"#复杂定义\" class=\"headerlink\" title=\"复杂定义\"></a>复杂定义</h1><pre><code>void * (*(*fp1)(int))[10];\n\nfloat (*(*fp2)(int,int,float))(int);\n\ntypedef double (*(*(*fp3)())[10])();\nfp3 a;    \n\nint (*(*fp4())[10])();\n</code></pre><ul>\n<li>fp1 是一个指向函数的指针,接受int参数,返回一个指向含有10个void指针数组的指针    </li>\n<li>fp2 是一个指向函数的指针,该函数接受int,int,double,返回一个指向函数的指针,该函数接受int,返回float</li>\n<li>fp3 指向函数的指针,该函数无参数,返回一个指向含有10个指向函数指针数组的指针,这些函数不接受参数且返回double 又定义a是ftp3类型的一个</li>\n<li>fp4 是一个返回指针的函数,改指针指向含有10个函数指针的数组,这些函数返回整型值    </li>\n</ul>\n<h1 id=\"使用函数指针\"><a href=\"#使用函数指针\" class=\"headerlink\" title=\"使用函数指针\"></a>使用函数指针</h1><p>函数func()的地址 就是func 或者使用更加明显的语法&amp;func()</p>\n<pre><code>void (*fp)() = func;\n</code></pre><p>指向函数的指针数组</p>\n<pre><code>#define DF(N) void N() { cout &lt;&lt; &quot;function &quot; #N&quot; called...&quot; &lt;&lt;endl; }\n\nDF(a);DF(b);DF(c);\nvoid (*func_table[])() = {a,b,c};\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://book.douban.com/subject/6558198/\" target=\"_blank\" rel=\"noopener\">C++编程思想</a></li>\n</ol>\n"},{"title":"gdb调试","date":"2019-10-03T01:09:21.000Z","_content":"\n# 编译器\ngcc(GNU Compiler Collection)\n\n    -c  激活预处理、编译和汇编，生成.o文件\n    -S  激活预处理和编译，生成.s的汇编代码wenjain\n    -E  激活预处理，结果输出到标准输出(屏幕)，可结合重定向输出到文件 > pre_test\n    -g  为调试程序生成相关信息\n    \n    默认生成a.out文件，可以使用-o 指定输出文件\n    \n编译c++：g++  gcc可以编译c++源文件，但是不会自动和c++程序使用的库连接，所以通常使用g++,会自动调用gcc\n\n# gdb调试 \n很多命令可以缩写为一个字母   \n## 启动\n    gcc -g summary.c\n    gdb a.out           #二进制文件作为gdb参数就可以了\n## 查看源代码\n    l       #list\n    search  #reverse-search\n    回车      #重复上一指令\n    \n## 设置断点\n    b 10  #第10行设置断点\n    info break   #查看断点信息\n    clear       #清除当前行断点\n    \n## 运行程序\n    r\n    n   #单步执行程序\n    continue    #运行到下一个断点\n    s   #step  遇到函数调用会进入函数内部 next不会\n## 监视变量\n    print variable  #缩写p  \n    watch varialbe    #监视\n## 临时改变变量\n    set var i=1 #临时设置i=1\n## 查看堆栈\n    bt  #程序调用函数，函数的地址、参数、函数内局部变量都会压入\n    \n# ROS中使用\nlaunch文件\n\n    launch-prefix=\"xterm -e gdb --args\"     //in a separate xterm window\n    launch-prefix=\"gdb -ex run --args\"　　　 //in the same xterm\n    \n使用memcheck启动valgrind来检测程序内存泄露　使用callgrind执行性能分析\n    \n    launch-prefix=\"valgrind\"    //valgrind\n设置ROS节点core文件转储　　coredump　进程突然崩溃的那一刻的内存快照\n\n    ulimit -c unlimited\n    echo 1 > /proc/sys/kernel/core_uses_pid     #将core文件名设置成默认使用进程的pid\n    \n    gdb  program_name  core_name  #查看core文件　program为编译好的　　/var/core_log\n# rosrun启动gdb\n    rosrun --prefix 'gdb -ex run --args' [package_name] [node_name]     \n    \n    \n    \n\n    \n\n# 引用\n1. [ros Tutorial Roslaunch Nodes in Valgrind or GDB](http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB)                  \n    ","source":"_posts/gdb调试.md","raw":"---\ntitle: gdb调试\ndate: 2019-10-03 09:09:21\ncategories:\n- Linux\n\ntags:\n- gdb\n\n---\n\n# 编译器\ngcc(GNU Compiler Collection)\n\n    -c  激活预处理、编译和汇编，生成.o文件\n    -S  激活预处理和编译，生成.s的汇编代码wenjain\n    -E  激活预处理，结果输出到标准输出(屏幕)，可结合重定向输出到文件 > pre_test\n    -g  为调试程序生成相关信息\n    \n    默认生成a.out文件，可以使用-o 指定输出文件\n    \n编译c++：g++  gcc可以编译c++源文件，但是不会自动和c++程序使用的库连接，所以通常使用g++,会自动调用gcc\n\n# gdb调试 \n很多命令可以缩写为一个字母   \n## 启动\n    gcc -g summary.c\n    gdb a.out           #二进制文件作为gdb参数就可以了\n## 查看源代码\n    l       #list\n    search  #reverse-search\n    回车      #重复上一指令\n    \n## 设置断点\n    b 10  #第10行设置断点\n    info break   #查看断点信息\n    clear       #清除当前行断点\n    \n## 运行程序\n    r\n    n   #单步执行程序\n    continue    #运行到下一个断点\n    s   #step  遇到函数调用会进入函数内部 next不会\n## 监视变量\n    print variable  #缩写p  \n    watch varialbe    #监视\n## 临时改变变量\n    set var i=1 #临时设置i=1\n## 查看堆栈\n    bt  #程序调用函数，函数的地址、参数、函数内局部变量都会压入\n    \n# ROS中使用\nlaunch文件\n\n    launch-prefix=\"xterm -e gdb --args\"     //in a separate xterm window\n    launch-prefix=\"gdb -ex run --args\"　　　 //in the same xterm\n    \n使用memcheck启动valgrind来检测程序内存泄露　使用callgrind执行性能分析\n    \n    launch-prefix=\"valgrind\"    //valgrind\n设置ROS节点core文件转储　　coredump　进程突然崩溃的那一刻的内存快照\n\n    ulimit -c unlimited\n    echo 1 > /proc/sys/kernel/core_uses_pid     #将core文件名设置成默认使用进程的pid\n    \n    gdb  program_name  core_name  #查看core文件　program为编译好的　　/var/core_log\n# rosrun启动gdb\n    rosrun --prefix 'gdb -ex run --args' [package_name] [node_name]     \n    \n    \n    \n\n    \n\n# 引用\n1. [ros Tutorial Roslaunch Nodes in Valgrind or GDB](http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB)                  \n    ","slug":"gdb调试","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chi000xmxkae3typ3hf","content":"<h1 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h1><p>gcc(GNU Compiler Collection)</p>\n<pre><code>-c  激活预处理、编译和汇编，生成.o文件\n-S  激活预处理和编译，生成.s的汇编代码wenjain\n-E  激活预处理，结果输出到标准输出(屏幕)，可结合重定向输出到文件 &gt; pre_test\n-g  为调试程序生成相关信息\n\n默认生成a.out文件，可以使用-o 指定输出文件\n</code></pre><p>编译c++：g++  gcc可以编译c++源文件，但是不会自动和c++程序使用的库连接，所以通常使用g++,会自动调用gcc</p>\n<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>很多命令可以缩写为一个字母   </p>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>gcc -g summary.c\ngdb a.out           #二进制文件作为gdb参数就可以了\n</code></pre><h2 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h2><pre><code>l       #list\nsearch  #reverse-search\n回车      #重复上一指令\n</code></pre><h2 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h2><pre><code>b 10  #第10行设置断点\ninfo break   #查看断点信息\nclear       #清除当前行断点\n</code></pre><h2 id=\"运行程序\"><a href=\"#运行程序\" class=\"headerlink\" title=\"运行程序\"></a>运行程序</h2><pre><code>r\nn   #单步执行程序\ncontinue    #运行到下一个断点\ns   #step  遇到函数调用会进入函数内部 next不会\n</code></pre><h2 id=\"监视变量\"><a href=\"#监视变量\" class=\"headerlink\" title=\"监视变量\"></a>监视变量</h2><pre><code>print variable  #缩写p  \nwatch varialbe    #监视\n</code></pre><h2 id=\"临时改变变量\"><a href=\"#临时改变变量\" class=\"headerlink\" title=\"临时改变变量\"></a>临时改变变量</h2><pre><code>set var i=1 #临时设置i=1\n</code></pre><h2 id=\"查看堆栈\"><a href=\"#查看堆栈\" class=\"headerlink\" title=\"查看堆栈\"></a>查看堆栈</h2><pre><code>bt  #程序调用函数，函数的地址、参数、函数内局部变量都会压入\n</code></pre><h1 id=\"ROS中使用\"><a href=\"#ROS中使用\" class=\"headerlink\" title=\"ROS中使用\"></a>ROS中使用</h1><p>launch文件</p>\n<pre><code>launch-prefix=&quot;xterm -e gdb --args&quot;     //in a separate xterm window\nlaunch-prefix=&quot;gdb -ex run --args&quot;　　　 //in the same xterm\n</code></pre><p>使用memcheck启动valgrind来检测程序内存泄露　使用callgrind执行性能分析</p>\n<pre><code>launch-prefix=&quot;valgrind&quot;    //valgrind\n</code></pre><p>设置ROS节点core文件转储　　coredump　进程突然崩溃的那一刻的内存快照</p>\n<pre><code>ulimit -c unlimited\necho 1 &gt; /proc/sys/kernel/core_uses_pid     #将core文件名设置成默认使用进程的pid\n\ngdb  program_name  core_name  #查看core文件　program为编译好的　　/var/core_log\n</code></pre><h1 id=\"rosrun启动gdb\"><a href=\"#rosrun启动gdb\" class=\"headerlink\" title=\"rosrun启动gdb\"></a>rosrun启动gdb</h1><pre><code>rosrun --prefix &#39;gdb -ex run --args&#39; [package_name] [node_name]     \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB\" target=\"_blank\" rel=\"noopener\">ros Tutorial Roslaunch Nodes in Valgrind or GDB</a>                  </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h1><p>gcc(GNU Compiler Collection)</p>\n<pre><code>-c  激活预处理、编译和汇编，生成.o文件\n-S  激活预处理和编译，生成.s的汇编代码wenjain\n-E  激活预处理，结果输出到标准输出(屏幕)，可结合重定向输出到文件 &gt; pre_test\n-g  为调试程序生成相关信息\n\n默认生成a.out文件，可以使用-o 指定输出文件\n</code></pre><p>编译c++：g++  gcc可以编译c++源文件，但是不会自动和c++程序使用的库连接，所以通常使用g++,会自动调用gcc</p>\n<h1 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h1><p>很多命令可以缩写为一个字母   </p>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>gcc -g summary.c\ngdb a.out           #二进制文件作为gdb参数就可以了\n</code></pre><h2 id=\"查看源代码\"><a href=\"#查看源代码\" class=\"headerlink\" title=\"查看源代码\"></a>查看源代码</h2><pre><code>l       #list\nsearch  #reverse-search\n回车      #重复上一指令\n</code></pre><h2 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h2><pre><code>b 10  #第10行设置断点\ninfo break   #查看断点信息\nclear       #清除当前行断点\n</code></pre><h2 id=\"运行程序\"><a href=\"#运行程序\" class=\"headerlink\" title=\"运行程序\"></a>运行程序</h2><pre><code>r\nn   #单步执行程序\ncontinue    #运行到下一个断点\ns   #step  遇到函数调用会进入函数内部 next不会\n</code></pre><h2 id=\"监视变量\"><a href=\"#监视变量\" class=\"headerlink\" title=\"监视变量\"></a>监视变量</h2><pre><code>print variable  #缩写p  \nwatch varialbe    #监视\n</code></pre><h2 id=\"临时改变变量\"><a href=\"#临时改变变量\" class=\"headerlink\" title=\"临时改变变量\"></a>临时改变变量</h2><pre><code>set var i=1 #临时设置i=1\n</code></pre><h2 id=\"查看堆栈\"><a href=\"#查看堆栈\" class=\"headerlink\" title=\"查看堆栈\"></a>查看堆栈</h2><pre><code>bt  #程序调用函数，函数的地址、参数、函数内局部变量都会压入\n</code></pre><h1 id=\"ROS中使用\"><a href=\"#ROS中使用\" class=\"headerlink\" title=\"ROS中使用\"></a>ROS中使用</h1><p>launch文件</p>\n<pre><code>launch-prefix=&quot;xterm -e gdb --args&quot;     //in a separate xterm window\nlaunch-prefix=&quot;gdb -ex run --args&quot;　　　 //in the same xterm\n</code></pre><p>使用memcheck启动valgrind来检测程序内存泄露　使用callgrind执行性能分析</p>\n<pre><code>launch-prefix=&quot;valgrind&quot;    //valgrind\n</code></pre><p>设置ROS节点core文件转储　　coredump　进程突然崩溃的那一刻的内存快照</p>\n<pre><code>ulimit -c unlimited\necho 1 &gt; /proc/sys/kernel/core_uses_pid     #将core文件名设置成默认使用进程的pid\n\ngdb  program_name  core_name  #查看core文件　program为编译好的　　/var/core_log\n</code></pre><h1 id=\"rosrun启动gdb\"><a href=\"#rosrun启动gdb\" class=\"headerlink\" title=\"rosrun启动gdb\"></a>rosrun启动gdb</h1><pre><code>rosrun --prefix &#39;gdb -ex run --args&#39; [package_name] [node_name]     \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://wiki.ros.org/roslaunch/Tutorials/Roslaunch%20Nodes%20in%20Valgrind%20or%20GDB\" target=\"_blank\" rel=\"noopener\">ros Tutorial Roslaunch Nodes in Valgrind or GDB</a>                  </li>\n</ol>\n"},{"title":"c++ string与c风格字符串","date":"2020-02-22T07:08:52.000Z","_content":"\n## 字符串 \n字符串实际上是使用 null 字符 '\\0' 终止的一维字符数组，大小比单词多一个\n\n不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。\n\n建议使用c++ string\n\n    char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; \n    char greeting[] = \"Hello\";  \n\n### c++操作c风格字符串\n复制,连接,查找,比较,**需要#include \\<cstring\\>**\n\n**strlen(s1)获得的长度不包含空字符'\\0',string类的length()也是一样,**\n    \n    #include <cstring>  \n    strcpy(s1, s2);   //复制字符串 s2 到字符串 s1\n    strcat(s1, s2);     //连接字符串 s2 到字符串 s1 的末尾\n    strlen(s1);         //返回字符串 s1 的长度 不包含空字符'\\0'\n    strcmp(s1, s2);     //如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0\n    strchr(s1, ch);     //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置\n    strstr(s1, s2);     //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置\n    \n### string\nc++ 支持上述所有操作,并增加了功能\n\n     append() -- 在字符串的末尾添加字符 直接用str1+str2也可以\n     find() -- 在字符串中查找字符串\n     insert() -- 插入字符\n     length() -- 返回字符串的长度 不包含空字符'\\0'\n     replace() -- 替换字符串\n     substr() -- 返回某个子字符串\n     ...\n\n## 遇到的问题 \n1. 常量字符串不能修改\n    **p指向常量字符串(位于常量存储区),内容不能修改**    \n    \n        // p a存放在栈区,\"string\"字面值存放在常量区\n        char *p = \"string\"; //可以访问单个字符p[2] 不能直接更改p[2] = 'I'\n        char a[] = \"string\"; //这里字符数组会把\"string\"拷贝到栈区,可以直接更改a[2] = 'I' \n        \n    一、程序的内存分配\n    - 栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量值等；\n    - 堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统OS回收。注意它与数据结构中的堆是两回事，**分配方式倒是类似于链表**； （malloc,new,free,delete）\n    - 全局区(静态区 static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；\n    - 文字常量区：常量字符串就是放在这里，程序结束后由系统释放；\n    - 程序代码区：存放函数体的二进制代码。\n    \n    栈区系统分配,速度快,但是程序员无法控制;堆区用起来方便,但是速度慢,容易产生内存碎片\n    \n\n##引用\n1. [char *p = \"abcdefg\"； 常量字符串\"abcdefg\"位于静态存储区，通过p不能修改该字符串常量](https://blog.csdn.net/Castiellee929/article/details/88628617)    \n2. [char *p = \"abcd\"; 和 char a[] = \"abcd\"的区别](https://blog.csdn.net/dongfanglanyi/article/details/81386752?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)    \n ","source":"_posts/c-string与c风格字符串.md","raw":"---\ntitle: c++ string与c风格字符串\ndate: 2020-02-22 15:08:52\ncategories:\n- program\ntags:\n- 字符串\n---\n\n## 字符串 \n字符串实际上是使用 null 字符 '\\0' 终止的一维字符数组，大小比单词多一个\n\n不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '\\0' 放在字符串的末尾。\n\n建议使用c++ string\n\n    char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; \n    char greeting[] = \"Hello\";  \n\n### c++操作c风格字符串\n复制,连接,查找,比较,**需要#include \\<cstring\\>**\n\n**strlen(s1)获得的长度不包含空字符'\\0',string类的length()也是一样,**\n    \n    #include <cstring>  \n    strcpy(s1, s2);   //复制字符串 s2 到字符串 s1\n    strcat(s1, s2);     //连接字符串 s2 到字符串 s1 的末尾\n    strlen(s1);         //返回字符串 s1 的长度 不包含空字符'\\0'\n    strcmp(s1, s2);     //如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0\n    strchr(s1, ch);     //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置\n    strstr(s1, s2);     //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置\n    \n### string\nc++ 支持上述所有操作,并增加了功能\n\n     append() -- 在字符串的末尾添加字符 直接用str1+str2也可以\n     find() -- 在字符串中查找字符串\n     insert() -- 插入字符\n     length() -- 返回字符串的长度 不包含空字符'\\0'\n     replace() -- 替换字符串\n     substr() -- 返回某个子字符串\n     ...\n\n## 遇到的问题 \n1. 常量字符串不能修改\n    **p指向常量字符串(位于常量存储区),内容不能修改**    \n    \n        // p a存放在栈区,\"string\"字面值存放在常量区\n        char *p = \"string\"; //可以访问单个字符p[2] 不能直接更改p[2] = 'I'\n        char a[] = \"string\"; //这里字符数组会把\"string\"拷贝到栈区,可以直接更改a[2] = 'I' \n        \n    一、程序的内存分配\n    - 栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量值等；\n    - 堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统OS回收。注意它与数据结构中的堆是两回事，**分配方式倒是类似于链表**； （malloc,new,free,delete）\n    - 全局区(静态区 static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；\n    - 文字常量区：常量字符串就是放在这里，程序结束后由系统释放；\n    - 程序代码区：存放函数体的二进制代码。\n    \n    栈区系统分配,速度快,但是程序员无法控制;堆区用起来方便,但是速度慢,容易产生内存碎片\n    \n\n##引用\n1. [char *p = \"abcdefg\"； 常量字符串\"abcdefg\"位于静态存储区，通过p不能修改该字符串常量](https://blog.csdn.net/Castiellee929/article/details/88628617)    \n2. [char *p = \"abcd\"; 和 char a[] = \"abcd\"的区别](https://blog.csdn.net/dongfanglanyi/article/details/81386752?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)    \n ","slug":"c-string与c风格字符串","published":1,"updated":"2020-09-23T14:42:00.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chj0011mxka09m5da3b","content":"<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组，大小比单词多一个</p>\n<p>不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。</p>\n<p>建议使用c++ string</p>\n<pre><code>char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\0&#39;}; \nchar greeting[] = &quot;Hello&quot;;  \n</code></pre><h3 id=\"c-操作c风格字符串\"><a href=\"#c-操作c风格字符串\" class=\"headerlink\" title=\"c++操作c风格字符串\"></a>c++操作c风格字符串</h3><p>复制,连接,查找,比较,<strong>需要#include \\<cstring\\></cstring\\></strong></p>\n<p><strong>strlen(s1)获得的长度不包含空字符’\\0’,string类的length()也是一样,</strong></p>\n<pre><code>#include &lt;cstring&gt;  \nstrcpy(s1, s2);   //复制字符串 s2 到字符串 s1\nstrcat(s1, s2);     //连接字符串 s2 到字符串 s1 的末尾\nstrlen(s1);         //返回字符串 s1 的长度 不包含空字符&#39;\\0&#39;\nstrcmp(s1, s2);     //如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0\nstrchr(s1, ch);     //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置\nstrstr(s1, s2);     //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置\n</code></pre><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>c++ 支持上述所有操作,并增加了功能</p>\n<pre><code> append() -- 在字符串的末尾添加字符 直接用str1+str2也可以\n find() -- 在字符串中查找字符串\n insert() -- 插入字符\n length() -- 返回字符串的长度 不包含空字符&#39;\\0&#39;\n replace() -- 替换字符串\n substr() -- 返回某个子字符串\n ...\n</code></pre><h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li><p>常量字符串不能修改<br> <strong>p指向常量字符串(位于常量存储区),内容不能修改</strong>    </p>\n<pre><code> // p a存放在栈区,&quot;string&quot;字面值存放在常量区\n char *p = &quot;string&quot;; //可以访问单个字符p[2] 不能直接更改p[2] = &#39;I&#39;\n char a[] = &quot;string&quot;; //这里字符数组会把&quot;string&quot;拷贝到栈区,可以直接更改a[2] = &#39;I&#39; \n</code></pre><p> 一、程序的内存分配</p>\n<ul>\n<li>栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量值等；</li>\n<li>堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统OS回收。注意它与数据结构中的堆是两回事，<strong>分配方式倒是类似于链表</strong>； （malloc,new,free,delete）</li>\n<li>全局区(静态区 static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；</li>\n<li>文字常量区：常量字符串就是放在这里，程序结束后由系统释放；</li>\n<li><p>程序代码区：存放函数体的二进制代码。</p>\n<p>栈区系统分配,速度快,但是程序员无法控制;堆区用起来方便,但是速度慢,容易产生内存碎片</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/Castiellee929/article/details/88628617\" target=\"_blank\" rel=\"noopener\">char *p = “abcdefg”； 常量字符串”abcdefg”位于静态存储区，通过p不能修改该字符串常量</a>    </li>\n<li><a href=\"https://blog.csdn.net/dongfanglanyi/article/details/81386752?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">char *p = “abcd”; 和 char a[] = “abcd”的区别</a>    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组，大小比单词多一个</p>\n<p>不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ‘\\0’ 放在字符串的末尾。</p>\n<p>建议使用c++ string</p>\n<pre><code>char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\0&#39;}; \nchar greeting[] = &quot;Hello&quot;;  \n</code></pre><h3 id=\"c-操作c风格字符串\"><a href=\"#c-操作c风格字符串\" class=\"headerlink\" title=\"c++操作c风格字符串\"></a>c++操作c风格字符串</h3><p>复制,连接,查找,比较,<strong>需要#include \\<cstring\\></cstring\\></strong></p>\n<p><strong>strlen(s1)获得的长度不包含空字符’\\0’,string类的length()也是一样,</strong></p>\n<pre><code>#include &lt;cstring&gt;  \nstrcpy(s1, s2);   //复制字符串 s2 到字符串 s1\nstrcat(s1, s2);     //连接字符串 s2 到字符串 s1 的末尾\nstrlen(s1);         //返回字符串 s1 的长度 不包含空字符&#39;\\0&#39;\nstrcmp(s1, s2);     //如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0\nstrchr(s1, ch);     //返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置\nstrstr(s1, s2);     //返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置\n</code></pre><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><p>c++ 支持上述所有操作,并增加了功能</p>\n<pre><code> append() -- 在字符串的末尾添加字符 直接用str1+str2也可以\n find() -- 在字符串中查找字符串\n insert() -- 插入字符\n length() -- 返回字符串的长度 不包含空字符&#39;\\0&#39;\n replace() -- 替换字符串\n substr() -- 返回某个子字符串\n ...\n</code></pre><h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li><p>常量字符串不能修改<br> <strong>p指向常量字符串(位于常量存储区),内容不能修改</strong>    </p>\n<pre><code> // p a存放在栈区,&quot;string&quot;字面值存放在常量区\n char *p = &quot;string&quot;; //可以访问单个字符p[2] 不能直接更改p[2] = &#39;I&#39;\n char a[] = &quot;string&quot;; //这里字符数组会把&quot;string&quot;拷贝到栈区,可以直接更改a[2] = &#39;I&#39; \n</code></pre><p> 一、程序的内存分配</p>\n<ul>\n<li>栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量值等；</li>\n<li>堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统OS回收。注意它与数据结构中的堆是两回事，<strong>分配方式倒是类似于链表</strong>； （malloc,new,free,delete）</li>\n<li>全局区(静态区 static)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放；</li>\n<li>文字常量区：常量字符串就是放在这里，程序结束后由系统释放；</li>\n<li><p>程序代码区：存放函数体的二进制代码。</p>\n<p>栈区系统分配,速度快,但是程序员无法控制;堆区用起来方便,但是速度慢,容易产生内存碎片</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/Castiellee929/article/details/88628617\" target=\"_blank\" rel=\"noopener\">char *p = “abcdefg”； 常量字符串”abcdefg”位于静态存储区，通过p不能修改该字符串常量</a>    </li>\n<li><a href=\"https://blog.csdn.net/dongfanglanyi/article/details/81386752?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">char *p = “abcd”; 和 char a[] = “abcd”的区别</a>    </li>\n</ol>\n"},{"title":"hexo博客和gitbook配置","date":"2019-10-06T00:36:02.000Z","_content":"环境：ubuntu16.04\n# gitbook简介\n创作和管理电子书，是目前最流行的开源书籍写作方案\ngitbook基于Node.js 开发，需要通过 Node.js 包管理工具 NPM 安装\n\n简单来说Node.js就是运行在服务端的JavaScript\nnpm 常用命令\n\n    npm update <name>   # 更新指定包\n    npm install npm -g  # 全局更新自己 \n    npm view <package> version  #查看包版本号\n## 环境配置\n\n- nodejs\n- gitbook\n\n        sudo apt-get install nodejs   # 可能还需要安装nodejs-legacy 这是因为需要node 但是最好直接使用node升级 文章末尾\n        sudo apt-get install npm\n        sudo npm install gitbook-cli -g   #全局安装\n        # 可能需要安装 ebook-convert    Binary install或者Source install\n        sudo -v && wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin\n## 常用命令\n    gitbook init    #初始化 生成 README.md SUMMARY.md\n    gitbook serve   #启动服务 浏览器打开 http://localhost:4000/\n\n## 定义目录结构\n1. 先定义好结构，然后通过gitbook init自动生成目录结构对应的文件夹和Markdown文件\n2. 先创建好文件夹和Markdown文件再来编辑目录结构\n\n        # Summary\n        \n        * [项目简介](README.md)\n        * [快速开始](docs/快速开始.md)\n         * [环境搭建](docs/环境搭建.md)\n         * [简单使用](docs/简单使用.md)\n        * [学入学习](docs/深入学习) \n        \n# hexo博客搭建\n\n    sudo apt install nodejs\n    sudo apt install npm\n    \n    sudo npm install n -g\n    sudo n stable\n    \n    sudo npm install hexo-cli\n## 引用自己的文章\n\n    {% post_link 文章文件名(不要后缀) 文章标题(可选) %}    \n    \n## 踩过的坑\n1. hexo用着用着报错，提示node版本太低\n\n    升级node：\n        \n        node -v     #查看当前版本\n        sudo npm cache clean -f #清楚node缓存 有时候不用也可以\n        sudo npm install n -g   #安装node版本管理工具n\n        sudo n stable           #安装最新版node\n        \n        sudo n 8.9.4            #安装指定版本\n        node -v\n    \n       \n# 引用\n1. [GitBook 使用入门](https://blog.csdn.net/wirelessqa/article/details/72616471)\n2. [node升级的正确方法](https://blog.csdn.net/tlbaba/article/details/79412433)\n3. [Node.js教程](https://www.runoob.com/nodejs/nodejs-tutorial.html)","source":"_posts/hexo博客和gitbook配置.md","raw":"---\ntitle: hexo博客和gitbook配置\ndate: 2019-10-06 08:36:02\ncategories:\n- Linux\ntags:\n- hexo\n- blog\n- gitbook\n\n---\n环境：ubuntu16.04\n# gitbook简介\n创作和管理电子书，是目前最流行的开源书籍写作方案\ngitbook基于Node.js 开发，需要通过 Node.js 包管理工具 NPM 安装\n\n简单来说Node.js就是运行在服务端的JavaScript\nnpm 常用命令\n\n    npm update <name>   # 更新指定包\n    npm install npm -g  # 全局更新自己 \n    npm view <package> version  #查看包版本号\n## 环境配置\n\n- nodejs\n- gitbook\n\n        sudo apt-get install nodejs   # 可能还需要安装nodejs-legacy 这是因为需要node 但是最好直接使用node升级 文章末尾\n        sudo apt-get install npm\n        sudo npm install gitbook-cli -g   #全局安装\n        # 可能需要安装 ebook-convert    Binary install或者Source install\n        sudo -v && wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin\n## 常用命令\n    gitbook init    #初始化 生成 README.md SUMMARY.md\n    gitbook serve   #启动服务 浏览器打开 http://localhost:4000/\n\n## 定义目录结构\n1. 先定义好结构，然后通过gitbook init自动生成目录结构对应的文件夹和Markdown文件\n2. 先创建好文件夹和Markdown文件再来编辑目录结构\n\n        # Summary\n        \n        * [项目简介](README.md)\n        * [快速开始](docs/快速开始.md)\n         * [环境搭建](docs/环境搭建.md)\n         * [简单使用](docs/简单使用.md)\n        * [学入学习](docs/深入学习) \n        \n# hexo博客搭建\n\n    sudo apt install nodejs\n    sudo apt install npm\n    \n    sudo npm install n -g\n    sudo n stable\n    \n    sudo npm install hexo-cli\n## 引用自己的文章\n\n    {% post_link 文章文件名(不要后缀) 文章标题(可选) %}    \n    \n## 踩过的坑\n1. hexo用着用着报错，提示node版本太低\n\n    升级node：\n        \n        node -v     #查看当前版本\n        sudo npm cache clean -f #清楚node缓存 有时候不用也可以\n        sudo npm install n -g   #安装node版本管理工具n\n        sudo n stable           #安装最新版node\n        \n        sudo n 8.9.4            #安装指定版本\n        node -v\n    \n       \n# 引用\n1. [GitBook 使用入门](https://blog.csdn.net/wirelessqa/article/details/72616471)\n2. [node升级的正确方法](https://blog.csdn.net/tlbaba/article/details/79412433)\n3. [Node.js教程](https://www.runoob.com/nodejs/nodejs-tutorial.html)","slug":"hexo博客和gitbook配置","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chk0015mxkamwj7t9mf","content":"<p>环境：ubuntu16.04</p>\n<h1 id=\"gitbook简介\"><a href=\"#gitbook简介\" class=\"headerlink\" title=\"gitbook简介\"></a>gitbook简介</h1><p>创作和管理电子书，是目前最流行的开源书籍写作方案<br>gitbook基于Node.js 开发，需要通过 Node.js 包管理工具 NPM 安装</p>\n<p>简单来说Node.js就是运行在服务端的JavaScript<br>npm 常用命令</p>\n<pre><code>npm update &lt;name&gt;   # 更新指定包\nnpm install npm -g  # 全局更新自己 \nnpm view &lt;package&gt; version  #查看包版本号\n</code></pre><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ul>\n<li>nodejs</li>\n<li><p>gitbook</p>\n<pre><code>  sudo apt-get install nodejs   # 可能还需要安装nodejs-legacy 这是因为需要node 但是最好直接使用node升级 文章末尾\n  sudo apt-get install npm\n  sudo npm install gitbook-cli -g   #全局安装\n  # 可能需要安装 ebook-convert    Binary install或者Source install\n  sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin\n</code></pre><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>  gitbook init    #初始化 生成 README.md SUMMARY.md<br>  gitbook serve   #启动服务 浏览器打开 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></p>\n</li>\n</ul>\n<h2 id=\"定义目录结构\"><a href=\"#定义目录结构\" class=\"headerlink\" title=\"定义目录结构\"></a>定义目录结构</h2><ol>\n<li>先定义好结构，然后通过gitbook init自动生成目录结构对应的文件夹和Markdown文件</li>\n<li><p>先创建好文件夹和Markdown文件再来编辑目录结构</p>\n<pre><code> # Summary\n\n * [项目简介](README.md)\n * [快速开始](docs/快速开始.md)\n  * [环境搭建](docs/环境搭建.md)\n  * [简单使用](docs/简单使用.md)\n * [学入学习](docs/深入学习) \n</code></pre></li>\n</ol>\n<h1 id=\"hexo博客搭建\"><a href=\"#hexo博客搭建\" class=\"headerlink\" title=\"hexo博客搭建\"></a>hexo博客搭建</h1><pre><code>sudo apt install nodejs\nsudo apt install npm\n\nsudo npm install n -g\nsudo n stable\n\nsudo npm install hexo-cli\n</code></pre><h2 id=\"引用自己的文章\"><a href=\"#引用自己的文章\" class=\"headerlink\" title=\"引用自己的文章\"></a>引用自己的文章</h2><pre><code>{% post_link 文章文件名(不要后缀) 文章标题(可选) %}    \n</code></pre><h2 id=\"踩过的坑\"><a href=\"#踩过的坑\" class=\"headerlink\" title=\"踩过的坑\"></a>踩过的坑</h2><ol>\n<li><p>hexo用着用着报错，提示node版本太低</p>\n<p> 升级node：</p>\n<pre><code> node -v     #查看当前版本\n sudo npm cache clean -f #清楚node缓存 有时候不用也可以\n sudo npm install n -g   #安装node版本管理工具n\n sudo n stable           #安装最新版node\n\n sudo n 8.9.4            #安装指定版本\n node -v\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/wirelessqa/article/details/72616471\" target=\"_blank\" rel=\"noopener\">GitBook 使用入门</a></li>\n<li><a href=\"https://blog.csdn.net/tlbaba/article/details/79412433\" target=\"_blank\" rel=\"noopener\">node升级的正确方法</a></li>\n<li><a href=\"https://www.runoob.com/nodejs/nodejs-tutorial.html\" target=\"_blank\" rel=\"noopener\">Node.js教程</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>环境：ubuntu16.04</p>\n<h1 id=\"gitbook简介\"><a href=\"#gitbook简介\" class=\"headerlink\" title=\"gitbook简介\"></a>gitbook简介</h1><p>创作和管理电子书，是目前最流行的开源书籍写作方案<br>gitbook基于Node.js 开发，需要通过 Node.js 包管理工具 NPM 安装</p>\n<p>简单来说Node.js就是运行在服务端的JavaScript<br>npm 常用命令</p>\n<pre><code>npm update &lt;name&gt;   # 更新指定包\nnpm install npm -g  # 全局更新自己 \nnpm view &lt;package&gt; version  #查看包版本号\n</code></pre><h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ul>\n<li>nodejs</li>\n<li><p>gitbook</p>\n<pre><code>  sudo apt-get install nodejs   # 可能还需要安装nodejs-legacy 这是因为需要node 但是最好直接使用node升级 文章末尾\n  sudo apt-get install npm\n  sudo npm install gitbook-cli -g   #全局安装\n  # 可能需要安装 ebook-convert    Binary install或者Source install\n  sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin\n</code></pre><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>  gitbook init    #初始化 生成 README.md SUMMARY.md<br>  gitbook serve   #启动服务 浏览器打开 <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a></p>\n</li>\n</ul>\n<h2 id=\"定义目录结构\"><a href=\"#定义目录结构\" class=\"headerlink\" title=\"定义目录结构\"></a>定义目录结构</h2><ol>\n<li>先定义好结构，然后通过gitbook init自动生成目录结构对应的文件夹和Markdown文件</li>\n<li><p>先创建好文件夹和Markdown文件再来编辑目录结构</p>\n<pre><code> # Summary\n\n * [项目简介](README.md)\n * [快速开始](docs/快速开始.md)\n  * [环境搭建](docs/环境搭建.md)\n  * [简单使用](docs/简单使用.md)\n * [学入学习](docs/深入学习) \n</code></pre></li>\n</ol>\n<h1 id=\"hexo博客搭建\"><a href=\"#hexo博客搭建\" class=\"headerlink\" title=\"hexo博客搭建\"></a>hexo博客搭建</h1><pre><code>sudo apt install nodejs\nsudo apt install npm\n\nsudo npm install n -g\nsudo n stable\n\nsudo npm install hexo-cli\n</code></pre><h2 id=\"引用自己的文章\"><a href=\"#引用自己的文章\" class=\"headerlink\" title=\"引用自己的文章\"></a>引用自己的文章</h2><pre><code>{% post_link 文章文件名(不要后缀) 文章标题(可选) %}    \n</code></pre><h2 id=\"踩过的坑\"><a href=\"#踩过的坑\" class=\"headerlink\" title=\"踩过的坑\"></a>踩过的坑</h2><ol>\n<li><p>hexo用着用着报错，提示node版本太低</p>\n<p> 升级node：</p>\n<pre><code> node -v     #查看当前版本\n sudo npm cache clean -f #清楚node缓存 有时候不用也可以\n sudo npm install n -g   #安装node版本管理工具n\n sudo n stable           #安装最新版node\n\n sudo n 8.9.4            #安装指定版本\n node -v\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/wirelessqa/article/details/72616471\" target=\"_blank\" rel=\"noopener\">GitBook 使用入门</a></li>\n<li><a href=\"https://blog.csdn.net/tlbaba/article/details/79412433\" target=\"_blank\" rel=\"noopener\">node升级的正确方法</a></li>\n<li><a href=\"https://www.runoob.com/nodejs/nodejs-tutorial.html\" target=\"_blank\" rel=\"noopener\">Node.js教程</a></li>\n</ol>\n"},{"title":"c++中argc argv理解","date":"2020-01-22T09:27:07.000Z","_content":"经常发现main函数这样写\n \n    int main(int argc, char *argv[]){}\n先来看关于char的几种类型\n\n# `char * ,char ** ,char a[ ] ,char *a[ ]`\n    \n    char * : 指向字符的指针,本质上存储是一个地址,地址中对应的内容为char\n    char a[ ]:字符数组,数组里面每一个都是一个char\n    char** a:二级指针,a是一个指向char * 的指针,保存的是char*的地址\n    char *a[ ] :[ ]的优先级高于*,所以首先是一个数组,数组里面元素为指向char *的指针\n\nc语言没有字符串,用字符数组代替;c语言中字符串常量本质上是一个地址\n\n**C语言中操作字符串是通过它在内存中的存储单元的首地址进行的,这是字符串的终极本质**\n\n    char *s;\n    s = \"China\";   //\"China\"字符串常量,存放的是C的地址\n    \n**字符指针可以用 间接操作符 \\*取其内容,也可以用数组的下标形式 [],数组名也可以用 \\*操作,因为它本身表示一个地址**    \n\n# argc argv\n\n1. argc为int:运行程序所带参数个数(包括程序本身名字,这点类似Linux下bash编程)\n2. char* argv[]:存放内容包括 程序绝对路径+程序运行所带参数(全部转化为字符串)\n\n    \n# 引用\n1. [深入 `char * ,char ** ,char a[ ] ,char *a[]` 内核](https://blog.csdn.net/daiyutage/article/details/8604720)\n2. {% post_link 临时记录 操作符优先级 %}    ","source":"_posts/c-中argc-argv理解.md","raw":"---\ntitle: c++中argc argv理解\ndate: 2020-01-22 17:27:07\ncategories:\n- program\ntags:\n- c++\n- c\n---\n经常发现main函数这样写\n \n    int main(int argc, char *argv[]){}\n先来看关于char的几种类型\n\n# `char * ,char ** ,char a[ ] ,char *a[ ]`\n    \n    char * : 指向字符的指针,本质上存储是一个地址,地址中对应的内容为char\n    char a[ ]:字符数组,数组里面每一个都是一个char\n    char** a:二级指针,a是一个指向char * 的指针,保存的是char*的地址\n    char *a[ ] :[ ]的优先级高于*,所以首先是一个数组,数组里面元素为指向char *的指针\n\nc语言没有字符串,用字符数组代替;c语言中字符串常量本质上是一个地址\n\n**C语言中操作字符串是通过它在内存中的存储单元的首地址进行的,这是字符串的终极本质**\n\n    char *s;\n    s = \"China\";   //\"China\"字符串常量,存放的是C的地址\n    \n**字符指针可以用 间接操作符 \\*取其内容,也可以用数组的下标形式 [],数组名也可以用 \\*操作,因为它本身表示一个地址**    \n\n# argc argv\n\n1. argc为int:运行程序所带参数个数(包括程序本身名字,这点类似Linux下bash编程)\n2. char* argv[]:存放内容包括 程序绝对路径+程序运行所带参数(全部转化为字符串)\n\n    \n# 引用\n1. [深入 `char * ,char ** ,char a[ ] ,char *a[]` 内核](https://blog.csdn.net/daiyutage/article/details/8604720)\n2. {% post_link 临时记录 操作符优先级 %}    ","slug":"c-中argc-argv理解","published":1,"updated":"2020-09-23T14:42:00.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chl0018mxkamv03updi","content":"<p>经常发现main函数这样写</p>\n<pre><code>int main(int argc, char *argv[]){}\n</code></pre><p>先来看关于char的几种类型</p>\n<h1 id=\"char-char-char-a-char-a\"><a href=\"#char-char-char-a-char-a\" class=\"headerlink\" title=\"char * ,char ** ,char a[ ] ,char *a[ ]\"></a><code>char * ,char ** ,char a[ ] ,char *a[ ]</code></h1><pre><code>char * : 指向字符的指针,本质上存储是一个地址,地址中对应的内容为char\nchar a[ ]:字符数组,数组里面每一个都是一个char\nchar** a:二级指针,a是一个指向char * 的指针,保存的是char*的地址\nchar *a[ ] :[ ]的优先级高于*,所以首先是一个数组,数组里面元素为指向char *的指针\n</code></pre><p>c语言没有字符串,用字符数组代替;c语言中字符串常量本质上是一个地址</p>\n<p><strong>C语言中操作字符串是通过它在内存中的存储单元的首地址进行的,这是字符串的终极本质</strong></p>\n<pre><code>char *s;\ns = &quot;China&quot;;   //&quot;China&quot;字符串常量,存放的是C的地址\n</code></pre><p><strong>字符指针可以用 间接操作符 *取其内容,也可以用数组的下标形式 [],数组名也可以用 *操作,因为它本身表示一个地址</strong>    </p>\n<h1 id=\"argc-argv\"><a href=\"#argc-argv\" class=\"headerlink\" title=\"argc argv\"></a>argc argv</h1><ol>\n<li>argc为int:运行程序所带参数个数(包括程序本身名字,这点类似Linux下bash编程)</li>\n<li>char* argv[]:存放内容包括 程序绝对路径+程序运行所带参数(全部转化为字符串)</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/daiyutage/article/details/8604720\" target=\"_blank\" rel=\"noopener\">深入 <code>char * ,char ** ,char a[ ] ,char *a[]</code> 内核</a></li>\n<li>    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>经常发现main函数这样写</p>\n<pre><code>int main(int argc, char *argv[]){}\n</code></pre><p>先来看关于char的几种类型</p>\n<h1 id=\"char-char-char-a-char-a\"><a href=\"#char-char-char-a-char-a\" class=\"headerlink\" title=\"char * ,char ** ,char a[ ] ,char *a[ ]\"></a><code>char * ,char ** ,char a[ ] ,char *a[ ]</code></h1><pre><code>char * : 指向字符的指针,本质上存储是一个地址,地址中对应的内容为char\nchar a[ ]:字符数组,数组里面每一个都是一个char\nchar** a:二级指针,a是一个指向char * 的指针,保存的是char*的地址\nchar *a[ ] :[ ]的优先级高于*,所以首先是一个数组,数组里面元素为指向char *的指针\n</code></pre><p>c语言没有字符串,用字符数组代替;c语言中字符串常量本质上是一个地址</p>\n<p><strong>C语言中操作字符串是通过它在内存中的存储单元的首地址进行的,这是字符串的终极本质</strong></p>\n<pre><code>char *s;\ns = &quot;China&quot;;   //&quot;China&quot;字符串常量,存放的是C的地址\n</code></pre><p><strong>字符指针可以用 间接操作符 *取其内容,也可以用数组的下标形式 [],数组名也可以用 *操作,因为它本身表示一个地址</strong>    </p>\n<h1 id=\"argc-argv\"><a href=\"#argc-argv\" class=\"headerlink\" title=\"argc argv\"></a>argc argv</h1><ol>\n<li>argc为int:运行程序所带参数个数(包括程序本身名字,这点类似Linux下bash编程)</li>\n<li>char* argv[]:存放内容包括 程序绝对路径+程序运行所带参数(全部转化为字符串)</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/daiyutage/article/details/8604720\" target=\"_blank\" rel=\"noopener\">深入 <code>char * ,char ** ,char a[ ] ,char *a[]</code> 内核</a></li>\n<li>    </li>\n</ol>\n"},{"title":"make宏编译","date":"2019-11-02T14:32:22.000Z","_content":"\n- 简化编译时所需要下达的指令;\n- 若在编译完成之后,修改了某个原始码文件,\n则 make 仅会针对被修改了的文件进行编译,其他的 object file不会被更动;\n- 最后可以依照相依性来更新 (update) 执行档。\n\n# 语法变量\n    目标(target): 目标文件 1 目标文件 2\n    <tab>\n    gcc -o 欲建立的执行文件 目标文件 1 目标文件 2\n- 在 makefile 当中的 # 代表批注;\n- <tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符;\n- 目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 \n\nmakefile 示例 两个target \n**$@:代表目前的目标(target)**\n\n        main: main.o haha.o sin_value.o cos_value.o\n            gcc -o main main.o haha.o sin_value.o cos_value.o -lm\n        clean:\n            rm -f main main.o haha.o sin_value.o cos_value.o \n        \n        # 简化重复内容之后如下\n        # $@:代表目前的目标(target)\n        LIBS = -lm\n        OBJS = main.o haha.o sin_value.o cos_value.o\n        main: ${OBJS}\n            gcc -o $@ ${OBJS} ${LIBS}\n        clean:\n            rm -f main ${OBJS}  \n调用\n\n        make  (make main)   #调用main对象\n        make clean          #调用clean\n        make clean main     #先clean 再main\n        \n## 基本语法\n1. 变量与变量内容以『=』隔开,同时两边可以具有空格;\n2. 变量左边不可以有 <tab> ,例如上面范例的第一行 LIBS 左边不可以是 <tab>;\n3. 变量与变量内容在『=』两边不能具有『:』\n;\n4. 在习惯上,变数最好是以『大写字母』为主;\n5. 运用变量时,以 ${变量} 或 $(变量) 使用;\n6. 在该 shell 的环境变量是可以被套用的,例如提到的 CFLAGS 这个变数!\n7. 在指令列模式也可以给予变量。 \n## 变量\ngcc 在进行编译的行为时,会主动的去读取 CFLAGS 这个环境变量,所以,你可以直接在 shell\n定义出这个环境变量,也可以在 makefile 文件里面去定义,更可以在指令列当中给予\n\n    CFLAGS=\"-Wall\" make clean main      #指令中指定 或者在makefile中定义变量\n环境变量取用规则\n1. make 指令列后面加上的环境变量为优先;\n2. makefile 里面指定的环境变量第二;\n3. shell 原本具有的环境变量第三。    \n           \n# 源码安装\n1. diff  行对比\n        \n        diff -Naur passwd.old passwd.new > passwd.patch    # 生成补丁文件\n        diff /etc/rc0.d/ /etc/rc5.d/                       # 比较布姆下相同文件名\n                    \n2. patch\n    \n    用来更新源码安装的源文件,使用规则\n    \n        patch -p 数字 < patch_file\n        patch -R  -p 数字 < patch_file    #回复旧文件\n    patch_file 第一行写的是这样:\n\n        *** /home/guest/example/expatch.old\n    \n    『patch -p0 < patch_file 』时,则更新的文件是『 /home/guest/example/expatch.old 』,\n    \n    『patch -p1 < patch_file』,则更新的文件为『home/guest/example/expatch.old』,\n    \n    『patch -p4 < patch_file』则更新『expatch.old』\n    \n    **-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思!**  \n3. cmp 字节对比 可以用来对比binary             \n# 动态函数库.so  静态函数库.a\n将常用到的动态函式库先加载内存当中 (快取, cache),需要 ldconfig 与 /etc/ld.so.conf协助\n1. 首先,我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』,注意喔, 是目录而不是文件;\n2. 接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中;\n3. 同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中\n    \n        ldconfig [-f conf] [ -C cache]\n        ldconfig [-p]       #列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料!)\n    将动态函式库所在的目录名称写入\n    /etc/ld.so.conf.d/yourfile.conf 当中,然后执行 ldconfig 就可以  \n\n4. 查看可执行binary文件含有的动态函数库\n\n        ldd [-vdr] [filename]      \n# 检查软件正确性\n目前广泛应用的加密机制 MD5 SHA1 SHA256 计算文件的指纹码\n\nmd5sum/sha1sum/sha356sum\n    \n    md5sum/sha1sum/sha256sum [-bct] filename\n可以把Linux上的重要文件进行指纹数据库的建立,然后定期以shell script的方式检查    \n# 安装问题\n1. 缺少依赖库\n    查看文件夹下对应的config.log 里面有对应的debug信息\n2. 没有那个文件或目录  X11/Intrinsic.h\n        \n        yum provides */Intrinsic.h   # 使用了正则表达式 需要头文件属于哪个包 安装就好            \n# 引用\n1. [鸟哥Linux基础](http://linux.vbird.org/new_linux.php)   \n2. [xpenguins 的安装（问题来源于鸟哥基础篇）](https://blog.csdn.net/king_on/article/details/7799695)        ","source":"_posts/make宏编译.md","raw":"---\ntitle: make宏编译\ndate: 2019-11-02 22:32:22\ncategories:\n- Linux\ntags:\n- make\n---\n\n- 简化编译时所需要下达的指令;\n- 若在编译完成之后,修改了某个原始码文件,\n则 make 仅会针对被修改了的文件进行编译,其他的 object file不会被更动;\n- 最后可以依照相依性来更新 (update) 执行档。\n\n# 语法变量\n    目标(target): 目标文件 1 目标文件 2\n    <tab>\n    gcc -o 欲建立的执行文件 目标文件 1 目标文件 2\n- 在 makefile 当中的 # 代表批注;\n- <tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符;\n- 目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 \n\nmakefile 示例 两个target \n**$@:代表目前的目标(target)**\n\n        main: main.o haha.o sin_value.o cos_value.o\n            gcc -o main main.o haha.o sin_value.o cos_value.o -lm\n        clean:\n            rm -f main main.o haha.o sin_value.o cos_value.o \n        \n        # 简化重复内容之后如下\n        # $@:代表目前的目标(target)\n        LIBS = -lm\n        OBJS = main.o haha.o sin_value.o cos_value.o\n        main: ${OBJS}\n            gcc -o $@ ${OBJS} ${LIBS}\n        clean:\n            rm -f main ${OBJS}  \n调用\n\n        make  (make main)   #调用main对象\n        make clean          #调用clean\n        make clean main     #先clean 再main\n        \n## 基本语法\n1. 变量与变量内容以『=』隔开,同时两边可以具有空格;\n2. 变量左边不可以有 <tab> ,例如上面范例的第一行 LIBS 左边不可以是 <tab>;\n3. 变量与变量内容在『=』两边不能具有『:』\n;\n4. 在习惯上,变数最好是以『大写字母』为主;\n5. 运用变量时,以 ${变量} 或 $(变量) 使用;\n6. 在该 shell 的环境变量是可以被套用的,例如提到的 CFLAGS 这个变数!\n7. 在指令列模式也可以给予变量。 \n## 变量\ngcc 在进行编译的行为时,会主动的去读取 CFLAGS 这个环境变量,所以,你可以直接在 shell\n定义出这个环境变量,也可以在 makefile 文件里面去定义,更可以在指令列当中给予\n\n    CFLAGS=\"-Wall\" make clean main      #指令中指定 或者在makefile中定义变量\n环境变量取用规则\n1. make 指令列后面加上的环境变量为优先;\n2. makefile 里面指定的环境变量第二;\n3. shell 原本具有的环境变量第三。    \n           \n# 源码安装\n1. diff  行对比\n        \n        diff -Naur passwd.old passwd.new > passwd.patch    # 生成补丁文件\n        diff /etc/rc0.d/ /etc/rc5.d/                       # 比较布姆下相同文件名\n                    \n2. patch\n    \n    用来更新源码安装的源文件,使用规则\n    \n        patch -p 数字 < patch_file\n        patch -R  -p 数字 < patch_file    #回复旧文件\n    patch_file 第一行写的是这样:\n\n        *** /home/guest/example/expatch.old\n    \n    『patch -p0 < patch_file 』时,则更新的文件是『 /home/guest/example/expatch.old 』,\n    \n    『patch -p1 < patch_file』,则更新的文件为『home/guest/example/expatch.old』,\n    \n    『patch -p4 < patch_file』则更新『expatch.old』\n    \n    **-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思!**  \n3. cmp 字节对比 可以用来对比binary             \n# 动态函数库.so  静态函数库.a\n将常用到的动态函式库先加载内存当中 (快取, cache),需要 ldconfig 与 /etc/ld.so.conf协助\n1. 首先,我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』,注意喔, 是目录而不是文件;\n2. 接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中;\n3. 同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中\n    \n        ldconfig [-f conf] [ -C cache]\n        ldconfig [-p]       #列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料!)\n    将动态函式库所在的目录名称写入\n    /etc/ld.so.conf.d/yourfile.conf 当中,然后执行 ldconfig 就可以  \n\n4. 查看可执行binary文件含有的动态函数库\n\n        ldd [-vdr] [filename]      \n# 检查软件正确性\n目前广泛应用的加密机制 MD5 SHA1 SHA256 计算文件的指纹码\n\nmd5sum/sha1sum/sha356sum\n    \n    md5sum/sha1sum/sha256sum [-bct] filename\n可以把Linux上的重要文件进行指纹数据库的建立,然后定期以shell script的方式检查    \n# 安装问题\n1. 缺少依赖库\n    查看文件夹下对应的config.log 里面有对应的debug信息\n2. 没有那个文件或目录  X11/Intrinsic.h\n        \n        yum provides */Intrinsic.h   # 使用了正则表达式 需要头文件属于哪个包 安装就好            \n# 引用\n1. [鸟哥Linux基础](http://linux.vbird.org/new_linux.php)   \n2. [xpenguins 的安装（问题来源于鸟哥基础篇）](https://blog.csdn.net/king_on/article/details/7799695)        ","slug":"make宏编译","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chm001bmxkaa5k9sx7b","content":"<ul>\n<li>简化编译时所需要下达的指令;</li>\n<li>若在编译完成之后,修改了某个原始码文件,<br>则 make 仅会针对被修改了的文件进行编译,其他的 object file不会被更动;</li>\n<li>最后可以依照相依性来更新 (update) 执行档。</li>\n</ul>\n<h1 id=\"语法变量\"><a href=\"#语法变量\" class=\"headerlink\" title=\"语法变量\"></a>语法变量</h1><pre><code>目标(target): 目标文件 1 目标文件 2\n&lt;tab&gt;\ngcc -o 欲建立的执行文件 目标文件 1 目标文件 2\n</code></pre><ul>\n<li>在 makefile 当中的 # 代表批注;</li>\n<li><tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符;</tab></li>\n<li>目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 </li>\n</ul>\n<p>makefile 示例 两个target<br><strong>$@:代表目前的目标(target)</strong></p>\n<pre><code>    main: main.o haha.o sin_value.o cos_value.o\n        gcc -o main main.o haha.o sin_value.o cos_value.o -lm\n    clean:\n        rm -f main main.o haha.o sin_value.o cos_value.o \n\n    # 简化重复内容之后如下\n    # $@:代表目前的目标(target)\n    LIBS = -lm\n    OBJS = main.o haha.o sin_value.o cos_value.o\n    main: ${OBJS}\n        gcc -o $@ ${OBJS} ${LIBS}\n    clean:\n        rm -f main ${OBJS}  \n</code></pre><p>调用</p>\n<pre><code>    make  (make main)   #调用main对象\n    make clean          #调用clean\n    make clean main     #先clean 再main\n</code></pre><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ol>\n<li>变量与变量内容以『=』隔开,同时两边可以具有空格;</li>\n<li>变量左边不可以有 <tab> ,例如上面范例的第一行 LIBS 左边不可以是 <tab>;</tab></tab></li>\n<li>变量与变量内容在『=』两边不能具有『:』<br>;</li>\n<li>在习惯上,变数最好是以『大写字母』为主;</li>\n<li>运用变量时,以 ${变量} 或 $(变量) 使用;</li>\n<li>在该 shell 的环境变量是可以被套用的,例如提到的 CFLAGS 这个变数!</li>\n<li><p>在指令列模式也可以给予变量。 </p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>gcc 在进行编译的行为时,会主动的去读取 CFLAGS 这个环境变量,所以,你可以直接在 shell<br>定义出这个环境变量,也可以在 makefile 文件里面去定义,更可以在指令列当中给予</p>\n<p> CFLAGS=”-Wall” make clean main      #指令中指定 或者在makefile中定义变量<br>环境变量取用规则</p>\n</li>\n<li>make 指令列后面加上的环境变量为优先;</li>\n<li>makefile 里面指定的环境变量第二;</li>\n<li>shell 原本具有的环境变量第三。    </li>\n</ol>\n<h1 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h1><ol>\n<li><p>diff  行对比</p>\n<pre><code> diff -Naur passwd.old passwd.new &gt; passwd.patch    # 生成补丁文件\n diff /etc/rc0.d/ /etc/rc5.d/                       # 比较布姆下相同文件名\n</code></pre></li>\n<li><p>patch</p>\n<p> 用来更新源码安装的源文件,使用规则</p>\n<pre><code> patch -p 数字 &lt; patch_file\n patch -R  -p 数字 &lt; patch_file    #回复旧文件\n</code></pre><p> patch_file 第一行写的是这样:</p>\n<pre><code> *** /home/guest/example/expatch.old\n</code></pre><p> 『patch -p0 &lt; patch_file 』时,则更新的文件是『 /home/guest/example/expatch.old 』,</p>\n<p> 『patch -p1 &lt; patch_file』,则更新的文件为『home/guest/example/expatch.old』,</p>\n<p> 『patch -p4 &lt; patch_file』则更新『expatch.old』</p>\n<p> <strong>-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思!</strong>  </p>\n</li>\n<li>cmp 字节对比 可以用来对比binary             <h1 id=\"动态函数库-so-静态函数库-a\"><a href=\"#动态函数库-so-静态函数库-a\" class=\"headerlink\" title=\"动态函数库.so  静态函数库.a\"></a>动态函数库.so  静态函数库.a</h1>将常用到的动态函式库先加载内存当中 (快取, cache),需要 ldconfig 与 /etc/ld.so.conf协助</li>\n<li>首先,我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』,注意喔, 是目录而不是文件;</li>\n<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中;</li>\n<li><p>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</p>\n<pre><code> ldconfig [-f conf] [ -C cache]\n ldconfig [-p]       #列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料!)\n</code></pre><p> 将动态函式库所在的目录名称写入<br> /etc/ld.so.conf.d/yourfile.conf 当中,然后执行 ldconfig 就可以  </p>\n</li>\n<li><p>查看可执行binary文件含有的动态函数库</p>\n<pre><code> ldd [-vdr] [filename]      \n</code></pre><h1 id=\"检查软件正确性\"><a href=\"#检查软件正确性\" class=\"headerlink\" title=\"检查软件正确性\"></a>检查软件正确性</h1><p>目前广泛应用的加密机制 MD5 SHA1 SHA256 计算文件的指纹码</p>\n</li>\n</ol>\n<p>md5sum/sha1sum/sha356sum</p>\n<pre><code>md5sum/sha1sum/sha256sum [-bct] filename\n</code></pre><p>可以把Linux上的重要文件进行指纹数据库的建立,然后定期以shell script的方式检查    </p>\n<h1 id=\"安装问题\"><a href=\"#安装问题\" class=\"headerlink\" title=\"安装问题\"></a>安装问题</h1><ol>\n<li>缺少依赖库<br> 查看文件夹下对应的config.log 里面有对应的debug信息</li>\n<li><p>没有那个文件或目录  X11/Intrinsic.h</p>\n<pre><code> yum provides */Intrinsic.h   # 使用了正则表达式 需要头文件属于哪个包 安装就好            \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1></li>\n<li><a href=\"http://linux.vbird.org/new_linux.php\" target=\"_blank\" rel=\"noopener\">鸟哥Linux基础</a>   </li>\n<li><a href=\"https://blog.csdn.net/king_on/article/details/7799695\" target=\"_blank\" rel=\"noopener\">xpenguins 的安装（问题来源于鸟哥基础篇）</a>        </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>简化编译时所需要下达的指令;</li>\n<li>若在编译完成之后,修改了某个原始码文件,<br>则 make 仅会针对被修改了的文件进行编译,其他的 object file不会被更动;</li>\n<li>最后可以依照相依性来更新 (update) 执行档。</li>\n</ul>\n<h1 id=\"语法变量\"><a href=\"#语法变量\" class=\"headerlink\" title=\"语法变量\"></a>语法变量</h1><pre><code>目标(target): 目标文件 1 目标文件 2\n&lt;tab&gt;\ngcc -o 欲建立的执行文件 目标文件 1 目标文件 2\n</code></pre><ul>\n<li>在 makefile 当中的 # 代表批注;</li>\n<li><tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符;</tab></li>\n<li>目标 (target) 与相依文件(就是目标文件)之间需以『:』隔开。 </li>\n</ul>\n<p>makefile 示例 两个target<br><strong>$@:代表目前的目标(target)</strong></p>\n<pre><code>    main: main.o haha.o sin_value.o cos_value.o\n        gcc -o main main.o haha.o sin_value.o cos_value.o -lm\n    clean:\n        rm -f main main.o haha.o sin_value.o cos_value.o \n\n    # 简化重复内容之后如下\n    # $@:代表目前的目标(target)\n    LIBS = -lm\n    OBJS = main.o haha.o sin_value.o cos_value.o\n    main: ${OBJS}\n        gcc -o $@ ${OBJS} ${LIBS}\n    clean:\n        rm -f main ${OBJS}  \n</code></pre><p>调用</p>\n<pre><code>    make  (make main)   #调用main对象\n    make clean          #调用clean\n    make clean main     #先clean 再main\n</code></pre><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ol>\n<li>变量与变量内容以『=』隔开,同时两边可以具有空格;</li>\n<li>变量左边不可以有 <tab> ,例如上面范例的第一行 LIBS 左边不可以是 <tab>;</tab></tab></li>\n<li>变量与变量内容在『=』两边不能具有『:』<br>;</li>\n<li>在习惯上,变数最好是以『大写字母』为主;</li>\n<li>运用变量时,以 ${变量} 或 $(变量) 使用;</li>\n<li>在该 shell 的环境变量是可以被套用的,例如提到的 CFLAGS 这个变数!</li>\n<li><p>在指令列模式也可以给予变量。 </p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>gcc 在进行编译的行为时,会主动的去读取 CFLAGS 这个环境变量,所以,你可以直接在 shell<br>定义出这个环境变量,也可以在 makefile 文件里面去定义,更可以在指令列当中给予</p>\n<p> CFLAGS=”-Wall” make clean main      #指令中指定 或者在makefile中定义变量<br>环境变量取用规则</p>\n</li>\n<li>make 指令列后面加上的环境变量为优先;</li>\n<li>makefile 里面指定的环境变量第二;</li>\n<li>shell 原本具有的环境变量第三。    </li>\n</ol>\n<h1 id=\"源码安装\"><a href=\"#源码安装\" class=\"headerlink\" title=\"源码安装\"></a>源码安装</h1><ol>\n<li><p>diff  行对比</p>\n<pre><code> diff -Naur passwd.old passwd.new &gt; passwd.patch    # 生成补丁文件\n diff /etc/rc0.d/ /etc/rc5.d/                       # 比较布姆下相同文件名\n</code></pre></li>\n<li><p>patch</p>\n<p> 用来更新源码安装的源文件,使用规则</p>\n<pre><code> patch -p 数字 &lt; patch_file\n patch -R  -p 数字 &lt; patch_file    #回复旧文件\n</code></pre><p> patch_file 第一行写的是这样:</p>\n<pre><code> *** /home/guest/example/expatch.old\n</code></pre><p> 『patch -p0 &lt; patch_file 』时,则更新的文件是『 /home/guest/example/expatch.old 』,</p>\n<p> 『patch -p1 &lt; patch_file』,则更新的文件为『home/guest/example/expatch.old』,</p>\n<p> 『patch -p4 &lt; patch_file』则更新『expatch.old』</p>\n<p> <strong>-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思!</strong>  </p>\n</li>\n<li>cmp 字节对比 可以用来对比binary             <h1 id=\"动态函数库-so-静态函数库-a\"><a href=\"#动态函数库-so-静态函数库-a\" class=\"headerlink\" title=\"动态函数库.so  静态函数库.a\"></a>动态函数库.so  静态函数库.a</h1>将常用到的动态函式库先加载内存当中 (快取, cache),需要 ldconfig 与 /etc/ld.so.conf协助</li>\n<li>首先,我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』,注意喔, 是目录而不是文件;</li>\n<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中;</li>\n<li><p>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中</p>\n<pre><code> ldconfig [-f conf] [ -C cache]\n ldconfig [-p]       #列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料!)\n</code></pre><p> 将动态函式库所在的目录名称写入<br> /etc/ld.so.conf.d/yourfile.conf 当中,然后执行 ldconfig 就可以  </p>\n</li>\n<li><p>查看可执行binary文件含有的动态函数库</p>\n<pre><code> ldd [-vdr] [filename]      \n</code></pre><h1 id=\"检查软件正确性\"><a href=\"#检查软件正确性\" class=\"headerlink\" title=\"检查软件正确性\"></a>检查软件正确性</h1><p>目前广泛应用的加密机制 MD5 SHA1 SHA256 计算文件的指纹码</p>\n</li>\n</ol>\n<p>md5sum/sha1sum/sha356sum</p>\n<pre><code>md5sum/sha1sum/sha256sum [-bct] filename\n</code></pre><p>可以把Linux上的重要文件进行指纹数据库的建立,然后定期以shell script的方式检查    </p>\n<h1 id=\"安装问题\"><a href=\"#安装问题\" class=\"headerlink\" title=\"安装问题\"></a>安装问题</h1><ol>\n<li>缺少依赖库<br> 查看文件夹下对应的config.log 里面有对应的debug信息</li>\n<li><p>没有那个文件或目录  X11/Intrinsic.h</p>\n<pre><code> yum provides */Intrinsic.h   # 使用了正则表达式 需要头文件属于哪个包 安装就好            \n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1></li>\n<li><a href=\"http://linux.vbird.org/new_linux.php\" target=\"_blank\" rel=\"noopener\">鸟哥Linux基础</a>   </li>\n<li><a href=\"https://blog.csdn.net/king_on/article/details/7799695\" target=\"_blank\" rel=\"noopener\">xpenguins 的安装（问题来源于鸟哥基础篇）</a>        </li>\n</ol>\n"},{"title":"mathtype常用配置","date":"2019-11-30T13:39:27.000Z","_content":"\n# 常用快捷键\n    \n    ctrl + L    下标\n    ctrl + H    上标\n    ctrl + B    向量 公式样式  原本快捷键和其他软件冲突了,重新设置新的即可\n    Alt + B     math 样式\n# 获取公式对应的LaTex格式 方便hexo博客使用\n1. mathtype 复制粘贴选项 \n    选择AMSTex 或者 MathML 2.0(no namespace)\n    ![选项](mathtype.png)   \n\n2. **mathpix** 截图识别公式\n使用[mathpix](https://mathpix.com/),简单高效","source":"_posts/mathtype常用配置.md","raw":"---\ntitle: mathtype常用配置\ndate: 2019-11-30 21:39:27\ncategories:\n- software\ntags:\n- equation\n---\n\n# 常用快捷键\n    \n    ctrl + L    下标\n    ctrl + H    上标\n    ctrl + B    向量 公式样式  原本快捷键和其他软件冲突了,重新设置新的即可\n    Alt + B     math 样式\n# 获取公式对应的LaTex格式 方便hexo博客使用\n1. mathtype 复制粘贴选项 \n    选择AMSTex 或者 MathML 2.0(no namespace)\n    ![选项](mathtype.png)   \n\n2. **mathpix** 截图识别公式\n使用[mathpix](https://mathpix.com/),简单高效","slug":"mathtype常用配置","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chn001emxkaevspo4pi","content":"<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><pre><code>ctrl + L    下标\nctrl + H    上标\nctrl + B    向量 公式样式  原本快捷键和其他软件冲突了,重新设置新的即可\nAlt + B     math 样式\n</code></pre><h1 id=\"获取公式对应的LaTex格式-方便hexo博客使用\"><a href=\"#获取公式对应的LaTex格式-方便hexo博客使用\" class=\"headerlink\" title=\"获取公式对应的LaTex格式 方便hexo博客使用\"></a>获取公式对应的LaTex格式 方便hexo博客使用</h1><ol>\n<li><p>mathtype 复制粘贴选项<br> 选择AMSTex 或者 MathML 2.0(no namespace)<br> <img src=\"/2019/11/30/mathtype常用配置/mathtype.png\" alt=\"选项\">   </p>\n</li>\n<li><p><strong>mathpix</strong> 截图识别公式<br>使用<a href=\"https://mathpix.com/\" target=\"_blank\" rel=\"noopener\">mathpix</a>,简单高效</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><pre><code>ctrl + L    下标\nctrl + H    上标\nctrl + B    向量 公式样式  原本快捷键和其他软件冲突了,重新设置新的即可\nAlt + B     math 样式\n</code></pre><h1 id=\"获取公式对应的LaTex格式-方便hexo博客使用\"><a href=\"#获取公式对应的LaTex格式-方便hexo博客使用\" class=\"headerlink\" title=\"获取公式对应的LaTex格式 方便hexo博客使用\"></a>获取公式对应的LaTex格式 方便hexo博客使用</h1><ol>\n<li><p>mathtype 复制粘贴选项<br> 选择AMSTex 或者 MathML 2.0(no namespace)<br> <img src=\"/2019/11/30/mathtype常用配置/mathtype.png\" alt=\"选项\">   </p>\n</li>\n<li><p><strong>mathpix</strong> 截图识别公式<br>使用<a href=\"https://mathpix.com/\" target=\"_blank\" rel=\"noopener\">mathpix</a>,简单高效</p>\n</li>\n</ol>\n"},{"title":"matlab中常见问题","date":"2019-10-24T11:46:53.000Z","_content":"1. matlab中sin(x) sind(x) \n    \n    都是计算正弦的函数　第一个输入单位为弧度　第二个为度\n\n    对于特殊角的三角函数为有理数的　最好使用sind　很多时候为了保证计算精度会使用符号计算\n\n        sin(pi) = 1.2246e-16\n        sind(180) = 0\n        vpa(sind(180),32) = 0.0   % 设置显示精度　32位\n    小数转为有理分式      \n      \n        rat(0.3)   \n2. 关于reshape\n    reshape是按照列来重新排列 不要想当然 之前一个sigma_cube数据(1667x3 其中每个3x3是一个sigma)就是排错了         \n        \n","source":"_posts/matlab中常见问题.md","raw":"---\ntitle: matlab中常见问题\ndate: 2019-10-24 19:46:53\ncategories:\n- software\ntags:\n- matlab\n---\n1. matlab中sin(x) sind(x) \n    \n    都是计算正弦的函数　第一个输入单位为弧度　第二个为度\n\n    对于特殊角的三角函数为有理数的　最好使用sind　很多时候为了保证计算精度会使用符号计算\n\n        sin(pi) = 1.2246e-16\n        sind(180) = 0\n        vpa(sind(180),32) = 0.0   % 设置显示精度　32位\n    小数转为有理分式      \n      \n        rat(0.3)   \n2. 关于reshape\n    reshape是按照列来重新排列 不要想当然 之前一个sigma_cube数据(1667x3 其中每个3x3是一个sigma)就是排错了         \n        \n","slug":"matlab中常见问题","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cho001hmxka9f0pz0ty","content":"<ol>\n<li><p>matlab中sin(x) sind(x) </p>\n<p> 都是计算正弦的函数　第一个输入单位为弧度　第二个为度</p>\n<p> 对于特殊角的三角函数为有理数的　最好使用sind　很多时候为了保证计算精度会使用符号计算</p>\n<pre><code> sin(pi) = 1.2246e-16\n sind(180) = 0\n vpa(sind(180),32) = 0.0   % 设置显示精度　32位\n</code></pre><p> 小数转为有理分式      </p>\n<pre><code> rat(0.3)   \n</code></pre></li>\n<li>关于reshape<br> reshape是按照列来重新排列 不要想当然 之前一个sigma_cube数据(1667x3 其中每个3x3是一个sigma)就是排错了         </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>matlab中sin(x) sind(x) </p>\n<p> 都是计算正弦的函数　第一个输入单位为弧度　第二个为度</p>\n<p> 对于特殊角的三角函数为有理数的　最好使用sind　很多时候为了保证计算精度会使用符号计算</p>\n<pre><code> sin(pi) = 1.2246e-16\n sind(180) = 0\n vpa(sind(180),32) = 0.0   % 设置显示精度　32位\n</code></pre><p> 小数转为有理分式      </p>\n<pre><code> rat(0.3)   \n</code></pre></li>\n<li>关于reshape<br> reshape是按照列来重新排列 不要想当然 之前一个sigma_cube数据(1667x3 其中每个3x3是一个sigma)就是排错了         </li>\n</ol>\n"},{"title":"python 装饰器","date":"2020-11-10T06:00:30.000Z","_content":"\n## python装饰器 @property\n\n绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值\n\n可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用\n\n    class Student(object):\n    \n        @property\n        def score(self):\n            return self._score\n    \n        @score.setter\n        def score(self, value):\n            if not isinstance(value, int):\n                raise ValueError('score must be an integer!')\n            if value < 0 or value > 100:\n                raise ValueError('score must between 0 ~ 100!')\n            self._score = value\n把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法\n\n\n## 引用\n1. [廖雪峰python教程 使用@property](https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208)             \n\n\n","source":"_posts/python-装饰器.md","raw":"---\ntitle: python 装饰器\ndate: 2020-11-10 14:00:30\ncategories:\n- program\ntags:\n- python\n---\n\n## python装饰器 @property\n\n绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值\n\n可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用\n\n    class Student(object):\n    \n        @property\n        def score(self):\n            return self._score\n    \n        @score.setter\n        def score(self, value):\n            if not isinstance(value, int):\n                raise ValueError('score must be an integer!')\n            if value < 0 or value > 100:\n                raise ValueError('score must between 0 ~ 100!')\n            self._score = value\n把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法\n\n\n## 引用\n1. [廖雪峰python教程 使用@property](https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208)             \n\n\n","slug":"python-装饰器","published":1,"updated":"2020-11-10T06:08:12.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chp001mmxkacu8hlc5r","content":"<h2 id=\"python装饰器-property\"><a href=\"#python装饰器-property\" class=\"headerlink\" title=\"python装饰器 @property\"></a>python装饰器 @property</h2><p>绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值</p>\n<p>可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用</p>\n<pre><code>class Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError(&#39;score must be an integer!&#39;)\n        if value &lt; 0 or value &gt; 100:\n            raise ValueError(&#39;score must between 0 ~ 100!&#39;)\n        self._score = value\n</code></pre><p>把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208\" target=\"_blank\" rel=\"noopener\">廖雪峰python教程 使用@property</a>             </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"python装饰器-property\"><a href=\"#python装饰器-property\" class=\"headerlink\" title=\"python装饰器 @property\"></a>python装饰器 @property</h2><p>绑定属性时有时候我们只想只读类的属性值,或者有限制的更改类的属性值</p>\n<p>可以使用get()和set()方法,但是略显复杂,使用装饰器可以更简单,python内置的@property装饰器负责把方法变成属性调用</p>\n<pre><code>class Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError(&#39;score must be an integer!&#39;)\n        if value &lt; 0 or value &gt; 100:\n            raise ValueError(&#39;score must between 0 ~ 100!&#39;)\n        self._score = value\n</code></pre><p>把getter方法变成属性时只需要@property,@score.setter负责把setter方法变成属性赋值,对于只读属性可只定义getter方法</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400/1017502538658208\" target=\"_blank\" rel=\"noopener\">廖雪峰python教程 使用@property</a>             </li>\n</ol>\n"},{"title":"git基本使用","date":"2019-07-16T09:36:13.000Z","_content":"\ngit管理版本主要分三个地址进行层次提交\n- 工作区(Working Directory):当前目录,即电脑能看到的目录\n- 版本库(Repository):\n    - 暂存区(stage或index):git add提交目的区域;\n    - 分支(如master):git commit则会提交目的区域\n\n基本操作\n===\n1. 常用\n\n\t\tgit add readme.md\n\t\tgit commit -m \"add readme.md\"\n\t\tgit diff readme.md          \n\t\tgit status     \n\t\tgit log         \n\t\tgit log --pretty=oneline\n\t\tgit diff HEAD -- readme.md    # 可以不用HEAD\n\t\tgit rm test.txt     # 从版本库中删除该文件\n\t\t\n\t\t# 从暂存区恢复,可以丢弃工作区的修改 回到最近一次git commit或git add时的状态\n\t\tgit checkout -- readme.md   \n\t\t# 把暂存区的修改撤销掉（unstage）,重新放回工作区,HEAD表示当前分支\n\t\tgit reset HEAD readme.md    \n\t\t# 分支的回退针对已经进行了git commit操作\n\t\tgit reset --hard commitid\n\n2. 远程仓库\n\n\t\tgit remote add origin git@server-name:path/repo-name.git\n\t\tgit push -u origin master   # 第一次推送master分支的所有内容\n\t\tgit push origin master   # 可以直接使用git push\n3. 分支\n\n\t\tgit branch   # 查看分支\n\t\tgit branch <name>  # 创建分支\n\t\tgit checkout <name>   # 切换分支\n\t\tgit checkout -b <name>   # 创建+切换分支\n\t\tgit merge <name>   # 合并某分支到当前分支\n\t\tgit branch -d <name>   # 删除分支\n4. 冲突\n\n\t合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n\t\tgit log --graph --pretty=oneline --abbrev-commit  # 查看分支合并图\n\t\tgit merge --no-ff -m \"merge with no-ff\" dev   # 普通模式合并\n5. BUG分支\n\n\t\tgit stash  # 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\t\tgit stash list \n\t你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n\n\t\t$ git stash apply stash@{0}\n\t修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\t当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再\n\t\t\n\t\tgit stash pop  # 回到工作现场。\n6. 时光穿梭\n\t\t\n\t在Git中，用HEAD表示当前版本，也就是最新的提交版本(针对git log),上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n\t\tgit reset --hard commit_id  \n\t\tgit reflog   # 查看命令历史，以便确定要回到未来的哪个版本\n\t\t# 回到之前版本发现未追踪文件,这是因为还没add 或commit就切换版本\n\t\t# 确认这些文件没用的话就可以直接clean,一般情况最好保留一个版本\n\t\tgit clean -df  \n7. feature\n\n\t\tgit branch -D <name>   # 丢弃一个没有被合并过的分支\n\t- master分支是主分支，因此要时刻与远程同步；\n\n\t- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n\t- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n\t- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n8. 合并commit\n    - git log 提交历史,显示提交过版本信息,不包括删除的commit和reset操作\n    - git reflog 命令历史,显示所有操作记录,包括提交,回退,合并等,一般用来回退\n    \n    合并commit针对git log\n        \n        git log     #查看commit记录\n        git rebase -i commitid  # 这里的id是不需要合并的commit对应id\n        # 进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)\n\ngit 遇到的问题\n===\n\n1. git add 文件添加失败\n\n提示modified content, untracked content是因为在add的时候这个目录下面本来就有一个.git文件，自然就会add失败，先删除这个.git文件再add\n\n还有问题可先删除缓存再来\n\tgit rm --cached filename\n\tgit add filename\n\tgit commit -m \"remark\"\n\tgit push origin master\n\n引用\n---\n1.廖雪峰 [Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)","source":"_posts/git基本使用.md","raw":"---\ntitle: git基本使用\ndate: 2019-07-16 17:36:13\ncategories:\n- Linux\ntags:\n- git\n\n---\n\ngit管理版本主要分三个地址进行层次提交\n- 工作区(Working Directory):当前目录,即电脑能看到的目录\n- 版本库(Repository):\n    - 暂存区(stage或index):git add提交目的区域;\n    - 分支(如master):git commit则会提交目的区域\n\n基本操作\n===\n1. 常用\n\n\t\tgit add readme.md\n\t\tgit commit -m \"add readme.md\"\n\t\tgit diff readme.md          \n\t\tgit status     \n\t\tgit log         \n\t\tgit log --pretty=oneline\n\t\tgit diff HEAD -- readme.md    # 可以不用HEAD\n\t\tgit rm test.txt     # 从版本库中删除该文件\n\t\t\n\t\t# 从暂存区恢复,可以丢弃工作区的修改 回到最近一次git commit或git add时的状态\n\t\tgit checkout -- readme.md   \n\t\t# 把暂存区的修改撤销掉（unstage）,重新放回工作区,HEAD表示当前分支\n\t\tgit reset HEAD readme.md    \n\t\t# 分支的回退针对已经进行了git commit操作\n\t\tgit reset --hard commitid\n\n2. 远程仓库\n\n\t\tgit remote add origin git@server-name:path/repo-name.git\n\t\tgit push -u origin master   # 第一次推送master分支的所有内容\n\t\tgit push origin master   # 可以直接使用git push\n3. 分支\n\n\t\tgit branch   # 查看分支\n\t\tgit branch <name>  # 创建分支\n\t\tgit checkout <name>   # 切换分支\n\t\tgit checkout -b <name>   # 创建+切换分支\n\t\tgit merge <name>   # 合并某分支到当前分支\n\t\tgit branch -d <name>   # 删除分支\n4. 冲突\n\n\t合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n\t\tgit log --graph --pretty=oneline --abbrev-commit  # 查看分支合并图\n\t\tgit merge --no-ff -m \"merge with no-ff\" dev   # 普通模式合并\n5. BUG分支\n\n\t\tgit stash  # 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\t\tgit stash list \n\t你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n\n\t\t$ git stash apply stash@{0}\n\t修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\t当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再\n\t\t\n\t\tgit stash pop  # 回到工作现场。\n6. 时光穿梭\n\t\t\n\t在Git中，用HEAD表示当前版本，也就是最新的提交版本(针对git log),上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n\t\tgit reset --hard commit_id  \n\t\tgit reflog   # 查看命令历史，以便确定要回到未来的哪个版本\n\t\t# 回到之前版本发现未追踪文件,这是因为还没add 或commit就切换版本\n\t\t# 确认这些文件没用的话就可以直接clean,一般情况最好保留一个版本\n\t\tgit clean -df  \n7. feature\n\n\t\tgit branch -D <name>   # 丢弃一个没有被合并过的分支\n\t- master分支是主分支，因此要时刻与远程同步；\n\n\t- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\n\t- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\n\t- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n8. 合并commit\n    - git log 提交历史,显示提交过版本信息,不包括删除的commit和reset操作\n    - git reflog 命令历史,显示所有操作记录,包括提交,回退,合并等,一般用来回退\n    \n    合并commit针对git log\n        \n        git log     #查看commit记录\n        git rebase -i commitid  # 这里的id是不需要合并的commit对应id\n        # 进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)\n\ngit 遇到的问题\n===\n\n1. git add 文件添加失败\n\n提示modified content, untracked content是因为在add的时候这个目录下面本来就有一个.git文件，自然就会add失败，先删除这个.git文件再add\n\n还有问题可先删除缓存再来\n\tgit rm --cached filename\n\tgit add filename\n\tgit commit -m \"remark\"\n\tgit push origin master\n\n引用\n---\n1.廖雪峰 [Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)","slug":"git基本使用","published":1,"updated":"2020-11-15T05:24:07.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chq001pmxkaz0j6pcde","content":"<p>git管理版本主要分三个地址进行层次提交</p>\n<ul>\n<li>工作区(Working Directory):当前目录,即电脑能看到的目录</li>\n<li>版本库(Repository):<ul>\n<li>暂存区(stage或index):git add提交目的区域;</li>\n<li>分支(如master):git commit则会提交目的区域</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><ol>\n<li><p>常用</p>\n<pre><code> git add readme.md\n git commit -m &quot;add readme.md&quot;\n git diff readme.md          \n git status     \n git log         \n git log --pretty=oneline\n git diff HEAD -- readme.md    # 可以不用HEAD\n git rm test.txt     # 从版本库中删除该文件\n\n # 从暂存区恢复,可以丢弃工作区的修改 回到最近一次git commit或git add时的状态\n git checkout -- readme.md   \n # 把暂存区的修改撤销掉（unstage）,重新放回工作区,HEAD表示当前分支\n git reset HEAD readme.md    \n # 分支的回退针对已经进行了git commit操作\n git reset --hard commitid\n</code></pre></li>\n<li><p>远程仓库</p>\n<pre><code> git remote add origin git@server-name:path/repo-name.git\n git push -u origin master   # 第一次推送master分支的所有内容\n git push origin master   # 可以直接使用git push\n</code></pre></li>\n<li><p>分支</p>\n<pre><code> git branch   # 查看分支\n git branch &lt;name&gt;  # 创建分支\n git checkout &lt;name&gt;   # 切换分支\n git checkout -b &lt;name&gt;   # 创建+切换分支\n git merge &lt;name&gt;   # 合并某分支到当前分支\n git branch -d &lt;name&gt;   # 删除分支\n</code></pre></li>\n<li><p>冲突</p>\n<p> 合并分支时，加上—no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<pre><code> git log --graph --pretty=oneline --abbrev-commit  # 查看分支合并图\n git merge --no-ff -m &quot;merge with no-ff&quot; dev   # 普通模式合并\n</code></pre></li>\n<li><p>BUG分支</p>\n<pre><code> git stash  # 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n git stash list \n</code></pre><p> 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>\n<pre><code> $ git stash apply stash@{0}\n</code></pre><p> 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br> 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再</p>\n<pre><code> git stash pop  # 回到工作现场。\n</code></pre></li>\n<li><p>时光穿梭</p>\n<p> 在Git中，用HEAD表示当前版本，也就是最新的提交版本(针对git log),上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>\n<pre><code> git reset --hard commit_id  \n git reflog   # 查看命令历史，以便确定要回到未来的哪个版本\n # 回到之前版本发现未追踪文件,这是因为还没add 或commit就切换版本\n # 确认这些文件没用的话就可以直接clean,一般情况最好保留一个版本\n git clean -df  \n</code></pre></li>\n<li><p>feature</p>\n<pre><code> git branch -D &lt;name&gt;   # 丢弃一个没有被合并过的分支\n</code></pre><ul>\n<li><p>master分支是主分支，因此要时刻与远程同步；</p>\n</li>\n<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>\n</li>\n<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>\n</li>\n<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>\n</li>\n</ul>\n</li>\n<li><p>合并commit</p>\n<ul>\n<li>git log 提交历史,显示提交过版本信息,不包括删除的commit和reset操作</li>\n<li><p>git reflog 命令历史,显示所有操作记录,包括提交,回退,合并等,一般用来回退</p>\n<p>合并commit针对git log</p>\n<p>  git log     #查看commit记录<br>  git rebase -i commitid  # 这里的id是不需要合并的commit对应id</p>\n<h1 id=\"进入vim模式-根据提示进行pick-执行commit-或者squash-合并commit\"><a href=\"#进入vim模式-根据提示进行pick-执行commit-或者squash-合并commit\" class=\"headerlink\" title=\"进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)\"></a>进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)</h1></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"git-遇到的问题\"><a href=\"#git-遇到的问题\" class=\"headerlink\" title=\"git 遇到的问题\"></a>git 遇到的问题</h1><ol>\n<li>git add 文件添加失败</li>\n</ol>\n<p>提示modified content, untracked content是因为在add的时候这个目录下面本来就有一个.git文件，自然就会add失败，先删除这个.git文件再add</p>\n<p>还有问题可先删除缓存再来<br>    git rm —cached filename<br>    git add filename<br>    git commit -m “remark”<br>    git push origin master</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>1.廖雪峰 <a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\" rel=\"noopener\">Git教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>git管理版本主要分三个地址进行层次提交</p>\n<ul>\n<li>工作区(Working Directory):当前目录,即电脑能看到的目录</li>\n<li>版本库(Repository):<ul>\n<li>暂存区(stage或index):git add提交目的区域;</li>\n<li>分支(如master):git commit则会提交目的区域</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><ol>\n<li><p>常用</p>\n<pre><code> git add readme.md\n git commit -m &quot;add readme.md&quot;\n git diff readme.md          \n git status     \n git log         \n git log --pretty=oneline\n git diff HEAD -- readme.md    # 可以不用HEAD\n git rm test.txt     # 从版本库中删除该文件\n\n # 从暂存区恢复,可以丢弃工作区的修改 回到最近一次git commit或git add时的状态\n git checkout -- readme.md   \n # 把暂存区的修改撤销掉（unstage）,重新放回工作区,HEAD表示当前分支\n git reset HEAD readme.md    \n # 分支的回退针对已经进行了git commit操作\n git reset --hard commitid\n</code></pre></li>\n<li><p>远程仓库</p>\n<pre><code> git remote add origin git@server-name:path/repo-name.git\n git push -u origin master   # 第一次推送master分支的所有内容\n git push origin master   # 可以直接使用git push\n</code></pre></li>\n<li><p>分支</p>\n<pre><code> git branch   # 查看分支\n git branch &lt;name&gt;  # 创建分支\n git checkout &lt;name&gt;   # 切换分支\n git checkout -b &lt;name&gt;   # 创建+切换分支\n git merge &lt;name&gt;   # 合并某分支到当前分支\n git branch -d &lt;name&gt;   # 删除分支\n</code></pre></li>\n<li><p>冲突</p>\n<p> 合并分支时，加上—no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<pre><code> git log --graph --pretty=oneline --abbrev-commit  # 查看分支合并图\n git merge --no-ff -m &quot;merge with no-ff&quot; dev   # 普通模式合并\n</code></pre></li>\n<li><p>BUG分支</p>\n<pre><code> git stash  # 把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n git stash list \n</code></pre><p> 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p>\n<pre><code> $ git stash apply stash@{0}\n</code></pre><p> 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br> 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再</p>\n<pre><code> git stash pop  # 回到工作现场。\n</code></pre></li>\n<li><p>时光穿梭</p>\n<p> 在Git中，用HEAD表示当前版本，也就是最新的提交版本(针对git log),上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>\n<pre><code> git reset --hard commit_id  \n git reflog   # 查看命令历史，以便确定要回到未来的哪个版本\n # 回到之前版本发现未追踪文件,这是因为还没add 或commit就切换版本\n # 确认这些文件没用的话就可以直接clean,一般情况最好保留一个版本\n git clean -df  \n</code></pre></li>\n<li><p>feature</p>\n<pre><code> git branch -D &lt;name&gt;   # 丢弃一个没有被合并过的分支\n</code></pre><ul>\n<li><p>master分支是主分支，因此要时刻与远程同步；</p>\n</li>\n<li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>\n</li>\n<li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>\n</li>\n<li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>\n</li>\n</ul>\n</li>\n<li><p>合并commit</p>\n<ul>\n<li>git log 提交历史,显示提交过版本信息,不包括删除的commit和reset操作</li>\n<li><p>git reflog 命令历史,显示所有操作记录,包括提交,回退,合并等,一般用来回退</p>\n<p>合并commit针对git log</p>\n<p>  git log     #查看commit记录<br>  git rebase -i commitid  # 这里的id是不需要合并的commit对应id</p>\n<h1 id=\"进入vim模式-根据提示进行pick-执行commit-或者squash-合并commit\"><a href=\"#进入vim模式-根据提示进行pick-执行commit-或者squash-合并commit\" class=\"headerlink\" title=\"进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)\"></a>进入vim模式,根据提示进行pick(执行commit)或者squash(合并commit)</h1></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"git-遇到的问题\"><a href=\"#git-遇到的问题\" class=\"headerlink\" title=\"git 遇到的问题\"></a>git 遇到的问题</h1><ol>\n<li>git add 文件添加失败</li>\n</ol>\n<p>提示modified content, untracked content是因为在add的时候这个目录下面本来就有一个.git文件，自然就会add失败，先删除这个.git文件再add</p>\n<p>还有问题可先删除缓存再来<br>    git rm —cached filename<br>    git add filename<br>    git commit -m “remark”<br>    git push origin master</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>1.廖雪峰 <a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\" target=\"_blank\" rel=\"noopener\">Git教程</a></p>\n"},{"title":"hexo本地图片配置","date":"2019-07-16T00:45:17.000Z","_content":"\n## hexo 本地图片，避免图床\n\n\n官网有相关说明，[hexo图片上传说明](https://hexo.io/zh-cn/docs/asset-folders)\n\n\t1. 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true\n\t2. 执行 npm install hexo-asset-image –save 装插件(或者npm install https://github.com/CodeFalling/hexo-asset-image --save)\n\t3. 执行hexo new [xxxx],生成xxxx.md和xxxx文件夹\n\t4. 把要引用的图片拷贝到xxxx文件夹中\n\t5. 使用\\![]\\(xxxx/example.jpg)来引用本地图片\n\n## hexo 配置pdf显示\n1. 安装hexo-pdf插件\n\n        npm install -save hexo-pdf\n2. 拷贝pdf到资源文件夹\n    与文章同名的资源文件夹在配置图片时已经配置过,这里直接用\n3. 文章中引用\n    \n        {% pdf pdf文件名 %}\n    外部链接使用外部链接：\n        \n        {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %}\n            \n## 引用\n\n1. [hexo建站过程中踩的坑总结](https://alreadyright.github.io/2019/06/16/aboutHexo/)\n2. [hexo配置本地图片和pdf](https://jankin987.github.io/2018/09/19/02.Hexo/03.hexo%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%92%8Cpdf/)","source":"_posts/hexo本地图片配置.md","raw":"---\ntitle: hexo本地图片配置\ndate: 2019-07-16 08:45:17\ncategories:\n- blog\ntags:\n- blog\n\n---\n\n## hexo 本地图片，避免图床\n\n\n官网有相关说明，[hexo图片上传说明](https://hexo.io/zh-cn/docs/asset-folders)\n\n\t1. 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true\n\t2. 执行 npm install hexo-asset-image –save 装插件(或者npm install https://github.com/CodeFalling/hexo-asset-image --save)\n\t3. 执行hexo new [xxxx],生成xxxx.md和xxxx文件夹\n\t4. 把要引用的图片拷贝到xxxx文件夹中\n\t5. 使用\\![]\\(xxxx/example.jpg)来引用本地图片\n\n## hexo 配置pdf显示\n1. 安装hexo-pdf插件\n\n        npm install -save hexo-pdf\n2. 拷贝pdf到资源文件夹\n    与文章同名的资源文件夹在配置图片时已经配置过,这里直接用\n3. 文章中引用\n    \n        {% pdf pdf文件名 %}\n    外部链接使用外部链接：\n        \n        {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %}\n            \n## 引用\n\n1. [hexo建站过程中踩的坑总结](https://alreadyright.github.io/2019/06/16/aboutHexo/)\n2. [hexo配置本地图片和pdf](https://jankin987.github.io/2018/09/19/02.Hexo/03.hexo%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%92%8Cpdf/)","slug":"hexo本地图片配置","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chr001smxka83d7ik25","content":"<h2 id=\"hexo-本地图片，避免图床\"><a href=\"#hexo-本地图片，避免图床\" class=\"headerlink\" title=\"hexo 本地图片，避免图床\"></a>hexo 本地图片，避免图床</h2><p>官网有相关说明，<a href=\"https://hexo.io/zh-cn/docs/asset-folders\" target=\"_blank\" rel=\"noopener\">hexo图片上传说明</a></p>\n<pre><code>1. 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true\n2. 执行 npm install hexo-asset-image –save 装插件(或者npm install https://github.com/CodeFalling/hexo-asset-image --save)\n3. 执行hexo new [xxxx],生成xxxx.md和xxxx文件夹\n4. 把要引用的图片拷贝到xxxx文件夹中\n5. 使用\\![]\\(xxxx/example.jpg)来引用本地图片\n</code></pre><h2 id=\"hexo-配置pdf显示\"><a href=\"#hexo-配置pdf显示\" class=\"headerlink\" title=\"hexo 配置pdf显示\"></a>hexo 配置pdf显示</h2><ol>\n<li><p>安装hexo-pdf插件</p>\n<pre><code> npm install -save hexo-pdf\n</code></pre></li>\n<li>拷贝pdf到资源文件夹<br> 与文章同名的资源文件夹在配置图片时已经配置过,这里直接用</li>\n<li><p>文章中引用</p>\n<pre><code> {% pdf pdf文件名 %}\n</code></pre><p> 外部链接使用外部链接：</p>\n<pre><code> {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %}\n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://alreadyright.github.io/2019/06/16/aboutHexo/\" target=\"_blank\" rel=\"noopener\">hexo建站过程中踩的坑总结</a></li>\n<li><a href=\"https://jankin987.github.io/2018/09/19/02.Hexo/03.hexo%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%92%8Cpdf/\" target=\"_blank\" rel=\"noopener\">hexo配置本地图片和pdf</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hexo-本地图片，避免图床\"><a href=\"#hexo-本地图片，避免图床\" class=\"headerlink\" title=\"hexo 本地图片，避免图床\"></a>hexo 本地图片，避免图床</h2><p>官网有相关说明，<a href=\"https://hexo.io/zh-cn/docs/asset-folders\" target=\"_blank\" rel=\"noopener\">hexo图片上传说明</a></p>\n<pre><code>1. 设置站点配置_config.yml: 将post_asset_folder: false改为post_asset_folder: true\n2. 执行 npm install hexo-asset-image –save 装插件(或者npm install https://github.com/CodeFalling/hexo-asset-image --save)\n3. 执行hexo new [xxxx],生成xxxx.md和xxxx文件夹\n4. 把要引用的图片拷贝到xxxx文件夹中\n5. 使用\\![]\\(xxxx/example.jpg)来引用本地图片\n</code></pre><h2 id=\"hexo-配置pdf显示\"><a href=\"#hexo-配置pdf显示\" class=\"headerlink\" title=\"hexo 配置pdf显示\"></a>hexo 配置pdf显示</h2><ol>\n<li><p>安装hexo-pdf插件</p>\n<pre><code> npm install -save hexo-pdf\n</code></pre></li>\n<li>拷贝pdf到资源文件夹<br> 与文章同名的资源文件夹在配置图片时已经配置过,这里直接用</li>\n<li><p>文章中引用</p>\n<pre><code> {% pdf pdf文件名 %}\n</code></pre><p> 外部链接使用外部链接：</p>\n<pre><code> {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %}\n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://alreadyright.github.io/2019/06/16/aboutHexo/\" target=\"_blank\" rel=\"noopener\">hexo建站过程中踩的坑总结</a></li>\n<li><a href=\"https://jankin987.github.io/2018/09/19/02.Hexo/03.hexo%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%92%8Cpdf/\" target=\"_blank\" rel=\"noopener\">hexo配置本地图片和pdf</a></li>\n</ol>\n"},{"title":"qt记录","date":"2019-11-22T14:23:21.000Z","_content":"\n不清楚多看qt帮助文档,介绍非常详细\n\n# 常用函数使用\n1. QString的arg()函数可以自动替换掉QString中出现的占位符。\n\n        QString(\"[%1, %2]\").arg(x).arg(y);\n        // 加粗居中\n        QString(\"<center><h1>Press:(%1, %2)</h1></center>\").arg(QString::number(event->x()),QString::number(event->y()));\n        \n        // 数字转字符串也可以用\n        QString::number(num);\n2. 打印\n    打印出错信息\n        \n        #define cout qDebug() << \"[\" << __FILE__ << \":\" << __LINE__ <<\"]\"\n    \\n正常表示(换行)\n        \n        qDebug().noquote() << str;  //直接用qDebug() \\r和\\n都不能正常显示             \n3. event事件\n    **event()函数主要用于事件的分发**\n    \n    事件处理之后一定要调用父类相应事件处理函数,不然信号就不会继续往后穿,或者使用ignore()函数,如果使用accept()函数就相当如接受信号,不继续传\n        \n    事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）\n        \n        bool CustomWidget::event(QEvent *e)\n        {\n            if (e->type() == QEvent::KeyPress) {\n                QKeyEvent *keyEvent = static_cast<QKeyEvent *>(e);//强制类型转换\n                if (keyEvent->key() == Qt::Key_Tab) {\n                    qDebug() << \"You press tab.\";\n                    return true;\n                }\n            }\n            return QWidget::event(e);//必要的，重新处理其他事件\n        }\n    - 如果传入事件被处理,需要返回true,否则返回false,那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n    - 在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。\n    \n    可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；**对于其它我们不关心的事件，则需要调用父类的event()函数继续转发**，否则这个组件就只能处理我们定义的事件了。\n    \n    **注意:**QWidget中有一个mouseTracking属性,该属性用于设置是否追踪鼠标,默认是false(至少鼠标点击一次才会追踪).只有鼠标被追踪时,mouseMoveEvent()才会发出.\n    \n        EventLabel *label = new EventLabel;\n        label->setMouseTracking(true);\n        \n# 绘图\nQt 的绘图系统: 使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。\n\n绘图设备是指继承QPainterDevice的子类.\n\n- QPixmap   针对屏幕进行了优化,和平台相关,不能对图片进行修改\n- QBitmap QBitmap是QPixmap的一个子类，它的色深限定为1(只有两种状态,黑白),可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap.\n- QImage    和平台无关,可以对图片进行修改,可以在线程中绘图,专门为图像的像素级访问做了优化。\n- QPicture  保存绘图的状态(**二进制文件**),记录和重现  \n\nQImage与QPixmap之间的转换:\n    \n    fromImage\n    toImage \n        \n## Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互\n    \n如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理QPainter的绘制语句容易得多。并且，\n这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。\n\n        \n# 非模态对话框析构\n设置对话框属性即可,避免子函数结束造成对话框对象析构,\n或者堆上创建对象一直存在(设置父对象容易造成对话框一直占用资源)\n\n    dialog->setAttribute(Qt::WA_DeleteOnClose);\n\n# 文件\n读取:\n- QDataStream:二进制文件读取  \n- QTextStream:自动将 Unicode 编码同操作系统的编码进行转换;也会将换行符进行转换 \n\n有关文件本身信息,可以通过QFileInfo获取\n    \n    QFileInfo info(file);\n    qDebug() << info.baseName();                        \n    // 获取应用程序执行时的当前路径\n    QDir::currentPath()\n\n**最好使用 Qt 整型来进行读写,比如程序中的qint32.\n这保证了在任意平台和任意编译器都能够有相同的行为.**\n\n## 魔术数字\n二进制输出中经常使用的一种技术,放在文件开头用于标示文件\n\n二进制格式是人不可读的，并且通常具有相同的后缀名(比如 dat 之类),\n因此我们没有办法区分两个二进制文件哪个是合法的.\n所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性.\n\n## tcp实现简单文件传输\n**数字和特定长度字符串相互转换**\n        \n    QString str = QString(\"%1\").arg(10, 4, 10, QChar('0'));\n    qDebug() <<str<<\"num \"<<str.toInt();\n为防止TCP粘包,通常在开头增加一个或一组固定长度数字表示数据包的大小,类型(类型可用enum+switch)等\n\n    //封包\n    quint16 totalLen = numLen + buff.size();  //数据位长度可自定义,和一次读取大小有关\n    QString lenStr = QString(\"%1\").arg(totalLen, numLen, 10, QChar('0'));\n    buffSend.append(lenStr).append(buff);\n    tcpsocket->write(buffSend);\n    buffSend.clear();\n    //解包\n    quint16 lenMsg = QString(mybuffer.left(4)).toInt();\n    QByteArray msg = mybuff.mid(numLen, lenMsg-numLen);\n    mybuff = mybuff.right(mybuff.size()-lenMsg);  //总缓存区\n其实这里有考虑过使用QDataStream,但是由于通过\"<<\"写入会有其他信息,\n导致大小不是想要的,通常使用writeRawData来避免  \n\n## 多线程\n    \n    robotarm = new robotArm();  //robotArm继承QObject\n    connect(ui.pushButton, &QPushButton::clicked, robotarm, &robotArm::InitPos);\n    QThread *pthread = new QThread(this);\n    robotarm->moveToThread(pthread);\n    pthread->start();           ","source":"_posts/qt纪要.md","raw":"---\ntitle: qt记录\ndate: 2019-11-22 22:23:21\ncategories:\n- program\ntags:\n- qt\n---\n\n不清楚多看qt帮助文档,介绍非常详细\n\n# 常用函数使用\n1. QString的arg()函数可以自动替换掉QString中出现的占位符。\n\n        QString(\"[%1, %2]\").arg(x).arg(y);\n        // 加粗居中\n        QString(\"<center><h1>Press:(%1, %2)</h1></center>\").arg(QString::number(event->x()),QString::number(event->y()));\n        \n        // 数字转字符串也可以用\n        QString::number(num);\n2. 打印\n    打印出错信息\n        \n        #define cout qDebug() << \"[\" << __FILE__ << \":\" << __LINE__ <<\"]\"\n    \\n正常表示(换行)\n        \n        qDebug().noquote() << str;  //直接用qDebug() \\r和\\n都不能正常显示             \n3. event事件\n    **event()函数主要用于事件的分发**\n    \n    事件处理之后一定要调用父类相应事件处理函数,不然信号就不会继续往后穿,或者使用ignore()函数,如果使用accept()函数就相当如接受信号,不继续传\n        \n    事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）\n        \n        bool CustomWidget::event(QEvent *e)\n        {\n            if (e->type() == QEvent::KeyPress) {\n                QKeyEvent *keyEvent = static_cast<QKeyEvent *>(e);//强制类型转换\n                if (keyEvent->key() == Qt::Key_Tab) {\n                    qDebug() << \"You press tab.\";\n                    return true;\n                }\n            }\n            return QWidget::event(e);//必要的，重新处理其他事件\n        }\n    - 如果传入事件被处理,需要返回true,否则返回false,那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。\n    - 在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。\n    \n    可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；**对于其它我们不关心的事件，则需要调用父类的event()函数继续转发**，否则这个组件就只能处理我们定义的事件了。\n    \n    **注意:**QWidget中有一个mouseTracking属性,该属性用于设置是否追踪鼠标,默认是false(至少鼠标点击一次才会追踪).只有鼠标被追踪时,mouseMoveEvent()才会发出.\n    \n        EventLabel *label = new EventLabel;\n        label->setMouseTracking(true);\n        \n# 绘图\nQt 的绘图系统: 使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。\n\n绘图设备是指继承QPainterDevice的子类.\n\n- QPixmap   针对屏幕进行了优化,和平台相关,不能对图片进行修改\n- QBitmap QBitmap是QPixmap的一个子类，它的色深限定为1(只有两种状态,黑白),可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap.\n- QImage    和平台无关,可以对图片进行修改,可以在线程中绘图,专门为图像的像素级访问做了优化。\n- QPicture  保存绘图的状态(**二进制文件**),记录和重现  \n\nQImage与QPixmap之间的转换:\n    \n    fromImage\n    toImage \n        \n## Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互\n    \n如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理QPainter的绘制语句容易得多。并且，\n这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。\n\n        \n# 非模态对话框析构\n设置对话框属性即可,避免子函数结束造成对话框对象析构,\n或者堆上创建对象一直存在(设置父对象容易造成对话框一直占用资源)\n\n    dialog->setAttribute(Qt::WA_DeleteOnClose);\n\n# 文件\n读取:\n- QDataStream:二进制文件读取  \n- QTextStream:自动将 Unicode 编码同操作系统的编码进行转换;也会将换行符进行转换 \n\n有关文件本身信息,可以通过QFileInfo获取\n    \n    QFileInfo info(file);\n    qDebug() << info.baseName();                        \n    // 获取应用程序执行时的当前路径\n    QDir::currentPath()\n\n**最好使用 Qt 整型来进行读写,比如程序中的qint32.\n这保证了在任意平台和任意编译器都能够有相同的行为.**\n\n## 魔术数字\n二进制输出中经常使用的一种技术,放在文件开头用于标示文件\n\n二进制格式是人不可读的，并且通常具有相同的后缀名(比如 dat 之类),\n因此我们没有办法区分两个二进制文件哪个是合法的.\n所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性.\n\n## tcp实现简单文件传输\n**数字和特定长度字符串相互转换**\n        \n    QString str = QString(\"%1\").arg(10, 4, 10, QChar('0'));\n    qDebug() <<str<<\"num \"<<str.toInt();\n为防止TCP粘包,通常在开头增加一个或一组固定长度数字表示数据包的大小,类型(类型可用enum+switch)等\n\n    //封包\n    quint16 totalLen = numLen + buff.size();  //数据位长度可自定义,和一次读取大小有关\n    QString lenStr = QString(\"%1\").arg(totalLen, numLen, 10, QChar('0'));\n    buffSend.append(lenStr).append(buff);\n    tcpsocket->write(buffSend);\n    buffSend.clear();\n    //解包\n    quint16 lenMsg = QString(mybuffer.left(4)).toInt();\n    QByteArray msg = mybuff.mid(numLen, lenMsg-numLen);\n    mybuff = mybuff.right(mybuff.size()-lenMsg);  //总缓存区\n其实这里有考虑过使用QDataStream,但是由于通过\"<<\"写入会有其他信息,\n导致大小不是想要的,通常使用writeRawData来避免  \n\n## 多线程\n    \n    robotarm = new robotArm();  //robotArm继承QObject\n    connect(ui.pushButton, &QPushButton::clicked, robotarm, &robotArm::InitPos);\n    QThread *pthread = new QThread(this);\n    robotarm->moveToThread(pthread);\n    pthread->start();           ","slug":"qt纪要","published":1,"updated":"2020-10-27T07:08:39.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chs001xmxkaqr37av3r","content":"<p>不清楚多看qt帮助文档,介绍非常详细</p>\n<h1 id=\"常用函数使用\"><a href=\"#常用函数使用\" class=\"headerlink\" title=\"常用函数使用\"></a>常用函数使用</h1><ol>\n<li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。</p>\n<pre><code> QString(&quot;[%1, %2]&quot;).arg(x).arg(y);\n // 加粗居中\n QString(&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(QString::number(event-&gt;x()),QString::number(event-&gt;y()));\n\n // 数字转字符串也可以用\n QString::number(num);\n</code></pre></li>\n<li><p>打印<br> 打印出错信息</p>\n<pre><code> #define cout qDebug() &lt;&lt; &quot;[&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt;&quot;]&quot;\n</code></pre><p> \\n正常表示(换行)</p>\n<pre><code> qDebug().noquote() &lt;&lt; str;  //直接用qDebug() \\r和\\n都不能正常显示             \n</code></pre></li>\n<li><p>event事件<br> <strong>event()函数主要用于事件的分发</strong></p>\n<p> 事件处理之后一定要调用父类相应事件处理函数,不然信号就不会继续往后穿,或者使用ignore()函数,如果使用accept()函数就相当如接受信号,不继续传</p>\n<p> 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）</p>\n<pre><code> bool CustomWidget::event(QEvent *e)\n {\n     if (e-&gt;type() == QEvent::KeyPress) {\n         QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(e);//强制类型转换\n         if (keyEvent-&gt;key() == Qt::Key_Tab) {\n             qDebug() &lt;&lt; &quot;You press tab.&quot;;\n             return true;\n         }\n     }\n     return QWidget::event(e);//必要的，重新处理其他事件\n }\n</code></pre><ul>\n<li>如果传入事件被处理,需要返回true,否则返回false,那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</li>\n<li><p>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。</p>\n<p>可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；<strong>对于其它我们不关心的事件，则需要调用父类的event()函数继续转发</strong>，否则这个组件就只能处理我们定义的事件了。</p>\n<p><strong>注意:</strong>QWidget中有一个mouseTracking属性,该属性用于设置是否追踪鼠标,默认是false(至少鼠标点击一次才会追踪).只有鼠标被追踪时,mouseMoveEvent()才会发出.</p>\n<p>  EventLabel *label = new EventLabel;<br>  label-&gt;setMouseTracking(true);</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"绘图\"><a href=\"#绘图\" class=\"headerlink\" title=\"绘图\"></a>绘图</h1><p>Qt 的绘图系统: 使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</p>\n<p>绘图设备是指继承QPainterDevice的子类.</p>\n<ul>\n<li>QPixmap   针对屏幕进行了优化,和平台相关,不能对图片进行修改</li>\n<li>QBitmap QBitmap是QPixmap的一个子类，它的色深限定为1(只有两种状态,黑白),可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap.</li>\n<li>QImage    和平台无关,可以对图片进行修改,可以在线程中绘图,专门为图像的像素级访问做了优化。</li>\n<li>QPicture  保存绘图的状态(<strong>二进制文件</strong>),记录和重现  </li>\n</ul>\n<p>QImage与QPixmap之间的转换:</p>\n<pre><code>fromImage\ntoImage \n</code></pre><h2 id=\"Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互\"><a href=\"#Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互\" class=\"headerlink\" title=\"Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互\"></a>Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互</h2><p>如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理QPainter的绘制语句容易得多。并且，<br>这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。</p>\n<h1 id=\"非模态对话框析构\"><a href=\"#非模态对话框析构\" class=\"headerlink\" title=\"非模态对话框析构\"></a>非模态对话框析构</h1><p>设置对话框属性即可,避免子函数结束造成对话框对象析构,<br>或者堆上创建对象一直存在(设置父对象容易造成对话框一直占用资源)</p>\n<pre><code>dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);\n</code></pre><h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><p>读取:</p>\n<ul>\n<li>QDataStream:二进制文件读取  </li>\n<li>QTextStream:自动将 Unicode 编码同操作系统的编码进行转换;也会将换行符进行转换 </li>\n</ul>\n<p>有关文件本身信息,可以通过QFileInfo获取</p>\n<pre><code>QFileInfo info(file);\nqDebug() &lt;&lt; info.baseName();                        \n// 获取应用程序执行时的当前路径\nQDir::currentPath()\n</code></pre><p><strong>最好使用 Qt 整型来进行读写,比如程序中的qint32.<br>这保证了在任意平台和任意编译器都能够有相同的行为.</strong></p>\n<h2 id=\"魔术数字\"><a href=\"#魔术数字\" class=\"headerlink\" title=\"魔术数字\"></a>魔术数字</h2><p>二进制输出中经常使用的一种技术,放在文件开头用于标示文件</p>\n<p>二进制格式是人不可读的，并且通常具有相同的后缀名(比如 dat 之类),<br>因此我们没有办法区分两个二进制文件哪个是合法的.<br>所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性.</p>\n<h2 id=\"tcp实现简单文件传输\"><a href=\"#tcp实现简单文件传输\" class=\"headerlink\" title=\"tcp实现简单文件传输\"></a>tcp实现简单文件传输</h2><p><strong>数字和特定长度字符串相互转换</strong></p>\n<pre><code>QString str = QString(&quot;%1&quot;).arg(10, 4, 10, QChar(&#39;0&#39;));\nqDebug() &lt;&lt;str&lt;&lt;&quot;num &quot;&lt;&lt;str.toInt();\n</code></pre><p>为防止TCP粘包,通常在开头增加一个或一组固定长度数字表示数据包的大小,类型(类型可用enum+switch)等</p>\n<pre><code>//封包\nquint16 totalLen = numLen + buff.size();  //数据位长度可自定义,和一次读取大小有关\nQString lenStr = QString(&quot;%1&quot;).arg(totalLen, numLen, 10, QChar(&#39;0&#39;));\nbuffSend.append(lenStr).append(buff);\ntcpsocket-&gt;write(buffSend);\nbuffSend.clear();\n//解包\nquint16 lenMsg = QString(mybuffer.left(4)).toInt();\nQByteArray msg = mybuff.mid(numLen, lenMsg-numLen);\nmybuff = mybuff.right(mybuff.size()-lenMsg);  //总缓存区\n</code></pre><p>其实这里有考虑过使用QDataStream,但是由于通过”&lt;&lt;”写入会有其他信息,<br>导致大小不是想要的,通常使用writeRawData来避免  </p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><pre><code>robotarm = new robotArm();  //robotArm继承QObject\nconnect(ui.pushButton, &amp;QPushButton::clicked, robotarm, &amp;robotArm::InitPos);\nQThread *pthread = new QThread(this);\nrobotarm-&gt;moveToThread(pthread);\npthread-&gt;start();           \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>不清楚多看qt帮助文档,介绍非常详细</p>\n<h1 id=\"常用函数使用\"><a href=\"#常用函数使用\" class=\"headerlink\" title=\"常用函数使用\"></a>常用函数使用</h1><ol>\n<li><p>QString的arg()函数可以自动替换掉QString中出现的占位符。</p>\n<pre><code> QString(&quot;[%1, %2]&quot;).arg(x).arg(y);\n // 加粗居中\n QString(&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;).arg(QString::number(event-&gt;x()),QString::number(event-&gt;y()));\n\n // 数字转字符串也可以用\n QString::number(num);\n</code></pre></li>\n<li><p>打印<br> 打印出错信息</p>\n<pre><code> #define cout qDebug() &lt;&lt; &quot;[&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt;&quot;]&quot;\n</code></pre><p> \\n正常表示(换行)</p>\n<pre><code> qDebug().noquote() &lt;&lt; str;  //直接用qDebug() \\r和\\n都不能正常显示             \n</code></pre></li>\n<li><p>event事件<br> <strong>event()函数主要用于事件的分发</strong></p>\n<p> 事件处理之后一定要调用父类相应事件处理函数,不然信号就不会继续往后穿,或者使用ignore()函数,如果使用accept()函数就相当如接受信号,不继续传</p>\n<p> 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）</p>\n<pre><code> bool CustomWidget::event(QEvent *e)\n {\n     if (e-&gt;type() == QEvent::KeyPress) {\n         QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(e);//强制类型转换\n         if (keyEvent-&gt;key() == Qt::Key_Tab) {\n             qDebug() &lt;&lt; &quot;You press tab.&quot;;\n             return true;\n         }\n     }\n     return QWidget::event(e);//必要的，重新处理其他事件\n }\n</code></pre><ul>\n<li>如果传入事件被处理,需要返回true,否则返回false,那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</li>\n<li><p>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播。</p>\n<p>可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；<strong>对于其它我们不关心的事件，则需要调用父类的event()函数继续转发</strong>，否则这个组件就只能处理我们定义的事件了。</p>\n<p><strong>注意:</strong>QWidget中有一个mouseTracking属性,该属性用于设置是否追踪鼠标,默认是false(至少鼠标点击一次才会追踪).只有鼠标被追踪时,mouseMoveEvent()才会发出.</p>\n<p>  EventLabel *label = new EventLabel;<br>  label-&gt;setMouseTracking(true);</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"绘图\"><a href=\"#绘图\" class=\"headerlink\" title=\"绘图\"></a>绘图</h1><p>Qt 的绘图系统: 使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</p>\n<p>绘图设备是指继承QPainterDevice的子类.</p>\n<ul>\n<li>QPixmap   针对屏幕进行了优化,和平台相关,不能对图片进行修改</li>\n<li>QBitmap QBitmap是QPixmap的一个子类，它的色深限定为1(只有两种状态,黑白),可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap.</li>\n<li>QImage    和平台无关,可以对图片进行修改,可以在线程中绘图,专门为图像的像素级访问做了优化。</li>\n<li>QPicture  保存绘图的状态(<strong>二进制文件</strong>),记录和重现  </li>\n</ul>\n<p>QImage与QPixmap之间的转换:</p>\n<pre><code>fromImage\ntoImage \n</code></pre><h2 id=\"Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互\"><a href=\"#Graphics-View-Framework-提供了一种接口，用于管理大量自定义的-2D-图形元素，并与之进行交互\" class=\"headerlink\" title=\"Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互\"></a>Graphics View Framework:提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互</h2><p>如果你的图像中包含了成千上万的直线、多边形之类，管理这些对象要比管理QPainter的绘制语句容易得多。并且，<br>这些图形对象也更加符合面向对象的设计要求：一个很复杂的图形可以很方便的复用。</p>\n<h1 id=\"非模态对话框析构\"><a href=\"#非模态对话框析构\" class=\"headerlink\" title=\"非模态对话框析构\"></a>非模态对话框析构</h1><p>设置对话框属性即可,避免子函数结束造成对话框对象析构,<br>或者堆上创建对象一直存在(设置父对象容易造成对话框一直占用资源)</p>\n<pre><code>dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);\n</code></pre><h1 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h1><p>读取:</p>\n<ul>\n<li>QDataStream:二进制文件读取  </li>\n<li>QTextStream:自动将 Unicode 编码同操作系统的编码进行转换;也会将换行符进行转换 </li>\n</ul>\n<p>有关文件本身信息,可以通过QFileInfo获取</p>\n<pre><code>QFileInfo info(file);\nqDebug() &lt;&lt; info.baseName();                        \n// 获取应用程序执行时的当前路径\nQDir::currentPath()\n</code></pre><p><strong>最好使用 Qt 整型来进行读写,比如程序中的qint32.<br>这保证了在任意平台和任意编译器都能够有相同的行为.</strong></p>\n<h2 id=\"魔术数字\"><a href=\"#魔术数字\" class=\"headerlink\" title=\"魔术数字\"></a>魔术数字</h2><p>二进制输出中经常使用的一种技术,放在文件开头用于标示文件</p>\n<p>二进制格式是人不可读的，并且通常具有相同的后缀名(比如 dat 之类),<br>因此我们没有办法区分两个二进制文件哪个是合法的.<br>所以，我们定义的二进制格式通常具有一个魔术数字，用于标识文件的合法性.</p>\n<h2 id=\"tcp实现简单文件传输\"><a href=\"#tcp实现简单文件传输\" class=\"headerlink\" title=\"tcp实现简单文件传输\"></a>tcp实现简单文件传输</h2><p><strong>数字和特定长度字符串相互转换</strong></p>\n<pre><code>QString str = QString(&quot;%1&quot;).arg(10, 4, 10, QChar(&#39;0&#39;));\nqDebug() &lt;&lt;str&lt;&lt;&quot;num &quot;&lt;&lt;str.toInt();\n</code></pre><p>为防止TCP粘包,通常在开头增加一个或一组固定长度数字表示数据包的大小,类型(类型可用enum+switch)等</p>\n<pre><code>//封包\nquint16 totalLen = numLen + buff.size();  //数据位长度可自定义,和一次读取大小有关\nQString lenStr = QString(&quot;%1&quot;).arg(totalLen, numLen, 10, QChar(&#39;0&#39;));\nbuffSend.append(lenStr).append(buff);\ntcpsocket-&gt;write(buffSend);\nbuffSend.clear();\n//解包\nquint16 lenMsg = QString(mybuffer.left(4)).toInt();\nQByteArray msg = mybuff.mid(numLen, lenMsg-numLen);\nmybuff = mybuff.right(mybuff.size()-lenMsg);  //总缓存区\n</code></pre><p>其实这里有考虑过使用QDataStream,但是由于通过”&lt;&lt;”写入会有其他信息,<br>导致大小不是想要的,通常使用writeRawData来避免  </p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><pre><code>robotarm = new robotArm();  //robotArm继承QObject\nconnect(ui.pushButton, &amp;QPushButton::clicked, robotarm, &amp;robotArm::InitPos);\nQThread *pthread = new QThread(this);\nrobotarm-&gt;moveToThread(pthread);\npthread-&gt;start();           \n</code></pre>"},{"title":"mysql","date":"2020-04-21T15:15:25.000Z","_content":"\n## 常用语句\n    -- 显示数据库\n    show databases;\n    \n    -- 显示表格\n    show tables;\n    \n    -- 创建一个名称为car的数据库。\n    create database car;\n    \n    -- 使用数据库 car\n    use car;\n    \n    -- 删除数据库car\n    -- drop database car;\n    \n    -- 显示表格内容\n    select * from tableName;\n    \n    -- 创建表\n    create table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);\n    \n    -- 删除brand表\n    -- drop table brand;\n    \n    -- 插入数据\n    insert into brand(factory,name,price,sum, sell, last) values('一汽大众', '奥迪A6', 36, 50, 8, 42);\n\n    -- 更新数据\n    -- update brand set sell=5 , last=70 where factory='上海大众' and name='桑塔纳';\n\n\n\n## 遇到的问题\n### 无法插入中文\n1. 临时修改\n    - 查看客户端 编码字符 状态\n        \n            status;  // Client characterset: utf8\n            #Server characterset 和 Db     characterset 都是utf8\n    - 查看所有编码字符\n            \n            show variables like'%char%';\n    - 修改设置(gbk 也是支持中文)            \n        \n            set character_set_database=utf8;\n            set character_set_server=utf8;\n2. 永久修改修改配置文件\n    - 针对未创建的表\n            \n            sudo vim /etc/mysql/my.cnf\n            \n            # 末尾添加\n            [client]\n            default-character-set=utf8\n            [mysqld]\n            character-set-server=utf8\n\n\t    /etc/init.d/mysql restart  #重启服务\n    - 针对已经创建的表\n        \n            alter table `tablename` convert to character set utf8;\n            \n                             \n","source":"_posts/mysql.md","raw":"---\ntitle: mysql\ndate: 2020-04-21 23:15:25\ncategories:\n- program\ntags:\n- mysql\n---\n\n## 常用语句\n    -- 显示数据库\n    show databases;\n    \n    -- 显示表格\n    show tables;\n    \n    -- 创建一个名称为car的数据库。\n    create database car;\n    \n    -- 使用数据库 car\n    use car;\n    \n    -- 删除数据库car\n    -- drop database car;\n    \n    -- 显示表格内容\n    select * from tableName;\n    \n    -- 创建表\n    create table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);\n    \n    -- 删除brand表\n    -- drop table brand;\n    \n    -- 插入数据\n    insert into brand(factory,name,price,sum, sell, last) values('一汽大众', '奥迪A6', 36, 50, 8, 42);\n\n    -- 更新数据\n    -- update brand set sell=5 , last=70 where factory='上海大众' and name='桑塔纳';\n\n\n\n## 遇到的问题\n### 无法插入中文\n1. 临时修改\n    - 查看客户端 编码字符 状态\n        \n            status;  // Client characterset: utf8\n            #Server characterset 和 Db     characterset 都是utf8\n    - 查看所有编码字符\n            \n            show variables like'%char%';\n    - 修改设置(gbk 也是支持中文)            \n        \n            set character_set_database=utf8;\n            set character_set_server=utf8;\n2. 永久修改修改配置文件\n    - 针对未创建的表\n            \n            sudo vim /etc/mysql/my.cnf\n            \n            # 末尾添加\n            [client]\n            default-character-set=utf8\n            [mysqld]\n            character-set-server=utf8\n\n\t    /etc/init.d/mysql restart  #重启服务\n    - 针对已经创建的表\n        \n            alter table `tablename` convert to character set utf8;\n            \n                             \n","slug":"mysql","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cht0020mxkau4a7qj39","content":"<h2 id=\"常用语句\"><a href=\"#常用语句\" class=\"headerlink\" title=\"常用语句\"></a>常用语句</h2><pre><code>-- 显示数据库\nshow databases;\n\n-- 显示表格\nshow tables;\n\n-- 创建一个名称为car的数据库。\ncreate database car;\n\n-- 使用数据库 car\nuse car;\n\n-- 删除数据库car\n-- drop database car;\n\n-- 显示表格内容\nselect * from tableName;\n\n-- 创建表\ncreate table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);\n\n-- 删除brand表\n-- drop table brand;\n\n-- 插入数据\ninsert into brand(factory,name,price,sum, sell, last) values(&#39;一汽大众&#39;, &#39;奥迪A6&#39;, 36, 50, 8, 42);\n\n-- 更新数据\n-- update brand set sell=5 , last=70 where factory=&#39;上海大众&#39; and name=&#39;桑塔纳&#39;;\n</code></pre><h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><h3 id=\"无法插入中文\"><a href=\"#无法插入中文\" class=\"headerlink\" title=\"无法插入中文\"></a>无法插入中文</h3><ol>\n<li><p>临时修改</p>\n<ul>\n<li><p>查看客户端 编码字符 状态</p>\n<pre><code>  status;  // Client characterset: utf8\n  #Server characterset 和 Db     characterset 都是utf8\n</code></pre></li>\n<li><p>查看所有编码字符</p>\n<pre><code>  show variables like&#39;%char%&#39;;\n</code></pre></li>\n<li><p>修改设置(gbk 也是支持中文)            </p>\n<pre><code>  set character_set_database=utf8;\n  set character_set_server=utf8;\n</code></pre></li>\n</ul>\n</li>\n<li><p>永久修改修改配置文件</p>\n<ul>\n<li><p>针对未创建的表</p>\n<pre><code>  sudo vim /etc/mysql/my.cnf\n\n  # 末尾添加\n  [client]\n  default-character-set=utf8\n  [mysqld]\n  character-set-server=utf8\n</code></pre><p>  /etc/init.d/mysql restart  #重启服务</p>\n</li>\n<li><p>针对已经创建的表</p>\n<pre><code>  alter table `tablename` convert to character set utf8;\n</code></pre></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用语句\"><a href=\"#常用语句\" class=\"headerlink\" title=\"常用语句\"></a>常用语句</h2><pre><code>-- 显示数据库\nshow databases;\n\n-- 显示表格\nshow tables;\n\n-- 创建一个名称为car的数据库。\ncreate database car;\n\n-- 使用数据库 car\nuse car;\n\n-- 删除数据库car\n-- drop database car;\n\n-- 显示表格内容\nselect * from tableName;\n\n-- 创建表\ncreate table brand (id int primary key auto_increment, factory varchar(255), name varchar(255), price int, sum int, sell int, last int);\n\n-- 删除brand表\n-- drop table brand;\n\n-- 插入数据\ninsert into brand(factory,name,price,sum, sell, last) values(&#39;一汽大众&#39;, &#39;奥迪A6&#39;, 36, 50, 8, 42);\n\n-- 更新数据\n-- update brand set sell=5 , last=70 where factory=&#39;上海大众&#39; and name=&#39;桑塔纳&#39;;\n</code></pre><h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><h3 id=\"无法插入中文\"><a href=\"#无法插入中文\" class=\"headerlink\" title=\"无法插入中文\"></a>无法插入中文</h3><ol>\n<li><p>临时修改</p>\n<ul>\n<li><p>查看客户端 编码字符 状态</p>\n<pre><code>  status;  // Client characterset: utf8\n  #Server characterset 和 Db     characterset 都是utf8\n</code></pre></li>\n<li><p>查看所有编码字符</p>\n<pre><code>  show variables like&#39;%char%&#39;;\n</code></pre></li>\n<li><p>修改设置(gbk 也是支持中文)            </p>\n<pre><code>  set character_set_database=utf8;\n  set character_set_server=utf8;\n</code></pre></li>\n</ul>\n</li>\n<li><p>永久修改修改配置文件</p>\n<ul>\n<li><p>针对未创建的表</p>\n<pre><code>  sudo vim /etc/mysql/my.cnf\n\n  # 末尾添加\n  [client]\n  default-character-set=utf8\n  [mysqld]\n  character-set-server=utf8\n</code></pre><p>  /etc/init.d/mysql restart  #重启服务</p>\n</li>\n<li><p>针对已经创建的表</p>\n<pre><code>  alter table `tablename` convert to character set utf8;\n</code></pre></li>\n</ul>\n</li>\n</ol>\n"},{"title":"ssh远程登录","date":"2019-09-29T04:13:36.000Z","_content":"\n# ssh简介\n**S**ecure **Sh**ell(SSH) 可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。\n\nSSH之所以能够保证安全，原因在于它采用了非对称加密技术(**RSA**)加密了所有传输的数据。\n\n实现SSH登录需要服务器和客户端各自保存公钥和私钥\n\n# 安装\n\n\tsudo apt-get install openssh-client #本地主机运行此条，实际上通常是默认安装client端程序的\n\tsudo apt-get install openssh-server #服务器运行此条命令安装\n\tdpkg -l | grep ssh    #查看是否安装对应包\n# 启动\n\tsudo /etc/init.d/ssh start    #打开服务器服务  关闭 stop\n\tps -e | grep ssh    #可以查看服务是否启动\n# 登录\n\tssh 服务器端登录用户名@服务器ip地址  #客户端登录  特别注意用户名要正确\n\tssh-keygen -t rsa      #生成公钥私钥\n\tssh-copy-id server@10.1.1.20 #把公钥上传服务器 免密登录  \n\tssh-copy-id server@10.1.1.20 -i copyed_file_name  #指定复制的文件名  \n\t\n# 同一台电脑配置github gitlab的SSH\n两种方式：ssh-add  或者使用配置文件 下面介绍使用配置文件\n1. 生成密钥文件\n        \n        ssh-keygen -t rsa -C '1253156159@qq.com' // GitLab\n        // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): gitlab_ssh\n        \n        ssh-keygen -t rsa -C 'a1253156159@gmail.com' // GitHub\n        // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): github_ssh\n2. 进入到.ssh文件下,找到gitlab_ssh.pub 和 github_ssh.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上\n3. 存储本地key\n        ssh-agent -s\n        ssh-add ~/.ssh/id_rsa_github    // 输入生成秘钥时设置的密码\n        ssh-add ~/.ssh/id_rsa_gitlab    // 输入生成秘钥时设置的密码\n4. .ssh下创建config 文件\n        \n        Host github.com\n          HostName github.com\n          User a1253156159@gmail.com    # 登录的邮箱　用户名\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/github_ssh\n        \n        Host 10.1.1.20\n          HostName 10.1.1.20\n          User 1253156159@qq.com\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/gitlab_ssh\n          Port 80\n        \n        Host 10.1.1.20\n          HostName 10.1.1.20\n          User yang@yang-cp\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/gitlab_ssh\n          Port 22\n5. 因为在自己的服务器上搭建的局域网gitlab　所以服务器登录和gitlab登录的ip一样，导致不能登录服务器\n    nmap -sT -O 10.1.1.20           //查看ssh端口　默认是22\n    ssh server@10.1.1.20 -p 22      //指定端口就可以了\n6. 测试是否连接\n    ssh -T git@github.com            \n        \n    \n\n# 问题\nssh无秘钥登录报错sign_and_send_pubkey: signing failed: agent refused operation。\n表示ssh-agent 已经在运行了，但是找不到附加的任何keys，就是说你生成的key，没有附加到ssh-agent上，需要附加一下，执行    \n\n    eval \"$(ssh-agent -s)\"\n\tssh-add  \n\n\n# 参考\n\n1. [SSH简介及两种远程登录的方法](https://blog.csdn.net/li528405176/article/details/82810342)\n2. [如何在一台设备上同时配置github和gitlab的SSH](https://segmentfault.com/a/1190000020010343)\n3. [SSH原理与运用](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n","source":"_posts/ssh远程登录.md","raw":"---\ntitle: ssh远程登录\ndate: 2019-09-29 12:13:36\ncategories:\n- Linux\ntags:\n- ssh\n\n---\n\n# ssh简介\n**S**ecure **Sh**ell(SSH) 可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。\n\nSSH之所以能够保证安全，原因在于它采用了非对称加密技术(**RSA**)加密了所有传输的数据。\n\n实现SSH登录需要服务器和客户端各自保存公钥和私钥\n\n# 安装\n\n\tsudo apt-get install openssh-client #本地主机运行此条，实际上通常是默认安装client端程序的\n\tsudo apt-get install openssh-server #服务器运行此条命令安装\n\tdpkg -l | grep ssh    #查看是否安装对应包\n# 启动\n\tsudo /etc/init.d/ssh start    #打开服务器服务  关闭 stop\n\tps -e | grep ssh    #可以查看服务是否启动\n# 登录\n\tssh 服务器端登录用户名@服务器ip地址  #客户端登录  特别注意用户名要正确\n\tssh-keygen -t rsa      #生成公钥私钥\n\tssh-copy-id server@10.1.1.20 #把公钥上传服务器 免密登录  \n\tssh-copy-id server@10.1.1.20 -i copyed_file_name  #指定复制的文件名  \n\t\n# 同一台电脑配置github gitlab的SSH\n两种方式：ssh-add  或者使用配置文件 下面介绍使用配置文件\n1. 生成密钥文件\n        \n        ssh-keygen -t rsa -C '1253156159@qq.com' // GitLab\n        // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): gitlab_ssh\n        \n        ssh-keygen -t rsa -C 'a1253156159@gmail.com' // GitHub\n        // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): github_ssh\n2. 进入到.ssh文件下,找到gitlab_ssh.pub 和 github_ssh.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上\n3. 存储本地key\n        ssh-agent -s\n        ssh-add ~/.ssh/id_rsa_github    // 输入生成秘钥时设置的密码\n        ssh-add ~/.ssh/id_rsa_gitlab    // 输入生成秘钥时设置的密码\n4. .ssh下创建config 文件\n        \n        Host github.com\n          HostName github.com\n          User a1253156159@gmail.com    # 登录的邮箱　用户名\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/github_ssh\n        \n        Host 10.1.1.20\n          HostName 10.1.1.20\n          User 1253156159@qq.com\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/gitlab_ssh\n          Port 80\n        \n        Host 10.1.1.20\n          HostName 10.1.1.20\n          User yang@yang-cp\n          PreferredAuthentications publickey\n          IdentityFile ~/.ssh/gitlab_ssh\n          Port 22\n5. 因为在自己的服务器上搭建的局域网gitlab　所以服务器登录和gitlab登录的ip一样，导致不能登录服务器\n    nmap -sT -O 10.1.1.20           //查看ssh端口　默认是22\n    ssh server@10.1.1.20 -p 22      //指定端口就可以了\n6. 测试是否连接\n    ssh -T git@github.com            \n        \n    \n\n# 问题\nssh无秘钥登录报错sign_and_send_pubkey: signing failed: agent refused operation。\n表示ssh-agent 已经在运行了，但是找不到附加的任何keys，就是说你生成的key，没有附加到ssh-agent上，需要附加一下，执行    \n\n    eval \"$(ssh-agent -s)\"\n\tssh-add  \n\n\n# 参考\n\n1. [SSH简介及两种远程登录的方法](https://blog.csdn.net/li528405176/article/details/82810342)\n2. [如何在一台设备上同时配置github和gitlab的SSH](https://segmentfault.com/a/1190000020010343)\n3. [SSH原理与运用](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)\n","slug":"ssh远程登录","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chu0025mxkaxh5bkq54","content":"<h1 id=\"ssh简介\"><a href=\"#ssh简介\" class=\"headerlink\" title=\"ssh简介\"></a>ssh简介</h1><p><strong>S</strong>ecure <strong>Sh</strong>ell(SSH) 可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。</p>\n<p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(<strong>RSA</strong>)加密了所有传输的数据。</p>\n<p>实现SSH登录需要服务器和客户端各自保存公钥和私钥</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><pre><code>sudo apt-get install openssh-client #本地主机运行此条，实际上通常是默认安装client端程序的\nsudo apt-get install openssh-server #服务器运行此条命令安装\ndpkg -l | grep ssh    #查看是否安装对应包\n</code></pre><h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><pre><code>sudo /etc/init.d/ssh start    #打开服务器服务  关闭 stop\nps -e | grep ssh    #可以查看服务是否启动\n</code></pre><h1 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h1><pre><code>ssh 服务器端登录用户名@服务器ip地址  #客户端登录  特别注意用户名要正确\nssh-keygen -t rsa      #生成公钥私钥\nssh-copy-id server@10.1.1.20 #把公钥上传服务器 免密登录  \nssh-copy-id server@10.1.1.20 -i copyed_file_name  #指定复制的文件名  \n</code></pre><h1 id=\"同一台电脑配置github-gitlab的SSH\"><a href=\"#同一台电脑配置github-gitlab的SSH\" class=\"headerlink\" title=\"同一台电脑配置github gitlab的SSH\"></a>同一台电脑配置github gitlab的SSH</h1><p>两种方式：ssh-add  或者使用配置文件 下面介绍使用配置文件</p>\n<ol>\n<li><p>生成密钥文件</p>\n<pre><code> ssh-keygen -t rsa -C &#39;1253156159@qq.com&#39; // GitLab\n // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): gitlab_ssh\n\n ssh-keygen -t rsa -C &#39;a1253156159@gmail.com&#39; // GitHub\n // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): github_ssh\n</code></pre></li>\n<li>进入到.ssh文件下,找到gitlab_ssh.pub 和 github_ssh.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上</li>\n<li>存储本地key<pre><code> ssh-agent -s\n ssh-add ~/.ssh/id_rsa_github    // 输入生成秘钥时设置的密码\n ssh-add ~/.ssh/id_rsa_gitlab    // 输入生成秘钥时设置的密码\n</code></pre></li>\n<li><p>.ssh下创建config 文件</p>\n<pre><code> Host github.com\n   HostName github.com\n   User a1253156159@gmail.com    # 登录的邮箱　用户名\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/github_ssh\n\n Host 10.1.1.20\n   HostName 10.1.1.20\n   User 1253156159@qq.com\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/gitlab_ssh\n   Port 80\n\n Host 10.1.1.20\n   HostName 10.1.1.20\n   User yang@yang-cp\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/gitlab_ssh\n   Port 22\n</code></pre></li>\n<li>因为在自己的服务器上搭建的局域网gitlab　所以服务器登录和gitlab登录的ip一样，导致不能登录服务器<br> nmap -sT -O 10.1.1.20           //查看ssh端口　默认是22<br> ssh server@10.1.1.20 -p 22      //指定端口就可以了</li>\n<li>测试是否连接<br> ssh -T git@github.com            </li>\n</ol>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>ssh无秘钥登录报错sign_and_send_pubkey: signing failed: agent refused operation。<br>表示ssh-agent 已经在运行了，但是找不到附加的任何keys，就是说你生成的key，没有附加到ssh-agent上，需要附加一下，执行    </p>\n<pre><code>eval &quot;$(ssh-agent -s)&quot;\nssh-add  \n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/li528405176/article/details/82810342\" target=\"_blank\" rel=\"noopener\">SSH简介及两种远程登录的方法</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020010343\" target=\"_blank\" rel=\"noopener\">如何在一台设备上同时配置github和gitlab的SSH</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"noopener\">SSH原理与运用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ssh简介\"><a href=\"#ssh简介\" class=\"headerlink\" title=\"ssh简介\"></a>ssh简介</h1><p><strong>S</strong>ecure <strong>Sh</strong>ell(SSH) 可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。</p>\n<p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(<strong>RSA</strong>)加密了所有传输的数据。</p>\n<p>实现SSH登录需要服务器和客户端各自保存公钥和私钥</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><pre><code>sudo apt-get install openssh-client #本地主机运行此条，实际上通常是默认安装client端程序的\nsudo apt-get install openssh-server #服务器运行此条命令安装\ndpkg -l | grep ssh    #查看是否安装对应包\n</code></pre><h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><pre><code>sudo /etc/init.d/ssh start    #打开服务器服务  关闭 stop\nps -e | grep ssh    #可以查看服务是否启动\n</code></pre><h1 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h1><pre><code>ssh 服务器端登录用户名@服务器ip地址  #客户端登录  特别注意用户名要正确\nssh-keygen -t rsa      #生成公钥私钥\nssh-copy-id server@10.1.1.20 #把公钥上传服务器 免密登录  \nssh-copy-id server@10.1.1.20 -i copyed_file_name  #指定复制的文件名  \n</code></pre><h1 id=\"同一台电脑配置github-gitlab的SSH\"><a href=\"#同一台电脑配置github-gitlab的SSH\" class=\"headerlink\" title=\"同一台电脑配置github gitlab的SSH\"></a>同一台电脑配置github gitlab的SSH</h1><p>两种方式：ssh-add  或者使用配置文件 下面介绍使用配置文件</p>\n<ol>\n<li><p>生成密钥文件</p>\n<pre><code> ssh-keygen -t rsa -C &#39;1253156159@qq.com&#39; // GitLab\n // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): gitlab_ssh\n\n ssh-keygen -t rsa -C &#39;a1253156159@gmail.com&#39; // GitHub\n // Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): github_ssh\n</code></pre></li>\n<li>进入到.ssh文件下,找到gitlab_ssh.pub 和 github_ssh.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上</li>\n<li>存储本地key<pre><code> ssh-agent -s\n ssh-add ~/.ssh/id_rsa_github    // 输入生成秘钥时设置的密码\n ssh-add ~/.ssh/id_rsa_gitlab    // 输入生成秘钥时设置的密码\n</code></pre></li>\n<li><p>.ssh下创建config 文件</p>\n<pre><code> Host github.com\n   HostName github.com\n   User a1253156159@gmail.com    # 登录的邮箱　用户名\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/github_ssh\n\n Host 10.1.1.20\n   HostName 10.1.1.20\n   User 1253156159@qq.com\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/gitlab_ssh\n   Port 80\n\n Host 10.1.1.20\n   HostName 10.1.1.20\n   User yang@yang-cp\n   PreferredAuthentications publickey\n   IdentityFile ~/.ssh/gitlab_ssh\n   Port 22\n</code></pre></li>\n<li>因为在自己的服务器上搭建的局域网gitlab　所以服务器登录和gitlab登录的ip一样，导致不能登录服务器<br> nmap -sT -O 10.1.1.20           //查看ssh端口　默认是22<br> ssh server@10.1.1.20 -p 22      //指定端口就可以了</li>\n<li>测试是否连接<br> ssh -T git@github.com            </li>\n</ol>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>ssh无秘钥登录报错sign_and_send_pubkey: signing failed: agent refused operation。<br>表示ssh-agent 已经在运行了，但是找不到附加的任何keys，就是说你生成的key，没有附加到ssh-agent上，需要附加一下，执行    </p>\n<pre><code>eval &quot;$(ssh-agent -s)&quot;\nssh-add  \n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/li528405176/article/details/82810342\" target=\"_blank\" rel=\"noopener\">SSH简介及两种远程登录的方法</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020010343\" target=\"_blank\" rel=\"noopener\">如何在一台设备上同时配置github和gitlab的SSH</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html\" target=\"_blank\" rel=\"noopener\">SSH原理与运用</a></li>\n</ol>\n"},{"title":"python基础","date":"2020-05-22T08:52:49.000Z","_content":"\n很多简单模块容易忘,在此记录一下\n\n## 基础操作\n\n1. 查看帮助文档\n\n        import os\n        # 主要有3中类型 ,也可以针对具体函数\n        dir(os)\n        help(os) \n        os.__doc__\n2. 查看变量内存地址\n\n        # 需要注意有时候变量的复制是浅拷贝,地址相同的\n        # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了\n        print(id(object))\n3. 查看当前路径\n\n        import os\n        os.getcwd()\n4. copy模块\n\n\t- 注意python具有即时复制的功能\n\n\t\t\ta = 1\n\t\t\tb = a\n\t\t\tprint(id(a), id(b))\n\t\t\tb = 2\n\t\t\tprint(id(a), id(b))\n\n\t- 有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()\n\n5. python3中@\n\t矩阵乘法\n\n\t\tOp\tPrecedence/associativity\tMethods\n\t\t@\tSame as *\t\t\t\t\t__matmul__, __rmatmul__\n\t\t@=\tn/a\t\t\t\t\t\t\t__imatmul__\n\n6. numpy数组交换行列\n    \n        a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]])\n        a[:,[1,0,2]]\n     \t\t\n\n## 安装模块\n\n1. 常用安装命令\n\n        # 安装 conda环境可以使用conda install xxx\n        pip install package_name\n        pip install package_name==package_version\n        # 更新\n        pip install -U package_name\n        # 显示模块的信息\n        pip show package_name\n        # 查看对应包简单信息\n        pip list |grep package_name\n        # 卸载建议这种方式,不会会有残留文件(针对pip install -e .)\n        pip uninstall package_name  \n\n2. pip install -e . VS python setup.py install\n\n        Editable   pip                    setup.py\n        yes        pip install -e .       python setup.py develop    \n        no         pip install .          python setup.py install   \n\n- 可编辑模式安装(develop,可以在当前文件基础上修改)\n  \n  这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;\n  在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;\n  查看sys.path会发现里面多了一个项目根目录的路径\n  \n        pip install -e /path/to/your/setup.py  # 项目根目录                  \n- install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改\n\n## pybullet 结合 ROS\n将pybullet中获取的图像通过变换获得对应的点云图\n{% pdf OPGL_pointcloud.pdf %}\n1. Image  numpy array to sensor_msgs/Image\n        \n        from cv_bridge import CvBridge\n        import numpy as np\n        from sensor_msgs.msg import Image\n        \n        # 确保能都找到正确的opencv2的位置\n        import sys\n        sys.path.remove('/opt/ros/kinetic/lib/python2.7/dist-packages')\n        import cv2\n        \n        rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame()\n        bridge = CvBridge()\n        image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype('uint8'))  # default bgra8\n        \n2. Pointcloud numpy to sensor_msgs/PointCloud2     \n    \n        import ros_numpy\n        import numpy as np\n        from sensor_msgs.msg import PointCloud2, PointField\n        \n        number = point_cloud.shape[0] * point_cloud.shape[1]\n        point_cloud_arr = point_cloud.reshape([number, 3])\n        data = np.zeros(number, dtype=[\n            ('x', np.float32),\n            ('y', np.float32),\n            ('z', np.float32)\n        ])\n        data['x'] = point_cloud_arr[:, 0]\n        data['y'] = point_cloud_arr[:, 1]\n        data['z'] = point_cloud_arr[:, 2]\n\n        cloud_msg = ros_numpy.msgify(PointCloud2, data)\n        cloud_msg.header.frame_id = \"map\"\n        \n3. pointcloud from image deepth\n    reshape 默认是按行排列, 按列需要order='F'\n    \n    矩阵求逆 np.linalg.inv(x)\n    \n    矩阵乘积 np.matmul(a, b)\n        \n        stepX = 10\n        stepY = 10\n        pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4])\n        projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order='F')\n        viewMatrix = np.asarray(view_matrix).reshape([4,4],order='F')\n        tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix))\n        for h in range(0, self.img_height, stepY):\n            for w in range(0, self.img_width, stepX):\n                x = (2*w - self.img_width)/self.img_width\n                y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position\n                z = 2*depth_np_arr[h,w] - 1\n                pixPos = np.asarray([x, y, z, 1])\n                position = np.matmul(tran_pix_world, pixPos)\n\n                pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          \n\n## 引用\n\n1. [在virtualenv中设置：`pip install -e .` vs `python setup.py install`](https://www.jb51.cc/python/241778.html)\n2. [如何将自己的Python程序打包--setuptools详解](https://www.jianshu.com/p/9a54e9f3e059)\n3. [Python Numpy 如何交换两行和两列](https://blog.csdn.net/qq_35356840/article/details/88557912)\n4. [Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix](http://ksimek.github.io/2012/08/22/extrinsic/)\n5. [OpenGL投影矩阵(Projection Matrix)构造方法](https://zhuanlan.zhihu.com/p/73034007)\n6. [OpenGL 101: Matrices - projection, view, model](https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/)\n","source":"_posts/python基础.md","raw":"---\ntitle: python基础\ndate: 2020-05-22 16:52:49\ncategories:\n- program\ntags:\n- python\n---\n\n很多简单模块容易忘,在此记录一下\n\n## 基础操作\n\n1. 查看帮助文档\n\n        import os\n        # 主要有3中类型 ,也可以针对具体函数\n        dir(os)\n        help(os) \n        os.__doc__\n2. 查看变量内存地址\n\n        # 需要注意有时候变量的复制是浅拷贝,地址相同的\n        # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了\n        print(id(object))\n3. 查看当前路径\n\n        import os\n        os.getcwd()\n4. copy模块\n\n\t- 注意python具有即时复制的功能\n\n\t\t\ta = 1\n\t\t\tb = a\n\t\t\tprint(id(a), id(b))\n\t\t\tb = 2\n\t\t\tprint(id(a), id(b))\n\n\t- 有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()\n\n5. python3中@\n\t矩阵乘法\n\n\t\tOp\tPrecedence/associativity\tMethods\n\t\t@\tSame as *\t\t\t\t\t__matmul__, __rmatmul__\n\t\t@=\tn/a\t\t\t\t\t\t\t__imatmul__\n\n6. numpy数组交换行列\n    \n        a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]])\n        a[:,[1,0,2]]\n     \t\t\n\n## 安装模块\n\n1. 常用安装命令\n\n        # 安装 conda环境可以使用conda install xxx\n        pip install package_name\n        pip install package_name==package_version\n        # 更新\n        pip install -U package_name\n        # 显示模块的信息\n        pip show package_name\n        # 查看对应包简单信息\n        pip list |grep package_name\n        # 卸载建议这种方式,不会会有残留文件(针对pip install -e .)\n        pip uninstall package_name  \n\n2. pip install -e . VS python setup.py install\n\n        Editable   pip                    setup.py\n        yes        pip install -e .       python setup.py develop    \n        no         pip install .          python setup.py install   \n\n- 可编辑模式安装(develop,可以在当前文件基础上修改)\n  \n  这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;\n  在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;\n  查看sys.path会发现里面多了一个项目根目录的路径\n  \n        pip install -e /path/to/your/setup.py  # 项目根目录                  \n- install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改\n\n## pybullet 结合 ROS\n将pybullet中获取的图像通过变换获得对应的点云图\n{% pdf OPGL_pointcloud.pdf %}\n1. Image  numpy array to sensor_msgs/Image\n        \n        from cv_bridge import CvBridge\n        import numpy as np\n        from sensor_msgs.msg import Image\n        \n        # 确保能都找到正确的opencv2的位置\n        import sys\n        sys.path.remove('/opt/ros/kinetic/lib/python2.7/dist-packages')\n        import cv2\n        \n        rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame()\n        bridge = CvBridge()\n        image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype('uint8'))  # default bgra8\n        \n2. Pointcloud numpy to sensor_msgs/PointCloud2     \n    \n        import ros_numpy\n        import numpy as np\n        from sensor_msgs.msg import PointCloud2, PointField\n        \n        number = point_cloud.shape[0] * point_cloud.shape[1]\n        point_cloud_arr = point_cloud.reshape([number, 3])\n        data = np.zeros(number, dtype=[\n            ('x', np.float32),\n            ('y', np.float32),\n            ('z', np.float32)\n        ])\n        data['x'] = point_cloud_arr[:, 0]\n        data['y'] = point_cloud_arr[:, 1]\n        data['z'] = point_cloud_arr[:, 2]\n\n        cloud_msg = ros_numpy.msgify(PointCloud2, data)\n        cloud_msg.header.frame_id = \"map\"\n        \n3. pointcloud from image deepth\n    reshape 默认是按行排列, 按列需要order='F'\n    \n    矩阵求逆 np.linalg.inv(x)\n    \n    矩阵乘积 np.matmul(a, b)\n        \n        stepX = 10\n        stepY = 10\n        pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4])\n        projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order='F')\n        viewMatrix = np.asarray(view_matrix).reshape([4,4],order='F')\n        tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix))\n        for h in range(0, self.img_height, stepY):\n            for w in range(0, self.img_width, stepX):\n                x = (2*w - self.img_width)/self.img_width\n                y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position\n                z = 2*depth_np_arr[h,w] - 1\n                pixPos = np.asarray([x, y, z, 1])\n                position = np.matmul(tran_pix_world, pixPos)\n\n                pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          \n\n## 引用\n\n1. [在virtualenv中设置：`pip install -e .` vs `python setup.py install`](https://www.jb51.cc/python/241778.html)\n2. [如何将自己的Python程序打包--setuptools详解](https://www.jianshu.com/p/9a54e9f3e059)\n3. [Python Numpy 如何交换两行和两列](https://blog.csdn.net/qq_35356840/article/details/88557912)\n4. [Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix](http://ksimek.github.io/2012/08/22/extrinsic/)\n5. [OpenGL投影矩阵(Projection Matrix)构造方法](https://zhuanlan.zhihu.com/p/73034007)\n6. [OpenGL 101: Matrices - projection, view, model](https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/)\n","slug":"python基础","published":1,"updated":"2020-10-27T06:45:29.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chv0028mxka61w33g3w","content":"<p>很多简单模块容易忘,在此记录一下</p>\n<h2 id=\"基础操作\"><a href=\"#基础操作\" class=\"headerlink\" title=\"基础操作\"></a>基础操作</h2><ol>\n<li><p>查看帮助文档</p>\n<pre><code> import os\n # 主要有3中类型 ,也可以针对具体函数\n dir(os)\n help(os) \n os.__doc__\n</code></pre></li>\n<li><p>查看变量内存地址</p>\n<pre><code> # 需要注意有时候变量的复制是浅拷贝,地址相同的\n # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了\n print(id(object))\n</code></pre></li>\n<li><p>查看当前路径</p>\n<pre><code> import os\n os.getcwd()\n</code></pre></li>\n<li><p>copy模块</p>\n<ul>\n<li><p>注意python具有即时复制的功能</p>\n<pre><code>  a = 1\n  b = a\n  print(id(a), id(b))\n  b = 2\n  print(id(a), id(b))\n</code></pre></li>\n<li><p>有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()</p>\n</li>\n</ul>\n</li>\n<li><p>python3中@<br> 矩阵乘法</p>\n<pre><code> Op    Precedence/associativity    Methods\n @    Same as *                    __matmul__, __rmatmul__\n @=    n/a                            __imatmul__\n</code></pre></li>\n<li><p>numpy数组交换行列</p>\n<pre><code> a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]])\n a[:,[1,0,2]]\n</code></pre></li>\n</ol>\n<h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><ol>\n<li><p>常用安装命令</p>\n<pre><code> # 安装 conda环境可以使用conda install xxx\n pip install package_name\n pip install package_name==package_version\n # 更新\n pip install -U package_name\n # 显示模块的信息\n pip show package_name\n # 查看对应包简单信息\n pip list |grep package_name\n # 卸载建议这种方式,不会会有残留文件(针对pip install -e .)\n pip uninstall package_name  \n</code></pre></li>\n<li><p>pip install -e . VS python setup.py install</p>\n<pre><code> Editable   pip                    setup.py\n yes        pip install -e .       python setup.py develop    \n no         pip install .          python setup.py install   \n</code></pre></li>\n</ol>\n<ul>\n<li><p>可编辑模式安装(develop,可以在当前文件基础上修改)</p>\n<p>这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;<br>在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;<br>查看sys.path会发现里面多了一个项目根目录的路径</p>\n<pre><code>  pip install -e /path/to/your/setup.py  # 项目根目录                  \n</code></pre></li>\n<li>install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改</li>\n</ul>\n<h2 id=\"pybullet-结合-ROS\"><a href=\"#pybullet-结合-ROS\" class=\"headerlink\" title=\"pybullet 结合 ROS\"></a>pybullet 结合 ROS</h2><p>将pybullet中获取的图像通过变换获得对应的点云图<br>\n\n\t<div class=\"row\">\n    <embed src=\"OPGL_pointcloud.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n</p>\n<ol>\n<li><p>Image  numpy array to sensor_msgs/Image</p>\n<pre><code> from cv_bridge import CvBridge\n import numpy as np\n from sensor_msgs.msg import Image\n\n # 确保能都找到正确的opencv2的位置\n import sys\n sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;)\n import cv2\n\n rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame()\n bridge = CvBridge()\n image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype(&#39;uint8&#39;))  # default bgra8\n</code></pre></li>\n<li><p>Pointcloud numpy to sensor_msgs/PointCloud2     </p>\n<pre><code> import ros_numpy\n import numpy as np\n from sensor_msgs.msg import PointCloud2, PointField\n\n number = point_cloud.shape[0] * point_cloud.shape[1]\n point_cloud_arr = point_cloud.reshape([number, 3])\n data = np.zeros(number, dtype=[\n     (&#39;x&#39;, np.float32),\n     (&#39;y&#39;, np.float32),\n     (&#39;z&#39;, np.float32)\n ])\n data[&#39;x&#39;] = point_cloud_arr[:, 0]\n data[&#39;y&#39;] = point_cloud_arr[:, 1]\n data[&#39;z&#39;] = point_cloud_arr[:, 2]\n\n cloud_msg = ros_numpy.msgify(PointCloud2, data)\n cloud_msg.header.frame_id = &quot;map&quot;\n</code></pre></li>\n<li><p>pointcloud from image deepth<br> reshape 默认是按行排列, 按列需要order=’F’</p>\n<p> 矩阵求逆 np.linalg.inv(x)</p>\n<p> 矩阵乘积 np.matmul(a, b)</p>\n<pre><code> stepX = 10\n stepY = 10\n pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4])\n projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order=&#39;F&#39;)\n viewMatrix = np.asarray(view_matrix).reshape([4,4],order=&#39;F&#39;)\n tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix))\n for h in range(0, self.img_height, stepY):\n     for w in range(0, self.img_width, stepX):\n         x = (2*w - self.img_width)/self.img_width\n         y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position\n         z = 2*depth_np_arr[h,w] - 1\n         pixPos = np.asarray([x, y, z, 1])\n         position = np.matmul(tran_pix_world, pixPos)\n\n         pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          \n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://www.jb51.cc/python/241778.html\" target=\"_blank\" rel=\"noopener\">在virtualenv中设置：<code>pip install -e .</code> vs <code>python setup.py install</code></a></li>\n<li><a href=\"https://www.jianshu.com/p/9a54e9f3e059\" target=\"_blank\" rel=\"noopener\">如何将自己的Python程序打包—setuptools详解</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35356840/article/details/88557912\" target=\"_blank\" rel=\"noopener\">Python Numpy 如何交换两行和两列</a></li>\n<li><a href=\"http://ksimek.github.io/2012/08/22/extrinsic/\" target=\"_blank\" rel=\"noopener\">Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/73034007\" target=\"_blank\" rel=\"noopener\">OpenGL投影矩阵(Projection Matrix)构造方法</a></li>\n<li><a href=\"https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/\" target=\"_blank\" rel=\"noopener\">OpenGL 101: Matrices - projection, view, model</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>很多简单模块容易忘,在此记录一下</p>\n<h2 id=\"基础操作\"><a href=\"#基础操作\" class=\"headerlink\" title=\"基础操作\"></a>基础操作</h2><ol>\n<li><p>查看帮助文档</p>\n<pre><code> import os\n # 主要有3中类型 ,也可以针对具体函数\n dir(os)\n help(os) \n os.__doc__\n</code></pre></li>\n<li><p>查看变量内存地址</p>\n<pre><code> # 需要注意有时候变量的复制是浅拷贝,地址相同的\n # 使用pybullet获取机械臂位置就是这样,机械臂运动之后地址才变了\n print(id(object))\n</code></pre></li>\n<li><p>查看当前路径</p>\n<pre><code> import os\n os.getcwd()\n</code></pre></li>\n<li><p>copy模块</p>\n<ul>\n<li><p>注意python具有即时复制的功能</p>\n<pre><code>  a = 1\n  b = a\n  print(id(a), id(b))\n  b = 2\n  print(id(a), id(b))\n</code></pre></li>\n<li><p>有些模块如numpy没有特别设置不会深拷贝,通常配合copy.deepcopy()</p>\n</li>\n</ul>\n</li>\n<li><p>python3中@<br> 矩阵乘法</p>\n<pre><code> Op    Precedence/associativity    Methods\n @    Same as *                    __matmul__, __rmatmul__\n @=    n/a                            __imatmul__\n</code></pre></li>\n<li><p>numpy数组交换行列</p>\n<pre><code> a = np.array([[1,2,3],[2,3,4],[1,6,5], [9,3,4]])\n a[:,[1,0,2]]\n</code></pre></li>\n</ol>\n<h2 id=\"安装模块\"><a href=\"#安装模块\" class=\"headerlink\" title=\"安装模块\"></a>安装模块</h2><ol>\n<li><p>常用安装命令</p>\n<pre><code> # 安装 conda环境可以使用conda install xxx\n pip install package_name\n pip install package_name==package_version\n # 更新\n pip install -U package_name\n # 显示模块的信息\n pip show package_name\n # 查看对应包简单信息\n pip list |grep package_name\n # 卸载建议这种方式,不会会有残留文件(针对pip install -e .)\n pip uninstall package_name  \n</code></pre></li>\n<li><p>pip install -e . VS python setup.py install</p>\n<pre><code> Editable   pip                    setup.py\n yes        pip install -e .       python setup.py develop    \n no         pip install .          python setup.py install   \n</code></pre></li>\n</ol>\n<ul>\n<li><p>可编辑模式安装(develop,可以在当前文件基础上修改)</p>\n<p>这种方式会在site-packages下创建一个文件指向项目目录,并不会复制对应代码;<br>在项目根目录(setup.py所在)会生成egg-info 文件夹包含这个包的主要信息;<br>查看sys.path会发现里面多了一个项目根目录的路径</p>\n<pre><code>  pip install -e /path/to/your/setup.py  # 项目根目录                  \n</code></pre></li>\n<li>install 这种方式会在site-packages生成egg文件,里面包含对应的函数和模块,无法修改</li>\n</ul>\n<h2 id=\"pybullet-结合-ROS\"><a href=\"#pybullet-结合-ROS\" class=\"headerlink\" title=\"pybullet 结合 ROS\"></a>pybullet 结合 ROS</h2><p>将pybullet中获取的图像通过变换获得对应的点云图<br>\n\n\t<div class=\"row\">\n    <embed src=\"OPGL_pointcloud.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n</p>\n<ol>\n<li><p>Image  numpy array to sensor_msgs/Image</p>\n<pre><code> from cv_bridge import CvBridge\n import numpy as np\n from sensor_msgs.msg import Image\n\n # 确保能都找到正确的opencv2的位置\n import sys\n sys.path.remove(&#39;/opt/ros/kinetic/lib/python2.7/dist-packages&#39;)\n import cv2\n\n rgb_np_arr, depth_np_arr, seg_mask_np_arr, point_cloud = self.camera.get_camera_frame()\n bridge = CvBridge()\n image_message = bridge.cv2_to_imgmsg(rgb_np_arr[:, :, [2, 1, 0, 3]].astype(&#39;uint8&#39;))  # default bgra8\n</code></pre></li>\n<li><p>Pointcloud numpy to sensor_msgs/PointCloud2     </p>\n<pre><code> import ros_numpy\n import numpy as np\n from sensor_msgs.msg import PointCloud2, PointField\n\n number = point_cloud.shape[0] * point_cloud.shape[1]\n point_cloud_arr = point_cloud.reshape([number, 3])\n data = np.zeros(number, dtype=[\n     (&#39;x&#39;, np.float32),\n     (&#39;y&#39;, np.float32),\n     (&#39;z&#39;, np.float32)\n ])\n data[&#39;x&#39;] = point_cloud_arr[:, 0]\n data[&#39;y&#39;] = point_cloud_arr[:, 1]\n data[&#39;z&#39;] = point_cloud_arr[:, 2]\n\n cloud_msg = ros_numpy.msgify(PointCloud2, data)\n cloud_msg.header.frame_id = &quot;map&quot;\n</code></pre></li>\n<li><p>pointcloud from image deepth<br> reshape 默认是按行排列, 按列需要order=’F’</p>\n<p> 矩阵求逆 np.linalg.inv(x)</p>\n<p> 矩阵乘积 np.matmul(a, b)</p>\n<pre><code> stepX = 10\n stepY = 10\n pointCloud = np.empty([np.int(self.img_height/stepY), np.int(self.img_width/stepX), 4])\n projectionMatrix = np.asarray(self.projection_matrix).reshape([4,4],order=&#39;F&#39;)\n viewMatrix = np.asarray(view_matrix).reshape([4,4],order=&#39;F&#39;)\n tran_pix_world = np.linalg.inv(np.matmul(projectionMatrix, viewMatrix))\n for h in range(0, self.img_height, stepY):\n     for w in range(0, self.img_width, stepX):\n         x = (2*w - self.img_width)/self.img_width\n         y = -(2*h - self.img_height)/self.img_height  # be careful！ deepth and its corresponding position\n         z = 2*depth_np_arr[h,w] - 1\n         pixPos = np.asarray([x, y, z, 1])\n         position = np.matmul(tran_pix_world, pixPos)\n\n         pointCloud[np.int(h/stepY),np.int(w/stepX),:] = position / position[3]          \n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://www.jb51.cc/python/241778.html\" target=\"_blank\" rel=\"noopener\">在virtualenv中设置：<code>pip install -e .</code> vs <code>python setup.py install</code></a></li>\n<li><a href=\"https://www.jianshu.com/p/9a54e9f3e059\" target=\"_blank\" rel=\"noopener\">如何将自己的Python程序打包—setuptools详解</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35356840/article/details/88557912\" target=\"_blank\" rel=\"noopener\">Python Numpy 如何交换两行和两列</a></li>\n<li><a href=\"http://ksimek.github.io/2012/08/22/extrinsic/\" target=\"_blank\" rel=\"noopener\">Dissecting the Camera Matrix, Part 2: The Extrinsic Matrix</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/73034007\" target=\"_blank\" rel=\"noopener\">OpenGL投影矩阵(Projection Matrix)构造方法</a></li>\n<li><a href=\"https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/\" target=\"_blank\" rel=\"noopener\">OpenGL 101: Matrices - projection, view, model</a></li>\n</ol>\n"},{"title":"matlab 绘图","date":"2019-10-24T01:52:50.000Z","_content":"# 常用绘图命令\n## 命令查看\n查看所有画图相关命令\n\n    help graph2d\n    help graph3d\n## 图形窗口\n    figure(n)    % 打开窗口n\n    subplot(m,n,p)   % m行n列窗口第p个\n## 坐标轴\n- axis([xmin xmax ymin ymax])\n\n- axis equal 使x,y轴的单位长度相同\n\n- axis square 出图为正方形\n\n- axis off 清除坐标刻度\n\n- semilogx,semilogy 绘制以x/y轴为对数坐标，以10为底，y/x轴为线性坐标的半对数坐标图形\n\n- loglog 绘制全对数坐标图，即x,y轴全取对数   \n## 文字标示\n- text(x,y,‘字符串’) 在图形的指定坐标（x,y)处表示’字符串’中的内容\n- gtext('说明文字’）利用鼠标在图形的某一位置标示说明文字。执行完绘图命令后再执行gtext('说明文字‘）命令\n- title('字符串’）图形标题\n- xlabel('字符串‘),ylabel(‘字符串’),zlabel('字符串’)，设置x,y,z轴的坐标轴名称。如需输入特殊文字，用\\开头\n- legend(‘字符串1’,‘字符串1’,‘字符串1’……）对图形上多条线按照绘图顺序进行说明 \n## 栅格\n- grid 给图形加栅格\n- grid on 给坐标系加栅格\n- grid off 删除当前坐标系的栅格\n- grid minor  细化栅格\n## 图形覆盖/保持\n- hold on 当前图形保持，且下条图形仍然绘制在该张图形上\n- hold off 新图覆盖旧图 \n## 视角方向\n\n- view(az,el)                   给三维空间图形设置观察点的方位角az与仰角el\n\n- view([az,el])                 同上\n\n- view([x,y,z])                 将点(x,y,z)设置为视点\n\n- view(2)                       设置默认的二维形式视点，其中az = 0,el = 90,即从z轴上方观看\n\n- **view(3)**                       设置默认的三维形式视点，其中az = -37.5, ell = 30\n\n- view(T)                       根据转换矩阵T设置视点，其中T为4*4阶的矩阵，如同用命令viewmtx生成的透视转换矩阵一样（注意：在2014版本中，这条命令好像没了）\n\n- [az,el]=view                  返回当前的方位角az与仰角el\n\n- T = view                      返回当前的4*4阶的转换矩阵T\n\n## 例子\n\n例子1\n   \n    clc;clear;close all;    % 清除变量　输入　关闭绘图\n    scrsz = get(groot,'ScreenSize');\n    figure('Position',[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]);  % 图像框为屏幕左上角1/4　像素\n    limAxes = [-1.2 0.8 -1.1 0.9];\n    xx = round(linspace(1,64,nbSamples));   % round 4舍5入\n    clrmap = colormap('jet');\n    clrmap = min(clrmap(xx,:),.95);\n    colPegs = [[.9,.5,.9];[.5,.9,.5]];\n\n    subplot(1,2,1); hold on; box on; title('Demonstrations');\n    \n    plot(b(1), b(2),'.','markersize',30,'color',colPegs(1,:)-[.05,.05,.05]);\n    plot(Data(1,:), Data(2,:),'-','linewidth',1.5,'color',clrmap(n,:));\n    \n    axis(limAxes); axis square; \n    set(gca,'xtick',[],'ytick',[]);  % 清除坐标轴刻度 axis off\n\n例子2\n\n    f = figure;\n    hold on;box on;\n    P1 = plot(x, y,'linewidth',1.2);\n    P2 = plot(mean_force, 0,'o','linewidth',1.2);   % 均值\n    P3 = plot(threhold, 0,'o','linewidth',1.2);   % 均值\n    \n    axis([0 28 0 0.14]);\n    \n    width = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mm\n    xlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)','Fontname', 'Times New Roman');\n    % xlabel('Torque $M_x$ (Nm)','interpreter','latex','FontSize',8); % Latex格式的label\n    ylabel('\\fontname{宋体}概率','Fontname', 'Times New Roman');\n    set(gcf,'unit','points','PaperUnits','points','PaperPosition',[0,0,width,width/5*4],...\n        'position',[500 300 width width/5*4],'color','w','PaperSize',[width, width/5*4]);\n    \n    set(gca, 'Fontsize', 8);   % 坐标轴句柄，设置坐标轴刻度数字样式\n    L1 = legend([P1 P2 P3],'高斯分布','均值','阈值');\n    set(L1,'Location','northeast','Orientation','vertical',...\n        'Fontname', '宋体','FontSize',8,'TextColor','black');% legend 格式\n    % set(gca, 'XTick',0:4:20);  % 设置X轴刻度\n    \n    print('S:\\PbD\\graph\\Force_threhold_change','-djpeg','-r600');\n    \nlegend 放置两排 需要鼠标拖动调整位置\n\n    \tL1 = legend([P1 P2 P3],'X\\fontname{宋体}变扰动力','Y\\fontname{宋体}变扰动力','Z\\fontname{宋体}变扰动力');\n    \n    \tset(L1,'Location','north','Orientation','horizontal',...\n    \t    'Fontname', 'Times New Roman','FontSize',8,'TextColor','black');% legend 格式\n    \t\n    \tah=axes('position',get(gca,'position'),'visible','off');\n    \tL2=legend(ah,[P4 P5 P6],'X\\fontname{宋体}恒扰动力','Y\\fontname{宋体}恒扰动力',...\n    \t\t'Z\\fontname{宋体}恒扰动力','orientation','horizontal','location','north');\n    \t\n    \tset(L2,    'Fontname', 'Times New Roman','FontSize',8,'TextColor','black');% legend 格式\n    \t\n    \tset(L1,'box','off');\t\t% 根据需要可以去除legend边框\n    \tset(L2,'box','off');\n去除图框白边\t\n\n    \tset(gca,'looseInset',[0 0 0 0]);   \t% 缩放坐标轴 去除图框白边 三维图不是很好用\n设置label等对象位置两种方式\n\n    \tx = xlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)');\n    \tset(x,'Position',[0.1,0.1])\n    \t\n    \txlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)','Position',[0.1,0.1]);\n\n\n# 参考\n1. [Matlab常用绘图命令](https://blog.csdn.net/weixin_38452468/article/details/90171772)\n2. [MATLAB中的视角处理](https://blog.csdn.net/seamanj/article/details/35790359)     ","source":"_posts/matlab-绘图.md","raw":"---\ntitle: matlab 绘图\ndate: 2019-10-24 09:52:50\ncategories:\n- software\ntags:\n- matlab\n\n---\n# 常用绘图命令\n## 命令查看\n查看所有画图相关命令\n\n    help graph2d\n    help graph3d\n## 图形窗口\n    figure(n)    % 打开窗口n\n    subplot(m,n,p)   % m行n列窗口第p个\n## 坐标轴\n- axis([xmin xmax ymin ymax])\n\n- axis equal 使x,y轴的单位长度相同\n\n- axis square 出图为正方形\n\n- axis off 清除坐标刻度\n\n- semilogx,semilogy 绘制以x/y轴为对数坐标，以10为底，y/x轴为线性坐标的半对数坐标图形\n\n- loglog 绘制全对数坐标图，即x,y轴全取对数   \n## 文字标示\n- text(x,y,‘字符串’) 在图形的指定坐标（x,y)处表示’字符串’中的内容\n- gtext('说明文字’）利用鼠标在图形的某一位置标示说明文字。执行完绘图命令后再执行gtext('说明文字‘）命令\n- title('字符串’）图形标题\n- xlabel('字符串‘),ylabel(‘字符串’),zlabel('字符串’)，设置x,y,z轴的坐标轴名称。如需输入特殊文字，用\\开头\n- legend(‘字符串1’,‘字符串1’,‘字符串1’……）对图形上多条线按照绘图顺序进行说明 \n## 栅格\n- grid 给图形加栅格\n- grid on 给坐标系加栅格\n- grid off 删除当前坐标系的栅格\n- grid minor  细化栅格\n## 图形覆盖/保持\n- hold on 当前图形保持，且下条图形仍然绘制在该张图形上\n- hold off 新图覆盖旧图 \n## 视角方向\n\n- view(az,el)                   给三维空间图形设置观察点的方位角az与仰角el\n\n- view([az,el])                 同上\n\n- view([x,y,z])                 将点(x,y,z)设置为视点\n\n- view(2)                       设置默认的二维形式视点，其中az = 0,el = 90,即从z轴上方观看\n\n- **view(3)**                       设置默认的三维形式视点，其中az = -37.5, ell = 30\n\n- view(T)                       根据转换矩阵T设置视点，其中T为4*4阶的矩阵，如同用命令viewmtx生成的透视转换矩阵一样（注意：在2014版本中，这条命令好像没了）\n\n- [az,el]=view                  返回当前的方位角az与仰角el\n\n- T = view                      返回当前的4*4阶的转换矩阵T\n\n## 例子\n\n例子1\n   \n    clc;clear;close all;    % 清除变量　输入　关闭绘图\n    scrsz = get(groot,'ScreenSize');\n    figure('Position',[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]);  % 图像框为屏幕左上角1/4　像素\n    limAxes = [-1.2 0.8 -1.1 0.9];\n    xx = round(linspace(1,64,nbSamples));   % round 4舍5入\n    clrmap = colormap('jet');\n    clrmap = min(clrmap(xx,:),.95);\n    colPegs = [[.9,.5,.9];[.5,.9,.5]];\n\n    subplot(1,2,1); hold on; box on; title('Demonstrations');\n    \n    plot(b(1), b(2),'.','markersize',30,'color',colPegs(1,:)-[.05,.05,.05]);\n    plot(Data(1,:), Data(2,:),'-','linewidth',1.5,'color',clrmap(n,:));\n    \n    axis(limAxes); axis square; \n    set(gca,'xtick',[],'ytick',[]);  % 清除坐标轴刻度 axis off\n\n例子2\n\n    f = figure;\n    hold on;box on;\n    P1 = plot(x, y,'linewidth',1.2);\n    P2 = plot(mean_force, 0,'o','linewidth',1.2);   % 均值\n    P3 = plot(threhold, 0,'o','linewidth',1.2);   % 均值\n    \n    axis([0 28 0 0.14]);\n    \n    width = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mm\n    xlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)','Fontname', 'Times New Roman');\n    % xlabel('Torque $M_x$ (Nm)','interpreter','latex','FontSize',8); % Latex格式的label\n    ylabel('\\fontname{宋体}概率','Fontname', 'Times New Roman');\n    set(gcf,'unit','points','PaperUnits','points','PaperPosition',[0,0,width,width/5*4],...\n        'position',[500 300 width width/5*4],'color','w','PaperSize',[width, width/5*4]);\n    \n    set(gca, 'Fontsize', 8);   % 坐标轴句柄，设置坐标轴刻度数字样式\n    L1 = legend([P1 P2 P3],'高斯分布','均值','阈值');\n    set(L1,'Location','northeast','Orientation','vertical',...\n        'Fontname', '宋体','FontSize',8,'TextColor','black');% legend 格式\n    % set(gca, 'XTick',0:4:20);  % 设置X轴刻度\n    \n    print('S:\\PbD\\graph\\Force_threhold_change','-djpeg','-r600');\n    \nlegend 放置两排 需要鼠标拖动调整位置\n\n    \tL1 = legend([P1 P2 P3],'X\\fontname{宋体}变扰动力','Y\\fontname{宋体}变扰动力','Z\\fontname{宋体}变扰动力');\n    \n    \tset(L1,'Location','north','Orientation','horizontal',...\n    \t    'Fontname', 'Times New Roman','FontSize',8,'TextColor','black');% legend 格式\n    \t\n    \tah=axes('position',get(gca,'position'),'visible','off');\n    \tL2=legend(ah,[P4 P5 P6],'X\\fontname{宋体}恒扰动力','Y\\fontname{宋体}恒扰动力',...\n    \t\t'Z\\fontname{宋体}恒扰动力','orientation','horizontal','location','north');\n    \t\n    \tset(L2,    'Fontname', 'Times New Roman','FontSize',8,'TextColor','black');% legend 格式\n    \t\n    \tset(L1,'box','off');\t\t% 根据需要可以去除legend边框\n    \tset(L2,'box','off');\n去除图框白边\t\n\n    \tset(gca,'looseInset',[0 0 0 0]);   \t% 缩放坐标轴 去除图框白边 三维图不是很好用\n设置label等对象位置两种方式\n\n    \tx = xlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)');\n    \tset(x,'Position',[0.1,0.1])\n    \t\n    \txlabel('\\fontname{宋体}力模长\\fontname{Times New Roman}(N)','Position',[0.1,0.1]);\n\n\n# 参考\n1. [Matlab常用绘图命令](https://blog.csdn.net/weixin_38452468/article/details/90171772)\n2. [MATLAB中的视角处理](https://blog.csdn.net/seamanj/article/details/35790359)     ","slug":"matlab-绘图","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chw002cmxka778ra8ds","content":"<h1 id=\"常用绘图命令\"><a href=\"#常用绘图命令\" class=\"headerlink\" title=\"常用绘图命令\"></a>常用绘图命令</h1><h2 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h2><p>查看所有画图相关命令</p>\n<pre><code>help graph2d\nhelp graph3d\n</code></pre><h2 id=\"图形窗口\"><a href=\"#图形窗口\" class=\"headerlink\" title=\"图形窗口\"></a>图形窗口</h2><pre><code>figure(n)    % 打开窗口n\nsubplot(m,n,p)   % m行n列窗口第p个\n</code></pre><h2 id=\"坐标轴\"><a href=\"#坐标轴\" class=\"headerlink\" title=\"坐标轴\"></a>坐标轴</h2><ul>\n<li><p>axis([xmin xmax ymin ymax])</p>\n</li>\n<li><p>axis equal 使x,y轴的单位长度相同</p>\n</li>\n<li><p>axis square 出图为正方形</p>\n</li>\n<li><p>axis off 清除坐标刻度</p>\n</li>\n<li><p>semilogx,semilogy 绘制以x/y轴为对数坐标，以10为底，y/x轴为线性坐标的半对数坐标图形</p>\n</li>\n<li><p>loglog 绘制全对数坐标图，即x,y轴全取对数   </p>\n<h2 id=\"文字标示\"><a href=\"#文字标示\" class=\"headerlink\" title=\"文字标示\"></a>文字标示</h2></li>\n<li>text(x,y,‘字符串’) 在图形的指定坐标（x,y)处表示’字符串’中的内容</li>\n<li>gtext(‘说明文字’）利用鼠标在图形的某一位置标示说明文字。执行完绘图命令后再执行gtext(‘说明文字‘）命令</li>\n<li>title(‘字符串’）图形标题</li>\n<li>xlabel(‘字符串‘),ylabel(‘字符串’),zlabel(‘字符串’)，设置x,y,z轴的坐标轴名称。如需输入特殊文字，用\\开头</li>\n<li>legend(‘字符串1’,‘字符串1’,‘字符串1’……）对图形上多条线按照绘图顺序进行说明 <h2 id=\"栅格\"><a href=\"#栅格\" class=\"headerlink\" title=\"栅格\"></a>栅格</h2></li>\n<li>grid 给图形加栅格</li>\n<li>grid on 给坐标系加栅格</li>\n<li>grid off 删除当前坐标系的栅格</li>\n<li>grid minor  细化栅格<h2 id=\"图形覆盖-保持\"><a href=\"#图形覆盖-保持\" class=\"headerlink\" title=\"图形覆盖/保持\"></a>图形覆盖/保持</h2></li>\n<li>hold on 当前图形保持，且下条图形仍然绘制在该张图形上</li>\n<li><p>hold off 新图覆盖旧图 </p>\n<h2 id=\"视角方向\"><a href=\"#视角方向\" class=\"headerlink\" title=\"视角方向\"></a>视角方向</h2></li>\n<li><p>view(az,el)                   给三维空间图形设置观察点的方位角az与仰角el</p>\n</li>\n<li><p>view([az,el])                 同上</p>\n</li>\n<li><p>view([x,y,z])                 将点(x,y,z)设置为视点</p>\n</li>\n<li><p>view(2)                       设置默认的二维形式视点，其中az = 0,el = 90,即从z轴上方观看</p>\n</li>\n<li><p><strong>view(3)</strong>                       设置默认的三维形式视点，其中az = -37.5, ell = 30</p>\n</li>\n<li><p>view(T)                       根据转换矩阵T设置视点，其中T为4*4阶的矩阵，如同用命令viewmtx生成的透视转换矩阵一样（注意：在2014版本中，这条命令好像没了）</p>\n</li>\n<li><p>[az,el]=view                  返回当前的方位角az与仰角el</p>\n</li>\n<li><p>T = view                      返回当前的4*4阶的转换矩阵T</p>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>例子1</p>\n<pre><code>clc;clear;close all;    % 清除变量　输入　关闭绘图\nscrsz = get(groot,&#39;ScreenSize&#39;);\nfigure(&#39;Position&#39;,[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]);  % 图像框为屏幕左上角1/4　像素\nlimAxes = [-1.2 0.8 -1.1 0.9];\nxx = round(linspace(1,64,nbSamples));   % round 4舍5入\nclrmap = colormap(&#39;jet&#39;);\nclrmap = min(clrmap(xx,:),.95);\ncolPegs = [[.9,.5,.9];[.5,.9,.5]];\n\nsubplot(1,2,1); hold on; box on; title(&#39;Demonstrations&#39;);\n\nplot(b(1), b(2),&#39;.&#39;,&#39;markersize&#39;,30,&#39;color&#39;,colPegs(1,:)-[.05,.05,.05]);\nplot(Data(1,:), Data(2,:),&#39;-&#39;,&#39;linewidth&#39;,1.5,&#39;color&#39;,clrmap(n,:));\n\naxis(limAxes); axis square; \nset(gca,&#39;xtick&#39;,[],&#39;ytick&#39;,[]);  % 清除坐标轴刻度 axis off\n</code></pre><p>例子2</p>\n<pre><code>f = figure;\nhold on;box on;\nP1 = plot(x, y,&#39;linewidth&#39;,1.2);\nP2 = plot(mean_force, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值\nP3 = plot(threhold, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值\n\naxis([0 28 0 0.14]);\n\nwidth = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mm\nxlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);\n% xlabel(&#39;Torque $M_x$ (Nm)&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,8); % Latex格式的label\nylabel(&#39;\\fontname{宋体}概率&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);\nset(gcf,&#39;unit&#39;,&#39;points&#39;,&#39;PaperUnits&#39;,&#39;points&#39;,&#39;PaperPosition&#39;,[0,0,width,width/5*4],...\n    &#39;position&#39;,[500 300 width width/5*4],&#39;color&#39;,&#39;w&#39;,&#39;PaperSize&#39;,[width, width/5*4]);\n\nset(gca, &#39;Fontsize&#39;, 8);   % 坐标轴句柄，设置坐标轴刻度数字样式\nL1 = legend([P1 P2 P3],&#39;高斯分布&#39;,&#39;均值&#39;,&#39;阈值&#39;);\nset(L1,&#39;Location&#39;,&#39;northeast&#39;,&#39;Orientation&#39;,&#39;vertical&#39;,...\n    &#39;Fontname&#39;, &#39;宋体&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n% set(gca, &#39;XTick&#39;,0:4:20);  % 设置X轴刻度\n\nprint(&#39;S:\\PbD\\graph\\Force_threhold_change&#39;,&#39;-djpeg&#39;,&#39;-r600&#39;);\n</code></pre><p>legend 放置两排 需要鼠标拖动调整位置</p>\n<pre><code>    L1 = legend([P1 P2 P3],&#39;X\\fontname{宋体}变扰动力&#39;,&#39;Y\\fontname{宋体}变扰动力&#39;,&#39;Z\\fontname{宋体}变扰动力&#39;);\n\n    set(L1,&#39;Location&#39;,&#39;north&#39;,&#39;Orientation&#39;,&#39;horizontal&#39;,...\n        &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n\n    ah=axes(&#39;position&#39;,get(gca,&#39;position&#39;),&#39;visible&#39;,&#39;off&#39;);\n    L2=legend(ah,[P4 P5 P6],&#39;X\\fontname{宋体}恒扰动力&#39;,&#39;Y\\fontname{宋体}恒扰动力&#39;,...\n        &#39;Z\\fontname{宋体}恒扰动力&#39;,&#39;orientation&#39;,&#39;horizontal&#39;,&#39;location&#39;,&#39;north&#39;);\n\n    set(L2,    &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n\n    set(L1,&#39;box&#39;,&#39;off&#39;);        % 根据需要可以去除legend边框\n    set(L2,&#39;box&#39;,&#39;off&#39;);\n</code></pre><p>去除图框白边    </p>\n<pre><code>    set(gca,&#39;looseInset&#39;,[0 0 0 0]);       % 缩放坐标轴 去除图框白边 三维图不是很好用\n</code></pre><p>设置label等对象位置两种方式</p>\n<pre><code>    x = xlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;);\n    set(x,&#39;Position&#39;,[0.1,0.1])\n\n    xlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;,&#39;Position&#39;,[0.1,0.1]);\n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/weixin_38452468/article/details/90171772\" target=\"_blank\" rel=\"noopener\">Matlab常用绘图命令</a></li>\n<li><a href=\"https://blog.csdn.net/seamanj/article/details/35790359\" target=\"_blank\" rel=\"noopener\">MATLAB中的视角处理</a>     </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用绘图命令\"><a href=\"#常用绘图命令\" class=\"headerlink\" title=\"常用绘图命令\"></a>常用绘图命令</h1><h2 id=\"命令查看\"><a href=\"#命令查看\" class=\"headerlink\" title=\"命令查看\"></a>命令查看</h2><p>查看所有画图相关命令</p>\n<pre><code>help graph2d\nhelp graph3d\n</code></pre><h2 id=\"图形窗口\"><a href=\"#图形窗口\" class=\"headerlink\" title=\"图形窗口\"></a>图形窗口</h2><pre><code>figure(n)    % 打开窗口n\nsubplot(m,n,p)   % m行n列窗口第p个\n</code></pre><h2 id=\"坐标轴\"><a href=\"#坐标轴\" class=\"headerlink\" title=\"坐标轴\"></a>坐标轴</h2><ul>\n<li><p>axis([xmin xmax ymin ymax])</p>\n</li>\n<li><p>axis equal 使x,y轴的单位长度相同</p>\n</li>\n<li><p>axis square 出图为正方形</p>\n</li>\n<li><p>axis off 清除坐标刻度</p>\n</li>\n<li><p>semilogx,semilogy 绘制以x/y轴为对数坐标，以10为底，y/x轴为线性坐标的半对数坐标图形</p>\n</li>\n<li><p>loglog 绘制全对数坐标图，即x,y轴全取对数   </p>\n<h2 id=\"文字标示\"><a href=\"#文字标示\" class=\"headerlink\" title=\"文字标示\"></a>文字标示</h2></li>\n<li>text(x,y,‘字符串’) 在图形的指定坐标（x,y)处表示’字符串’中的内容</li>\n<li>gtext(‘说明文字’）利用鼠标在图形的某一位置标示说明文字。执行完绘图命令后再执行gtext(‘说明文字‘）命令</li>\n<li>title(‘字符串’）图形标题</li>\n<li>xlabel(‘字符串‘),ylabel(‘字符串’),zlabel(‘字符串’)，设置x,y,z轴的坐标轴名称。如需输入特殊文字，用\\开头</li>\n<li>legend(‘字符串1’,‘字符串1’,‘字符串1’……）对图形上多条线按照绘图顺序进行说明 <h2 id=\"栅格\"><a href=\"#栅格\" class=\"headerlink\" title=\"栅格\"></a>栅格</h2></li>\n<li>grid 给图形加栅格</li>\n<li>grid on 给坐标系加栅格</li>\n<li>grid off 删除当前坐标系的栅格</li>\n<li>grid minor  细化栅格<h2 id=\"图形覆盖-保持\"><a href=\"#图形覆盖-保持\" class=\"headerlink\" title=\"图形覆盖/保持\"></a>图形覆盖/保持</h2></li>\n<li>hold on 当前图形保持，且下条图形仍然绘制在该张图形上</li>\n<li><p>hold off 新图覆盖旧图 </p>\n<h2 id=\"视角方向\"><a href=\"#视角方向\" class=\"headerlink\" title=\"视角方向\"></a>视角方向</h2></li>\n<li><p>view(az,el)                   给三维空间图形设置观察点的方位角az与仰角el</p>\n</li>\n<li><p>view([az,el])                 同上</p>\n</li>\n<li><p>view([x,y,z])                 将点(x,y,z)设置为视点</p>\n</li>\n<li><p>view(2)                       设置默认的二维形式视点，其中az = 0,el = 90,即从z轴上方观看</p>\n</li>\n<li><p><strong>view(3)</strong>                       设置默认的三维形式视点，其中az = -37.5, ell = 30</p>\n</li>\n<li><p>view(T)                       根据转换矩阵T设置视点，其中T为4*4阶的矩阵，如同用命令viewmtx生成的透视转换矩阵一样（注意：在2014版本中，这条命令好像没了）</p>\n</li>\n<li><p>[az,el]=view                  返回当前的方位角az与仰角el</p>\n</li>\n<li><p>T = view                      返回当前的4*4阶的转换矩阵T</p>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>例子1</p>\n<pre><code>clc;clear;close all;    % 清除变量　输入　关闭绘图\nscrsz = get(groot,&#39;ScreenSize&#39;);\nfigure(&#39;Position&#39;,[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]);  % 图像框为屏幕左上角1/4　像素\nlimAxes = [-1.2 0.8 -1.1 0.9];\nxx = round(linspace(1,64,nbSamples));   % round 4舍5入\nclrmap = colormap(&#39;jet&#39;);\nclrmap = min(clrmap(xx,:),.95);\ncolPegs = [[.9,.5,.9];[.5,.9,.5]];\n\nsubplot(1,2,1); hold on; box on; title(&#39;Demonstrations&#39;);\n\nplot(b(1), b(2),&#39;.&#39;,&#39;markersize&#39;,30,&#39;color&#39;,colPegs(1,:)-[.05,.05,.05]);\nplot(Data(1,:), Data(2,:),&#39;-&#39;,&#39;linewidth&#39;,1.5,&#39;color&#39;,clrmap(n,:));\n\naxis(limAxes); axis square; \nset(gca,&#39;xtick&#39;,[],&#39;ytick&#39;,[]);  % 清除坐标轴刻度 axis off\n</code></pre><p>例子2</p>\n<pre><code>f = figure;\nhold on;box on;\nP1 = plot(x, y,&#39;linewidth&#39;,1.2);\nP2 = plot(mean_force, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值\nP3 = plot(threhold, 0,&#39;o&#39;,&#39;linewidth&#39;,1.2);   % 均值\n\naxis([0 28 0 0.14]);\n\nwidth = 240;   % 240pt  US letter 双栏 1pt = 1/72inch   1 inch = 25.4mm\nxlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);\n% xlabel(&#39;Torque $M_x$ (Nm)&#39;,&#39;interpreter&#39;,&#39;latex&#39;,&#39;FontSize&#39;,8); % Latex格式的label\nylabel(&#39;\\fontname{宋体}概率&#39;,&#39;Fontname&#39;, &#39;Times New Roman&#39;);\nset(gcf,&#39;unit&#39;,&#39;points&#39;,&#39;PaperUnits&#39;,&#39;points&#39;,&#39;PaperPosition&#39;,[0,0,width,width/5*4],...\n    &#39;position&#39;,[500 300 width width/5*4],&#39;color&#39;,&#39;w&#39;,&#39;PaperSize&#39;,[width, width/5*4]);\n\nset(gca, &#39;Fontsize&#39;, 8);   % 坐标轴句柄，设置坐标轴刻度数字样式\nL1 = legend([P1 P2 P3],&#39;高斯分布&#39;,&#39;均值&#39;,&#39;阈值&#39;);\nset(L1,&#39;Location&#39;,&#39;northeast&#39;,&#39;Orientation&#39;,&#39;vertical&#39;,...\n    &#39;Fontname&#39;, &#39;宋体&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n% set(gca, &#39;XTick&#39;,0:4:20);  % 设置X轴刻度\n\nprint(&#39;S:\\PbD\\graph\\Force_threhold_change&#39;,&#39;-djpeg&#39;,&#39;-r600&#39;);\n</code></pre><p>legend 放置两排 需要鼠标拖动调整位置</p>\n<pre><code>    L1 = legend([P1 P2 P3],&#39;X\\fontname{宋体}变扰动力&#39;,&#39;Y\\fontname{宋体}变扰动力&#39;,&#39;Z\\fontname{宋体}变扰动力&#39;);\n\n    set(L1,&#39;Location&#39;,&#39;north&#39;,&#39;Orientation&#39;,&#39;horizontal&#39;,...\n        &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n\n    ah=axes(&#39;position&#39;,get(gca,&#39;position&#39;),&#39;visible&#39;,&#39;off&#39;);\n    L2=legend(ah,[P4 P5 P6],&#39;X\\fontname{宋体}恒扰动力&#39;,&#39;Y\\fontname{宋体}恒扰动力&#39;,...\n        &#39;Z\\fontname{宋体}恒扰动力&#39;,&#39;orientation&#39;,&#39;horizontal&#39;,&#39;location&#39;,&#39;north&#39;);\n\n    set(L2,    &#39;Fontname&#39;, &#39;Times New Roman&#39;,&#39;FontSize&#39;,8,&#39;TextColor&#39;,&#39;black&#39;);% legend 格式\n\n    set(L1,&#39;box&#39;,&#39;off&#39;);        % 根据需要可以去除legend边框\n    set(L2,&#39;box&#39;,&#39;off&#39;);\n</code></pre><p>去除图框白边    </p>\n<pre><code>    set(gca,&#39;looseInset&#39;,[0 0 0 0]);       % 缩放坐标轴 去除图框白边 三维图不是很好用\n</code></pre><p>设置label等对象位置两种方式</p>\n<pre><code>    x = xlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;);\n    set(x,&#39;Position&#39;,[0.1,0.1])\n\n    xlabel(&#39;\\fontname{宋体}力模长\\fontname{Times New Roman}(N)&#39;,&#39;Position&#39;,[0.1,0.1]);\n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/weixin_38452468/article/details/90171772\" target=\"_blank\" rel=\"noopener\">Matlab常用绘图命令</a></li>\n<li><a href=\"https://blog.csdn.net/seamanj/article/details/35790359\" target=\"_blank\" rel=\"noopener\">MATLAB中的视角处理</a>     </li>\n</ol>\n"},{"title":"ubuntu系统配置","date":"2019-07-14T12:17:42.000Z","_content":"最近在自己的笔记本安装了ubuntu16，记录一下环境配置,持续更新\n\n# 软件安装\n\n- chorme\n- RedShift(如果不行的话考虑 护眼软件flux安装：先安装crossover，然后安装的windos下的flux)\n- terminator\n- ssr\n- 输入法 sogo for Linux\n- wine\n- GoldenDict\n- shutter\n- smplayer\n- draw.io\n- kazam (录屏软件)\n\n## RedShift\n首选挺好用的护眼工具 如果无法使用就用flux\n\n    sudo apt-get install redshift  \n      \n    gedit .config/redshift.conf     # 对应修改相应配置文件\n    redshift -t 5700:3600       # 设置白天和黑夜对应温度   默认5000-4100\n    tldr redshift               # 忘记命令可以使用tldr 或者cheat\n\n## terminator\n终端分屏工具\n\n1. 安装\n\n\t\tsudo apt-get install terminator\n\n2. 配置（没找到文件夹就创建一个）\n\n\t\tcd ~/.config/terminator/ && sudo gedit config\n3. 修改配置文件\n\n\t\t[global_config]\n\t\t  focus = system\n\t\t  suppress_multiple_term_dialog = True\n\t\t  title_transmit_bg_color = \"#d30102\"\n\t\t[keybindings]\n\t\t  close_term = <Primary><Alt>w\n\t\t[layouts]\n\t\t  [[default]]\n\t\t    [[[child1]]]\n\t\t      parent = window0\n\t\t      profile = default\n\t\t      type = Terminal\n\t\t    [[[window0]]]\n\t\t      parent = \"\"\n\t\t      type = Window\n\t\t[plugins]\n\t\t[profiles]\n\t\t  [[default]]\n\t\t    background_color = \"#2d2d2d\"\n\t\t    background_darkness = 0.85\n\t\t    background_image = None\n\t\t    copy_on_selection = True\n\t\t    cursor_color = \"#EEE9E9\"\n\t\t    font = Ubuntu Mono 13\n\t\t    foreground_color = \"#eee9e9\"\n\t\t    palette = \"#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec\"\n\t\t    show_titlebar = False\n\t\t    use_system_font = False\n\n## ssr\n\n1. 使用：双击[electron-ssr](https://github.com/qingshuisiyuan/electron-ssr-backup)\n2. 账号:\n\t1. 免费账号：[github](https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7)\n\t2. 免费账号+服务器订阅：[github](https://github.com/the0demiurge/ShadowSocksShare)\n\n感谢他们的付出\n\n## wine\n可以安装windows程序,这里我用于安装mathtype,写博客用公式就不同切换会windows了\n\n    sudo apt-get install wine\nwine安装软件3中方式\n    \n    wine xxx.exe\n    ./xxx.exe\n    直接双击(可能需要选择wine打开)\n    \n    winecfg （wine的设置~）\n    wine  taskmgr （任务管理器）\n    wine  uninstaller （卸载软件）\n    wine  regedit （注册表）\n    wine  notepad （记事本）\n    wineboot （ 重启wine）\n    \n## GoldenDict\n一款强大的翻译软件\n1. 安装\n\n        sudo apt install goldendict\n2. 配置\n    - 网络词典 Edit -> Dictionaries -> Sources -> Websites -> Add\n    \n    常用的有:必应、有道、百度,选择一个就可以了，这里选择bing,(youdao的网页不能播放发音)\n    \n        必应：https://cn.bing.com/dict/search?q=%GDWORD%\n        有道：https://dict.youdao.com/search?q=%GDWORD%&ue=utf8\n        百度：https://fanyi.baidu.com/#en/zh/%25GDWORD%25      \n    - 本地词典 Edit -> Dictionaries -> Sources -> Files -> Add\n    \n    《牛津英汉双解美化版》 下载网址[http://download.huzheng.org/zh_CN/](http://download.huzheng.org/zh_CN/)\n    - 屏幕取词 Edit -> Preferences -> Scan Popup\n    - 词形匹配(如果主要使用网络词典，可以不用配置此项) Edit->Dictionaries->Morphology  \n    \n        下载英文构词法规则库,[地址](https://sourceforge.net/projects/goldendict/files/better%20morphologies/1.0/)\n3. 使用　\n    选中单词 Ctrl+C+C　(可以设置)        \n          \n## shutter\n截图软件\n\n        sudo apt install shutter  \n## smplayer\n视频播放软件 可倍速\n    \n    sudo apt-get install smplayer  #可选安装smplayer-skins smplayer-themes\n    # [ ] 分别减速加速\t\n           \n## draw.io\n- 支持谷歌浏览器app(推荐)\n- 支持在线绘图,类似visio\n- [桌面版本](https://github.com/jgraph/drawio-desktop/releases)\n \n\n\n导出jpg可设置更改缩放为1000%就可以有较好清晰度\n\n[draw.io](https://www.draw.io/)        \n\n# 资源\n\n1. [软件资源](https://pan.baidu.com/s/1B4lO9MiZVEqehld8ffoeFg),提取码：87q8\n\n# 开机启动软件设置\n1. 启动软件\n2. ps auxww |grep qq    # 找到软件对应的命令\n3. 在startup里面添加对应命令\n\n# 引用\n1. terminator[配置](https://blog.csdn.net/ipatient/article/details/51547658)\n2. [Ubuntu桌面启动后自动执行指定的命令或程序的三种方法](https://blog.csdn.net/davidhzq/article/details/102725116)\n3. [Ubuntu 18.04 LTS版本 GoldenDict安装与配置](https://www.cnblogs.com/creasing/p/11333728.html)\n4. [Ubuntu,Linux下goldendict词典安装及配置](https://blog.csdn.net/www_helloworld_com/article/details/85019862)\n5. [强烈推荐：Goldendict 及其词典详述(5 月 26 日更新)](https://forum.ubuntu.org.cn/viewtopic.php?f=95&t=265588)\n6. [Linux 下非常好用的字典 GoldenDict](http://einverne.github.io/post/2018/08/goldendict.html)\n7. [wine 安装（ubuntu中安装windows下软件）](https://blog.csdn.net/qq_34638161/article/details/81271977)\n","source":"_posts/ubuntu系统配置.md","raw":"---\ntitle: ubuntu系统配置\ndate: 2019-07-14 20:17:42\ncategories:\n- Linux\ntags:\n- software\n- ubuntu\n\n---\n最近在自己的笔记本安装了ubuntu16，记录一下环境配置,持续更新\n\n# 软件安装\n\n- chorme\n- RedShift(如果不行的话考虑 护眼软件flux安装：先安装crossover，然后安装的windos下的flux)\n- terminator\n- ssr\n- 输入法 sogo for Linux\n- wine\n- GoldenDict\n- shutter\n- smplayer\n- draw.io\n- kazam (录屏软件)\n\n## RedShift\n首选挺好用的护眼工具 如果无法使用就用flux\n\n    sudo apt-get install redshift  \n      \n    gedit .config/redshift.conf     # 对应修改相应配置文件\n    redshift -t 5700:3600       # 设置白天和黑夜对应温度   默认5000-4100\n    tldr redshift               # 忘记命令可以使用tldr 或者cheat\n\n## terminator\n终端分屏工具\n\n1. 安装\n\n\t\tsudo apt-get install terminator\n\n2. 配置（没找到文件夹就创建一个）\n\n\t\tcd ~/.config/terminator/ && sudo gedit config\n3. 修改配置文件\n\n\t\t[global_config]\n\t\t  focus = system\n\t\t  suppress_multiple_term_dialog = True\n\t\t  title_transmit_bg_color = \"#d30102\"\n\t\t[keybindings]\n\t\t  close_term = <Primary><Alt>w\n\t\t[layouts]\n\t\t  [[default]]\n\t\t    [[[child1]]]\n\t\t      parent = window0\n\t\t      profile = default\n\t\t      type = Terminal\n\t\t    [[[window0]]]\n\t\t      parent = \"\"\n\t\t      type = Window\n\t\t[plugins]\n\t\t[profiles]\n\t\t  [[default]]\n\t\t    background_color = \"#2d2d2d\"\n\t\t    background_darkness = 0.85\n\t\t    background_image = None\n\t\t    copy_on_selection = True\n\t\t    cursor_color = \"#EEE9E9\"\n\t\t    font = Ubuntu Mono 13\n\t\t    foreground_color = \"#eee9e9\"\n\t\t    palette = \"#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec\"\n\t\t    show_titlebar = False\n\t\t    use_system_font = False\n\n## ssr\n\n1. 使用：双击[electron-ssr](https://github.com/qingshuisiyuan/electron-ssr-backup)\n2. 账号:\n\t1. 免费账号：[github](https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7)\n\t2. 免费账号+服务器订阅：[github](https://github.com/the0demiurge/ShadowSocksShare)\n\n感谢他们的付出\n\n## wine\n可以安装windows程序,这里我用于安装mathtype,写博客用公式就不同切换会windows了\n\n    sudo apt-get install wine\nwine安装软件3中方式\n    \n    wine xxx.exe\n    ./xxx.exe\n    直接双击(可能需要选择wine打开)\n    \n    winecfg （wine的设置~）\n    wine  taskmgr （任务管理器）\n    wine  uninstaller （卸载软件）\n    wine  regedit （注册表）\n    wine  notepad （记事本）\n    wineboot （ 重启wine）\n    \n## GoldenDict\n一款强大的翻译软件\n1. 安装\n\n        sudo apt install goldendict\n2. 配置\n    - 网络词典 Edit -> Dictionaries -> Sources -> Websites -> Add\n    \n    常用的有:必应、有道、百度,选择一个就可以了，这里选择bing,(youdao的网页不能播放发音)\n    \n        必应：https://cn.bing.com/dict/search?q=%GDWORD%\n        有道：https://dict.youdao.com/search?q=%GDWORD%&ue=utf8\n        百度：https://fanyi.baidu.com/#en/zh/%25GDWORD%25      \n    - 本地词典 Edit -> Dictionaries -> Sources -> Files -> Add\n    \n    《牛津英汉双解美化版》 下载网址[http://download.huzheng.org/zh_CN/](http://download.huzheng.org/zh_CN/)\n    - 屏幕取词 Edit -> Preferences -> Scan Popup\n    - 词形匹配(如果主要使用网络词典，可以不用配置此项) Edit->Dictionaries->Morphology  \n    \n        下载英文构词法规则库,[地址](https://sourceforge.net/projects/goldendict/files/better%20morphologies/1.0/)\n3. 使用　\n    选中单词 Ctrl+C+C　(可以设置)        \n          \n## shutter\n截图软件\n\n        sudo apt install shutter  \n## smplayer\n视频播放软件 可倍速\n    \n    sudo apt-get install smplayer  #可选安装smplayer-skins smplayer-themes\n    # [ ] 分别减速加速\t\n           \n## draw.io\n- 支持谷歌浏览器app(推荐)\n- 支持在线绘图,类似visio\n- [桌面版本](https://github.com/jgraph/drawio-desktop/releases)\n \n\n\n导出jpg可设置更改缩放为1000%就可以有较好清晰度\n\n[draw.io](https://www.draw.io/)        \n\n# 资源\n\n1. [软件资源](https://pan.baidu.com/s/1B4lO9MiZVEqehld8ffoeFg),提取码：87q8\n\n# 开机启动软件设置\n1. 启动软件\n2. ps auxww |grep qq    # 找到软件对应的命令\n3. 在startup里面添加对应命令\n\n# 引用\n1. terminator[配置](https://blog.csdn.net/ipatient/article/details/51547658)\n2. [Ubuntu桌面启动后自动执行指定的命令或程序的三种方法](https://blog.csdn.net/davidhzq/article/details/102725116)\n3. [Ubuntu 18.04 LTS版本 GoldenDict安装与配置](https://www.cnblogs.com/creasing/p/11333728.html)\n4. [Ubuntu,Linux下goldendict词典安装及配置](https://blog.csdn.net/www_helloworld_com/article/details/85019862)\n5. [强烈推荐：Goldendict 及其词典详述(5 月 26 日更新)](https://forum.ubuntu.org.cn/viewtopic.php?f=95&t=265588)\n6. [Linux 下非常好用的字典 GoldenDict](http://einverne.github.io/post/2018/08/goldendict.html)\n7. [wine 安装（ubuntu中安装windows下软件）](https://blog.csdn.net/qq_34638161/article/details/81271977)\n","slug":"ubuntu系统配置","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chx002fmxkawziznvsq","content":"<p>最近在自己的笔记本安装了ubuntu16，记录一下环境配置,持续更新</p>\n<h1 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h1><ul>\n<li>chorme</li>\n<li>RedShift(如果不行的话考虑 护眼软件flux安装：先安装crossover，然后安装的windos下的flux)</li>\n<li>terminator</li>\n<li>ssr</li>\n<li>输入法 sogo for Linux</li>\n<li>wine</li>\n<li>GoldenDict</li>\n<li>shutter</li>\n<li>smplayer</li>\n<li>draw.io</li>\n<li>kazam (录屏软件)</li>\n</ul>\n<h2 id=\"RedShift\"><a href=\"#RedShift\" class=\"headerlink\" title=\"RedShift\"></a>RedShift</h2><p>首选挺好用的护眼工具 如果无法使用就用flux</p>\n<pre><code>sudo apt-get install redshift  \n\ngedit .config/redshift.conf     # 对应修改相应配置文件\nredshift -t 5700:3600       # 设置白天和黑夜对应温度   默认5000-4100\ntldr redshift               # 忘记命令可以使用tldr 或者cheat\n</code></pre><h2 id=\"terminator\"><a href=\"#terminator\" class=\"headerlink\" title=\"terminator\"></a>terminator</h2><p>终端分屏工具</p>\n<ol>\n<li><p>安装</p>\n<pre><code> sudo apt-get install terminator\n</code></pre></li>\n<li><p>配置（没找到文件夹就创建一个）</p>\n<pre><code> cd ~/.config/terminator/ &amp;&amp; sudo gedit config\n</code></pre></li>\n<li><p>修改配置文件</p>\n<pre><code> [global_config]\n   focus = system\n   suppress_multiple_term_dialog = True\n   title_transmit_bg_color = &quot;#d30102&quot;\n [keybindings]\n   close_term = &lt;Primary&gt;&lt;Alt&gt;w\n [layouts]\n   [[default]]\n     [[[child1]]]\n       parent = window0\n       profile = default\n       type = Terminal\n     [[[window0]]]\n       parent = &quot;&quot;\n       type = Window\n [plugins]\n [profiles]\n   [[default]]\n     background_color = &quot;#2d2d2d&quot;\n     background_darkness = 0.85\n     background_image = None\n     copy_on_selection = True\n     cursor_color = &quot;#EEE9E9&quot;\n     font = Ubuntu Mono 13\n     foreground_color = &quot;#eee9e9&quot;\n     palette = &quot;#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec&quot;\n     show_titlebar = False\n     use_system_font = False\n</code></pre></li>\n</ol>\n<h2 id=\"ssr\"><a href=\"#ssr\" class=\"headerlink\" title=\"ssr\"></a>ssr</h2><ol>\n<li>使用：双击<a href=\"https://github.com/qingshuisiyuan/electron-ssr-backup\" target=\"_blank\" rel=\"noopener\">electron-ssr</a></li>\n<li>账号:<ol>\n<li>免费账号：<a href=\"https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>免费账号+服务器订阅：<a href=\"https://github.com/the0demiurge/ShadowSocksShare\" target=\"_blank\" rel=\"noopener\">github</a></li>\n</ol>\n</li>\n</ol>\n<p>感谢他们的付出</p>\n<h2 id=\"wine\"><a href=\"#wine\" class=\"headerlink\" title=\"wine\"></a>wine</h2><p>可以安装windows程序,这里我用于安装mathtype,写博客用公式就不同切换会windows了</p>\n<pre><code>sudo apt-get install wine\n</code></pre><p>wine安装软件3中方式</p>\n<pre><code>wine xxx.exe\n./xxx.exe\n直接双击(可能需要选择wine打开)\n\nwinecfg （wine的设置~）\nwine  taskmgr （任务管理器）\nwine  uninstaller （卸载软件）\nwine  regedit （注册表）\nwine  notepad （记事本）\nwineboot （ 重启wine）\n</code></pre><h2 id=\"GoldenDict\"><a href=\"#GoldenDict\" class=\"headerlink\" title=\"GoldenDict\"></a>GoldenDict</h2><p>一款强大的翻译软件</p>\n<ol>\n<li><p>安装</p>\n<pre><code> sudo apt install goldendict\n</code></pre></li>\n<li><p>配置</p>\n<ul>\n<li><p>网络词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Websites -&gt; Add</p>\n<p>常用的有:必应、有道、百度,选择一个就可以了，这里选择bing,(youdao的网页不能播放发音)</p>\n<p>  必应：<a href=\"https://cn.bing.com/dict/search?q=%GDWORD%\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/dict/search?q=%GDWORD%</a><br>  有道：<a href=\"https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8\" target=\"_blank\" rel=\"noopener\">https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</a><br>  百度：<a href=\"https://fanyi.baidu.com/#en/zh/%25GDWORD%25\" target=\"_blank\" rel=\"noopener\">https://fanyi.baidu.com/#en/zh/%25GDWORD%25</a>      </p>\n</li>\n<li><p>本地词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Files -&gt; Add</p>\n<p>《牛津英汉双解美化版》 下载网址<a href=\"http://download.huzheng.org/zh_CN/\" target=\"_blank\" rel=\"noopener\">http://download.huzheng.org/zh_CN/</a></p>\n</li>\n<li>屏幕取词 Edit -&gt; Preferences -&gt; Scan Popup</li>\n<li><p>词形匹配(如果主要使用网络词典，可以不用配置此项) Edit-&gt;Dictionaries-&gt;Morphology  </p>\n<p>  下载英文构词法规则库,<a href=\"https://sourceforge.net/projects/goldendict/files/better%20morphologies/1.0/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n</li>\n</ul>\n</li>\n<li>使用　<br> 选中单词 Ctrl+C+C　(可以设置)        </li>\n</ol>\n<h2 id=\"shutter\"><a href=\"#shutter\" class=\"headerlink\" title=\"shutter\"></a>shutter</h2><p>截图软件</p>\n<pre><code>    sudo apt install shutter  \n</code></pre><h2 id=\"smplayer\"><a href=\"#smplayer\" class=\"headerlink\" title=\"smplayer\"></a>smplayer</h2><p>视频播放软件 可倍速</p>\n<pre><code>sudo apt-get install smplayer  #可选安装smplayer-skins smplayer-themes\n# [ ] 分别减速加速    \n</code></pre><h2 id=\"draw-io\"><a href=\"#draw-io\" class=\"headerlink\" title=\"draw.io\"></a>draw.io</h2><ul>\n<li>支持谷歌浏览器app(推荐)</li>\n<li>支持在线绘图,类似visio</li>\n<li><a href=\"https://github.com/jgraph/drawio-desktop/releases\" target=\"_blank\" rel=\"noopener\">桌面版本</a></li>\n</ul>\n<p>导出jpg可设置更改缩放为1000%就可以有较好清晰度</p>\n<p><a href=\"https://www.draw.io/\" target=\"_blank\" rel=\"noopener\">draw.io</a>        </p>\n<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><ol>\n<li><a href=\"https://pan.baidu.com/s/1B4lO9MiZVEqehld8ffoeFg\" target=\"_blank\" rel=\"noopener\">软件资源</a>,提取码：87q8</li>\n</ol>\n<h1 id=\"开机启动软件设置\"><a href=\"#开机启动软件设置\" class=\"headerlink\" title=\"开机启动软件设置\"></a>开机启动软件设置</h1><ol>\n<li>启动软件</li>\n<li>ps auxww |grep qq    # 找到软件对应的命令</li>\n<li>在startup里面添加对应命令</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>terminator<a href=\"https://blog.csdn.net/ipatient/article/details/51547658\" target=\"_blank\" rel=\"noopener\">配置</a></li>\n<li><a href=\"https://blog.csdn.net/davidhzq/article/details/102725116\" target=\"_blank\" rel=\"noopener\">Ubuntu桌面启动后自动执行指定的命令或程序的三种方法</a></li>\n<li><a href=\"https://www.cnblogs.com/creasing/p/11333728.html\" target=\"_blank\" rel=\"noopener\">Ubuntu 18.04 LTS版本 GoldenDict安装与配置</a></li>\n<li><a href=\"https://blog.csdn.net/www_helloworld_com/article/details/85019862\" target=\"_blank\" rel=\"noopener\">Ubuntu,Linux下goldendict词典安装及配置</a></li>\n<li><a href=\"https://forum.ubuntu.org.cn/viewtopic.php?f=95&amp;t=265588\" target=\"_blank\" rel=\"noopener\">强烈推荐：Goldendict 及其词典详述(5 月 26 日更新)</a></li>\n<li><a href=\"http://einverne.github.io/post/2018/08/goldendict.html\" target=\"_blank\" rel=\"noopener\">Linux 下非常好用的字典 GoldenDict</a></li>\n<li><a href=\"https://blog.csdn.net/qq_34638161/article/details/81271977\" target=\"_blank\" rel=\"noopener\">wine 安装（ubuntu中安装windows下软件）</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在自己的笔记本安装了ubuntu16，记录一下环境配置,持续更新</p>\n<h1 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h1><ul>\n<li>chorme</li>\n<li>RedShift(如果不行的话考虑 护眼软件flux安装：先安装crossover，然后安装的windos下的flux)</li>\n<li>terminator</li>\n<li>ssr</li>\n<li>输入法 sogo for Linux</li>\n<li>wine</li>\n<li>GoldenDict</li>\n<li>shutter</li>\n<li>smplayer</li>\n<li>draw.io</li>\n<li>kazam (录屏软件)</li>\n</ul>\n<h2 id=\"RedShift\"><a href=\"#RedShift\" class=\"headerlink\" title=\"RedShift\"></a>RedShift</h2><p>首选挺好用的护眼工具 如果无法使用就用flux</p>\n<pre><code>sudo apt-get install redshift  \n\ngedit .config/redshift.conf     # 对应修改相应配置文件\nredshift -t 5700:3600       # 设置白天和黑夜对应温度   默认5000-4100\ntldr redshift               # 忘记命令可以使用tldr 或者cheat\n</code></pre><h2 id=\"terminator\"><a href=\"#terminator\" class=\"headerlink\" title=\"terminator\"></a>terminator</h2><p>终端分屏工具</p>\n<ol>\n<li><p>安装</p>\n<pre><code> sudo apt-get install terminator\n</code></pre></li>\n<li><p>配置（没找到文件夹就创建一个）</p>\n<pre><code> cd ~/.config/terminator/ &amp;&amp; sudo gedit config\n</code></pre></li>\n<li><p>修改配置文件</p>\n<pre><code> [global_config]\n   focus = system\n   suppress_multiple_term_dialog = True\n   title_transmit_bg_color = &quot;#d30102&quot;\n [keybindings]\n   close_term = &lt;Primary&gt;&lt;Alt&gt;w\n [layouts]\n   [[default]]\n     [[[child1]]]\n       parent = window0\n       profile = default\n       type = Terminal\n     [[[window0]]]\n       parent = &quot;&quot;\n       type = Window\n [plugins]\n [profiles]\n   [[default]]\n     background_color = &quot;#2d2d2d&quot;\n     background_darkness = 0.85\n     background_image = None\n     copy_on_selection = True\n     cursor_color = &quot;#EEE9E9&quot;\n     font = Ubuntu Mono 13\n     foreground_color = &quot;#eee9e9&quot;\n     palette = &quot;#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec&quot;\n     show_titlebar = False\n     use_system_font = False\n</code></pre></li>\n</ol>\n<h2 id=\"ssr\"><a href=\"#ssr\" class=\"headerlink\" title=\"ssr\"></a>ssr</h2><ol>\n<li>使用：双击<a href=\"https://github.com/qingshuisiyuan/electron-ssr-backup\" target=\"_blank\" rel=\"noopener\">electron-ssr</a></li>\n<li>账号:<ol>\n<li>免费账号：<a href=\"https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>免费账号+服务器订阅：<a href=\"https://github.com/the0demiurge/ShadowSocksShare\" target=\"_blank\" rel=\"noopener\">github</a></li>\n</ol>\n</li>\n</ol>\n<p>感谢他们的付出</p>\n<h2 id=\"wine\"><a href=\"#wine\" class=\"headerlink\" title=\"wine\"></a>wine</h2><p>可以安装windows程序,这里我用于安装mathtype,写博客用公式就不同切换会windows了</p>\n<pre><code>sudo apt-get install wine\n</code></pre><p>wine安装软件3中方式</p>\n<pre><code>wine xxx.exe\n./xxx.exe\n直接双击(可能需要选择wine打开)\n\nwinecfg （wine的设置~）\nwine  taskmgr （任务管理器）\nwine  uninstaller （卸载软件）\nwine  regedit （注册表）\nwine  notepad （记事本）\nwineboot （ 重启wine）\n</code></pre><h2 id=\"GoldenDict\"><a href=\"#GoldenDict\" class=\"headerlink\" title=\"GoldenDict\"></a>GoldenDict</h2><p>一款强大的翻译软件</p>\n<ol>\n<li><p>安装</p>\n<pre><code> sudo apt install goldendict\n</code></pre></li>\n<li><p>配置</p>\n<ul>\n<li><p>网络词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Websites -&gt; Add</p>\n<p>常用的有:必应、有道、百度,选择一个就可以了，这里选择bing,(youdao的网页不能播放发音)</p>\n<p>  必应：<a href=\"https://cn.bing.com/dict/search?q=%GDWORD%\" target=\"_blank\" rel=\"noopener\">https://cn.bing.com/dict/search?q=%GDWORD%</a><br>  有道：<a href=\"https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8\" target=\"_blank\" rel=\"noopener\">https://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</a><br>  百度：<a href=\"https://fanyi.baidu.com/#en/zh/%25GDWORD%25\" target=\"_blank\" rel=\"noopener\">https://fanyi.baidu.com/#en/zh/%25GDWORD%25</a>      </p>\n</li>\n<li><p>本地词典 Edit -&gt; Dictionaries -&gt; Sources -&gt; Files -&gt; Add</p>\n<p>《牛津英汉双解美化版》 下载网址<a href=\"http://download.huzheng.org/zh_CN/\" target=\"_blank\" rel=\"noopener\">http://download.huzheng.org/zh_CN/</a></p>\n</li>\n<li>屏幕取词 Edit -&gt; Preferences -&gt; Scan Popup</li>\n<li><p>词形匹配(如果主要使用网络词典，可以不用配置此项) Edit-&gt;Dictionaries-&gt;Morphology  </p>\n<p>  下载英文构词法规则库,<a href=\"https://sourceforge.net/projects/goldendict/files/better%20morphologies/1.0/\" target=\"_blank\" rel=\"noopener\">地址</a></p>\n</li>\n</ul>\n</li>\n<li>使用　<br> 选中单词 Ctrl+C+C　(可以设置)        </li>\n</ol>\n<h2 id=\"shutter\"><a href=\"#shutter\" class=\"headerlink\" title=\"shutter\"></a>shutter</h2><p>截图软件</p>\n<pre><code>    sudo apt install shutter  \n</code></pre><h2 id=\"smplayer\"><a href=\"#smplayer\" class=\"headerlink\" title=\"smplayer\"></a>smplayer</h2><p>视频播放软件 可倍速</p>\n<pre><code>sudo apt-get install smplayer  #可选安装smplayer-skins smplayer-themes\n# [ ] 分别减速加速    \n</code></pre><h2 id=\"draw-io\"><a href=\"#draw-io\" class=\"headerlink\" title=\"draw.io\"></a>draw.io</h2><ul>\n<li>支持谷歌浏览器app(推荐)</li>\n<li>支持在线绘图,类似visio</li>\n<li><a href=\"https://github.com/jgraph/drawio-desktop/releases\" target=\"_blank\" rel=\"noopener\">桌面版本</a></li>\n</ul>\n<p>导出jpg可设置更改缩放为1000%就可以有较好清晰度</p>\n<p><a href=\"https://www.draw.io/\" target=\"_blank\" rel=\"noopener\">draw.io</a>        </p>\n<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><ol>\n<li><a href=\"https://pan.baidu.com/s/1B4lO9MiZVEqehld8ffoeFg\" target=\"_blank\" rel=\"noopener\">软件资源</a>,提取码：87q8</li>\n</ol>\n<h1 id=\"开机启动软件设置\"><a href=\"#开机启动软件设置\" class=\"headerlink\" title=\"开机启动软件设置\"></a>开机启动软件设置</h1><ol>\n<li>启动软件</li>\n<li>ps auxww |grep qq    # 找到软件对应的命令</li>\n<li>在startup里面添加对应命令</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>terminator<a href=\"https://blog.csdn.net/ipatient/article/details/51547658\" target=\"_blank\" rel=\"noopener\">配置</a></li>\n<li><a href=\"https://blog.csdn.net/davidhzq/article/details/102725116\" target=\"_blank\" rel=\"noopener\">Ubuntu桌面启动后自动执行指定的命令或程序的三种方法</a></li>\n<li><a href=\"https://www.cnblogs.com/creasing/p/11333728.html\" target=\"_blank\" rel=\"noopener\">Ubuntu 18.04 LTS版本 GoldenDict安装与配置</a></li>\n<li><a href=\"https://blog.csdn.net/www_helloworld_com/article/details/85019862\" target=\"_blank\" rel=\"noopener\">Ubuntu,Linux下goldendict词典安装及配置</a></li>\n<li><a href=\"https://forum.ubuntu.org.cn/viewtopic.php?f=95&amp;t=265588\" target=\"_blank\" rel=\"noopener\">强烈推荐：Goldendict 及其词典详述(5 月 26 日更新)</a></li>\n<li><a href=\"http://einverne.github.io/post/2018/08/goldendict.html\" target=\"_blank\" rel=\"noopener\">Linux 下非常好用的字典 GoldenDict</a></li>\n<li><a href=\"https://blog.csdn.net/qq_34638161/article/details/81271977\" target=\"_blank\" rel=\"noopener\">wine 安装（ubuntu中安装windows下软件）</a></li>\n</ol>\n"},{"title":"ubuntu配置grub,指定默认内核","date":"2020-01-09T07:30:29.000Z","_content":"\n# Boot Loader: grub2\n\nBIOS 读完信息后,接下来就是会到第一个开机装置\n的 MBR 去读取 boot loader.这个 boot loader 可以具有选单功能、直接加载核心文件以及控制权\n移交的功能等，,系统必须要有 loader 才有办法加载该操作系统的核心就是了.\n\n由于MBR是整个硬盘的第一个 sector 内的一个区块,充其量整个大小也才 446 bytes 而已.即使\n是 GPT 也没有很大的扇区来储存 loader 的数据.所以分两个阶段\n\n- 执行 boot loader 主程序:在MBR或者boot sector,通常是最小主程序\n- 主程序加载配置文件: 配置文件在/boot下,读取了文件系统定义数据之后就能够认识文件系统并读取该文件系统的核心\n\n## 磁盘分区槽在grub2中的代号\n/boot/grub/grub.cfg  里面有set root='hd1,gpt5'  指/boot目录挂载的区域\n\n第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分区槽为『(hd0,1)』\n\n- 第一颗(MBR):     (hd0) (hd0,msdos1) (hd0,msdos2) (hd0,msdos3)....\n- 第二颗(GPT):     (hd1) (hd1,gpt1) (hd1,gpt2) (hd1,gpt3)....\n- 第三颗 (hd2):    (hd2,1) (hd2,2) (hd2,3)....\n\n## 配置文件\n修改/etc/default/grub,然后使用updata-grub更新/boot/grub/grub.cfg\n1. 数字\n    \n        GRUB_DEFAULT=\"1> 0\"     #表示第二个选单子菜单的第一个  只使用\"0\" 表示第一个选单\n2. ID\n        \n        GRUB_DEFAULT=\"Advanced options for Ubuntu>Ubuntu, with Linux 4.15.0-74-generic\"\n    \n    可通过一下命令查看目前系统选单\n        \n        awk -F\\' '/menuentry |submenu / {print $1 $2}' /boot/grub/grub.cfg  \n3. saved   \n        \n         GRUB_DEFAULT=saved     \n    代表使用 grub2-set-default 来设定哪一个 menuentry 为默认值的意思。通常预设为 0 \n\n## 遇到的问题\n1. 调用了update-grub之后/boot/grub/grub.cfg并没有改变,查看文件内部发现grub.cfg是需要使用grub-mkconfig\n\n        sudo grub-mkconfig -o /boot/grub/grub.cfg   # 可以先备份一下配置文件\n        \n# 引用\n1. [Setup GRUB to always boot the real-time kernel](https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/real_time.md)\n2. 鸟哥的Linux私房菜-基础学习篇(第四版)         \n        \n             ","source":"_posts/ubuntu配置grub-指定默认内核.md","raw":"---\ntitle: 'ubuntu配置grub,指定默认内核'\ndate: 2020-01-09 15:30:29\ncategories:\n- Linux\ntags:\n- grub\n---\n\n# Boot Loader: grub2\n\nBIOS 读完信息后,接下来就是会到第一个开机装置\n的 MBR 去读取 boot loader.这个 boot loader 可以具有选单功能、直接加载核心文件以及控制权\n移交的功能等，,系统必须要有 loader 才有办法加载该操作系统的核心就是了.\n\n由于MBR是整个硬盘的第一个 sector 内的一个区块,充其量整个大小也才 446 bytes 而已.即使\n是 GPT 也没有很大的扇区来储存 loader 的数据.所以分两个阶段\n\n- 执行 boot loader 主程序:在MBR或者boot sector,通常是最小主程序\n- 主程序加载配置文件: 配置文件在/boot下,读取了文件系统定义数据之后就能够认识文件系统并读取该文件系统的核心\n\n## 磁盘分区槽在grub2中的代号\n/boot/grub/grub.cfg  里面有set root='hd1,gpt5'  指/boot目录挂载的区域\n\n第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分区槽为『(hd0,1)』\n\n- 第一颗(MBR):     (hd0) (hd0,msdos1) (hd0,msdos2) (hd0,msdos3)....\n- 第二颗(GPT):     (hd1) (hd1,gpt1) (hd1,gpt2) (hd1,gpt3)....\n- 第三颗 (hd2):    (hd2,1) (hd2,2) (hd2,3)....\n\n## 配置文件\n修改/etc/default/grub,然后使用updata-grub更新/boot/grub/grub.cfg\n1. 数字\n    \n        GRUB_DEFAULT=\"1> 0\"     #表示第二个选单子菜单的第一个  只使用\"0\" 表示第一个选单\n2. ID\n        \n        GRUB_DEFAULT=\"Advanced options for Ubuntu>Ubuntu, with Linux 4.15.0-74-generic\"\n    \n    可通过一下命令查看目前系统选单\n        \n        awk -F\\' '/menuentry |submenu / {print $1 $2}' /boot/grub/grub.cfg  \n3. saved   \n        \n         GRUB_DEFAULT=saved     \n    代表使用 grub2-set-default 来设定哪一个 menuentry 为默认值的意思。通常预设为 0 \n\n## 遇到的问题\n1. 调用了update-grub之后/boot/grub/grub.cfg并没有改变,查看文件内部发现grub.cfg是需要使用grub-mkconfig\n\n        sudo grub-mkconfig -o /boot/grub/grub.cfg   # 可以先备份一下配置文件\n        \n# 引用\n1. [Setup GRUB to always boot the real-time kernel](https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/real_time.md)\n2. 鸟哥的Linux私房菜-基础学习篇(第四版)         \n        \n             ","slug":"ubuntu配置grub-指定默认内核","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chx002imxkapwsvsge2","content":"<h1 id=\"Boot-Loader-grub2\"><a href=\"#Boot-Loader-grub2\" class=\"headerlink\" title=\"Boot Loader: grub2\"></a>Boot Loader: grub2</h1><p>BIOS 读完信息后,接下来就是会到第一个开机装置<br>的 MBR 去读取 boot loader.这个 boot loader 可以具有选单功能、直接加载核心文件以及控制权<br>移交的功能等，,系统必须要有 loader 才有办法加载该操作系统的核心就是了.</p>\n<p>由于MBR是整个硬盘的第一个 sector 内的一个区块,充其量整个大小也才 446 bytes 而已.即使<br>是 GPT 也没有很大的扇区来储存 loader 的数据.所以分两个阶段</p>\n<ul>\n<li>执行 boot loader 主程序:在MBR或者boot sector,通常是最小主程序</li>\n<li>主程序加载配置文件: 配置文件在/boot下,读取了文件系统定义数据之后就能够认识文件系统并读取该文件系统的核心</li>\n</ul>\n<h2 id=\"磁盘分区槽在grub2中的代号\"><a href=\"#磁盘分区槽在grub2中的代号\" class=\"headerlink\" title=\"磁盘分区槽在grub2中的代号\"></a>磁盘分区槽在grub2中的代号</h2><p>/boot/grub/grub.cfg  里面有set root=’hd1,gpt5’  指/boot目录挂载的区域</p>\n<p>第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分区槽为『(hd0,1)』</p>\n<ul>\n<li>第一颗(MBR):     (hd0) (hd0,msdos1) (hd0,msdos2) (hd0,msdos3)….</li>\n<li>第二颗(GPT):     (hd1) (hd1,gpt1) (hd1,gpt2) (hd1,gpt3)….</li>\n<li>第三颗 (hd2):    (hd2,1) (hd2,2) (hd2,3)….</li>\n</ul>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>修改/etc/default/grub,然后使用updata-grub更新/boot/grub/grub.cfg</p>\n<ol>\n<li><p>数字</p>\n<pre><code> GRUB_DEFAULT=&quot;1&gt; 0&quot;     #表示第二个选单子菜单的第一个  只使用&quot;0&quot; 表示第一个选单\n</code></pre></li>\n<li><p>ID</p>\n<pre><code> GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.15.0-74-generic&quot;\n</code></pre><p> 可通过一下命令查看目前系统选单</p>\n<pre><code> awk -F\\&#39; &#39;/menuentry |submenu / {print $1 $2}&#39; /boot/grub/grub.cfg  \n</code></pre></li>\n<li><p>saved   </p>\n<pre><code>  GRUB_DEFAULT=saved     \n</code></pre><p> 代表使用 grub2-set-default 来设定哪一个 menuentry 为默认值的意思。通常预设为 0 </p>\n</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li><p>调用了update-grub之后/boot/grub/grub.cfg并没有改变,查看文件内部发现grub.cfg是需要使用grub-mkconfig</p>\n<pre><code> sudo grub-mkconfig -o /boot/grub/grub.cfg   # 可以先备份一下配置文件\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/real_time.md\" target=\"_blank\" rel=\"noopener\">Setup GRUB to always boot the real-time kernel</a></li>\n<li>鸟哥的Linux私房菜-基础学习篇(第四版)         </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Boot-Loader-grub2\"><a href=\"#Boot-Loader-grub2\" class=\"headerlink\" title=\"Boot Loader: grub2\"></a>Boot Loader: grub2</h1><p>BIOS 读完信息后,接下来就是会到第一个开机装置<br>的 MBR 去读取 boot loader.这个 boot loader 可以具有选单功能、直接加载核心文件以及控制权<br>移交的功能等，,系统必须要有 loader 才有办法加载该操作系统的核心就是了.</p>\n<p>由于MBR是整个硬盘的第一个 sector 内的一个区块,充其量整个大小也才 446 bytes 而已.即使<br>是 GPT 也没有很大的扇区来储存 loader 的数据.所以分两个阶段</p>\n<ul>\n<li>执行 boot loader 主程序:在MBR或者boot sector,通常是最小主程序</li>\n<li>主程序加载配置文件: 配置文件在/boot下,读取了文件系统定义数据之后就能够认识文件系统并读取该文件系统的核心</li>\n</ul>\n<h2 id=\"磁盘分区槽在grub2中的代号\"><a href=\"#磁盘分区槽在grub2中的代号\" class=\"headerlink\" title=\"磁盘分区槽在grub2中的代号\"></a>磁盘分区槽在grub2中的代号</h2><p>/boot/grub/grub.cfg  里面有set root=’hd1,gpt5’  指/boot目录挂载的区域</p>\n<p>第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分区槽为『(hd0,1)』</p>\n<ul>\n<li>第一颗(MBR):     (hd0) (hd0,msdos1) (hd0,msdos2) (hd0,msdos3)….</li>\n<li>第二颗(GPT):     (hd1) (hd1,gpt1) (hd1,gpt2) (hd1,gpt3)….</li>\n<li>第三颗 (hd2):    (hd2,1) (hd2,2) (hd2,3)….</li>\n</ul>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>修改/etc/default/grub,然后使用updata-grub更新/boot/grub/grub.cfg</p>\n<ol>\n<li><p>数字</p>\n<pre><code> GRUB_DEFAULT=&quot;1&gt; 0&quot;     #表示第二个选单子菜单的第一个  只使用&quot;0&quot; 表示第一个选单\n</code></pre></li>\n<li><p>ID</p>\n<pre><code> GRUB_DEFAULT=&quot;Advanced options for Ubuntu&gt;Ubuntu, with Linux 4.15.0-74-generic&quot;\n</code></pre><p> 可通过一下命令查看目前系统选单</p>\n<pre><code> awk -F\\&#39; &#39;/menuentry |submenu / {print $1 $2}&#39; /boot/grub/grub.cfg  \n</code></pre></li>\n<li><p>saved   </p>\n<pre><code>  GRUB_DEFAULT=saved     \n</code></pre><p> 代表使用 grub2-set-default 来设定哪一个 menuentry 为默认值的意思。通常预设为 0 </p>\n</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li><p>调用了update-grub之后/boot/grub/grub.cfg并没有改变,查看文件内部发现grub.cfg是需要使用grub-mkconfig</p>\n<pre><code> sudo grub-mkconfig -o /boot/grub/grub.cfg   # 可以先备份一下配置文件\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://github.com/UniversalRobots/Universal_Robots_ROS_Driver/blob/master/ur_robot_driver/doc/real_time.md\" target=\"_blank\" rel=\"noopener\">Setup GRUB to always boot the real-time kernel</a></li>\n<li>鸟哥的Linux私房菜-基础学习篇(第四版)         </li>\n</ol>\n"},{"title":"ubuntu下wps缺少字体","date":"2019-12-22T03:34:17.000Z","_content":"\n# 安装字体\n\n1. 下载字体[https://github.com/yangbenbo/wps-font-symbols/archive/master.zip](https://github.com/yangbenbo/wps-font-symbols/archive/master.zip)\n2. 解压并复制到字体文件夹\n    \n    unzip wps-font-symbols-master.zip\n    sudo cp -r wps-font-symbols-master /usr//share/fonts/\n    \n# 参考\n\n1. [Linux Wps 缺少字体](https://blog.csdn.net/u014241313/article/details/91070843)    \n\n","source":"_posts/ubuntu下wps缺少字体.md","raw":"---\ntitle: ubuntu下wps缺少字体\ndate: 2019-12-22 11:34:17\ncategories:\n- Linux\ntags:\n- wps\n---\n\n# 安装字体\n\n1. 下载字体[https://github.com/yangbenbo/wps-font-symbols/archive/master.zip](https://github.com/yangbenbo/wps-font-symbols/archive/master.zip)\n2. 解压并复制到字体文件夹\n    \n    unzip wps-font-symbols-master.zip\n    sudo cp -r wps-font-symbols-master /usr//share/fonts/\n    \n# 参考\n\n1. [Linux Wps 缺少字体](https://blog.csdn.net/u014241313/article/details/91070843)    \n\n","slug":"ubuntu下wps缺少字体","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chy002lmxka5721t0nb","content":"<h1 id=\"安装字体\"><a href=\"#安装字体\" class=\"headerlink\" title=\"安装字体\"></a>安装字体</h1><ol>\n<li>下载字体<a href=\"https://github.com/yangbenbo/wps-font-symbols/archive/master.zip\" target=\"_blank\" rel=\"noopener\">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></li>\n<li><p>解压并复制到字体文件夹</p>\n<p> unzip wps-font-symbols-master.zip<br> sudo cp -r wps-font-symbols-master /usr//share/fonts/</p>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/u014241313/article/details/91070843\" target=\"_blank\" rel=\"noopener\">Linux Wps 缺少字体</a>    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装字体\"><a href=\"#安装字体\" class=\"headerlink\" title=\"安装字体\"></a>安装字体</h1><ol>\n<li>下载字体<a href=\"https://github.com/yangbenbo/wps-font-symbols/archive/master.zip\" target=\"_blank\" rel=\"noopener\">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></li>\n<li><p>解压并复制到字体文件夹</p>\n<p> unzip wps-font-symbols-master.zip<br> sudo cp -r wps-font-symbols-master /usr//share/fonts/</p>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/u014241313/article/details/91070843\" target=\"_blank\" rel=\"noopener\">Linux Wps 缺少字体</a>    </li>\n</ol>\n"},{"title":"vim常用命令","date":"2019-09-30T06:59:28.000Z","_content":"\n# 常用命令\n\n![模式切换](Vim.png)\n## 插入命令\n\ni 光标前输入 \n\nI 行首输入 \n\na 光标后输入\n\nA 行尾输入\n\no 当前行下新开一行 \n\nO 当前行上新开一行\n## 定位命令\n:set nu   显示行号\n\n:set nonu   为取消行号\n\nw       光标移动到下一个单词  5w 5个单词\n\nb       光标移动到上一个单词\n\ngg       跳到文本首行\n\nG       最后一行\n\nnG      到第n行\n\n:n      到第n行\n\n$       移动到行尾\n\n0       移动到行首   ^\n\n\n## 删除命令\n\nx 删除光标所在处字符\n\nnx  删除光标所在处后n个字符\n\ndd  删除光标所在行,ndd删除n行\n\ndG  删除光标所在行到文件末尾内容\n\nD   删除光标所在处到行尾内容\n\n:n1,n2d 删除指定范围的行\n\n## 复制和剪切\n\nyy  复制当前行\n\nnyy 复制当前行以下n行\n\ndd  剪切当前行\n\nndd 剪切当前行以下n行\n\np、P 粘贴在当前光标所在行下或行上\n\n## 替换和取消\n\nr   取代光标所在处字符\n\nR   从光标所在处开始替换字符,按Esc结束\n\nu   取消上一步操作\n\n## 搜索和搜索替换\n\n/string             搜索指定字符串搜索时忽略大小写 :set ic\n\nn                   搜索指定字符串的下一个出现位置\n\n:%s/old/new/g       全文替换指定字符串\n\n:n1,n2s/old/new/g   在一定范围内替换指定字符串\n\n:set ignorecase     搜索是忽略大小写 noignorecase\n\n## 保存和退出\n\n:w          保存修改\n\n:w new_name 另存为指定文件\n\n:wq         保存修改并退出\n\nZZ          快捷键,保存修改并退出\n\n:q!         不保存修改退出\n\n:wq!        保存修改并退出(文件所有者及root可使用)\n\n# 技巧\n导入命令执行结果 :r !命令\n\n定义快捷键 :map 快捷键 触发命令\n\n范例:    \n\n    : map ^P I#<ESC>\n    : map ^B 0x\n连续行注释 \n\n    :n1,n2s/^/#/g\n    :n1,n2s/^#//g\n    :n1,n2s/^/\\/\\//g\n替换 \n\n    :ab mymail samlee@lampbrother.net\n# 参考\n1. 兄弟连Linux","source":"_posts/vim常用命令.md","raw":"---\ntitle: vim常用命令\ndate: 2019-09-30 14:59:28\ncategories:\n- Linux\n\ntags:\n- vim\n\n---\n\n# 常用命令\n\n![模式切换](Vim.png)\n## 插入命令\n\ni 光标前输入 \n\nI 行首输入 \n\na 光标后输入\n\nA 行尾输入\n\no 当前行下新开一行 \n\nO 当前行上新开一行\n## 定位命令\n:set nu   显示行号\n\n:set nonu   为取消行号\n\nw       光标移动到下一个单词  5w 5个单词\n\nb       光标移动到上一个单词\n\ngg       跳到文本首行\n\nG       最后一行\n\nnG      到第n行\n\n:n      到第n行\n\n$       移动到行尾\n\n0       移动到行首   ^\n\n\n## 删除命令\n\nx 删除光标所在处字符\n\nnx  删除光标所在处后n个字符\n\ndd  删除光标所在行,ndd删除n行\n\ndG  删除光标所在行到文件末尾内容\n\nD   删除光标所在处到行尾内容\n\n:n1,n2d 删除指定范围的行\n\n## 复制和剪切\n\nyy  复制当前行\n\nnyy 复制当前行以下n行\n\ndd  剪切当前行\n\nndd 剪切当前行以下n行\n\np、P 粘贴在当前光标所在行下或行上\n\n## 替换和取消\n\nr   取代光标所在处字符\n\nR   从光标所在处开始替换字符,按Esc结束\n\nu   取消上一步操作\n\n## 搜索和搜索替换\n\n/string             搜索指定字符串搜索时忽略大小写 :set ic\n\nn                   搜索指定字符串的下一个出现位置\n\n:%s/old/new/g       全文替换指定字符串\n\n:n1,n2s/old/new/g   在一定范围内替换指定字符串\n\n:set ignorecase     搜索是忽略大小写 noignorecase\n\n## 保存和退出\n\n:w          保存修改\n\n:w new_name 另存为指定文件\n\n:wq         保存修改并退出\n\nZZ          快捷键,保存修改并退出\n\n:q!         不保存修改退出\n\n:wq!        保存修改并退出(文件所有者及root可使用)\n\n# 技巧\n导入命令执行结果 :r !命令\n\n定义快捷键 :map 快捷键 触发命令\n\n范例:    \n\n    : map ^P I#<ESC>\n    : map ^B 0x\n连续行注释 \n\n    :n1,n2s/^/#/g\n    :n1,n2s/^#//g\n    :n1,n2s/^/\\/\\//g\n替换 \n\n    :ab mymail samlee@lampbrother.net\n# 参考\n1. 兄弟连Linux","slug":"vim常用命令","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3chz002omxkaevcb8bfo","content":"<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><img src=\"/2019/09/30/vim常用命令/Vim.png\" alt=\"模式切换\"></p>\n<h2 id=\"插入命令\"><a href=\"#插入命令\" class=\"headerlink\" title=\"插入命令\"></a>插入命令</h2><p>i 光标前输入 </p>\n<p>I 行首输入 </p>\n<p>a 光标后输入</p>\n<p>A 行尾输入</p>\n<p>o 当前行下新开一行 </p>\n<p>O 当前行上新开一行</p>\n<h2 id=\"定位命令\"><a href=\"#定位命令\" class=\"headerlink\" title=\"定位命令\"></a>定位命令</h2><p>:set nu   显示行号</p>\n<p>:set nonu   为取消行号</p>\n<p>w       光标移动到下一个单词  5w 5个单词</p>\n<p>b       光标移动到上一个单词</p>\n<p>gg       跳到文本首行</p>\n<p>G       最后一行</p>\n<p>nG      到第n行</p>\n<p>:n      到第n行</p>\n<p>$       移动到行尾</p>\n<p>0       移动到行首   ^</p>\n<h2 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h2><p>x 删除光标所在处字符</p>\n<p>nx  删除光标所在处后n个字符</p>\n<p>dd  删除光标所在行,ndd删除n行</p>\n<p>dG  删除光标所在行到文件末尾内容</p>\n<p>D   删除光标所在处到行尾内容</p>\n<p>:n1,n2d 删除指定范围的行</p>\n<h2 id=\"复制和剪切\"><a href=\"#复制和剪切\" class=\"headerlink\" title=\"复制和剪切\"></a>复制和剪切</h2><p>yy  复制当前行</p>\n<p>nyy 复制当前行以下n行</p>\n<p>dd  剪切当前行</p>\n<p>ndd 剪切当前行以下n行</p>\n<p>p、P 粘贴在当前光标所在行下或行上</p>\n<h2 id=\"替换和取消\"><a href=\"#替换和取消\" class=\"headerlink\" title=\"替换和取消\"></a>替换和取消</h2><p>r   取代光标所在处字符</p>\n<p>R   从光标所在处开始替换字符,按Esc结束</p>\n<p>u   取消上一步操作</p>\n<h2 id=\"搜索和搜索替换\"><a href=\"#搜索和搜索替换\" class=\"headerlink\" title=\"搜索和搜索替换\"></a>搜索和搜索替换</h2><p>/string             搜索指定字符串搜索时忽略大小写 :set ic</p>\n<p>n                   搜索指定字符串的下一个出现位置</p>\n<p>:%s/old/new/g       全文替换指定字符串</p>\n<p>:n1,n2s/old/new/g   在一定范围内替换指定字符串</p>\n<p>:set ignorecase     搜索是忽略大小写 noignorecase</p>\n<h2 id=\"保存和退出\"><a href=\"#保存和退出\" class=\"headerlink\" title=\"保存和退出\"></a>保存和退出</h2><p>:w          保存修改</p>\n<p>:w new_name 另存为指定文件</p>\n<p>:wq         保存修改并退出</p>\n<p>ZZ          快捷键,保存修改并退出</p>\n<p>:q!         不保存修改退出</p>\n<p>:wq!        保存修改并退出(文件所有者及root可使用)</p>\n<h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><p>导入命令执行结果 :r !命令</p>\n<p>定义快捷键 :map 快捷键 触发命令</p>\n<p>范例:    </p>\n<pre><code>: map ^P I#&lt;ESC&gt;\n: map ^B 0x\n</code></pre><p>连续行注释 </p>\n<pre><code>:n1,n2s/^/#/g\n:n1,n2s/^#//g\n:n1,n2s/^/\\/\\//g\n</code></pre><p>替换 </p>\n<pre><code>:ab mymail samlee@lampbrother.net\n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>兄弟连Linux</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><p><img src=\"/2019/09/30/vim常用命令/Vim.png\" alt=\"模式切换\"></p>\n<h2 id=\"插入命令\"><a href=\"#插入命令\" class=\"headerlink\" title=\"插入命令\"></a>插入命令</h2><p>i 光标前输入 </p>\n<p>I 行首输入 </p>\n<p>a 光标后输入</p>\n<p>A 行尾输入</p>\n<p>o 当前行下新开一行 </p>\n<p>O 当前行上新开一行</p>\n<h2 id=\"定位命令\"><a href=\"#定位命令\" class=\"headerlink\" title=\"定位命令\"></a>定位命令</h2><p>:set nu   显示行号</p>\n<p>:set nonu   为取消行号</p>\n<p>w       光标移动到下一个单词  5w 5个单词</p>\n<p>b       光标移动到上一个单词</p>\n<p>gg       跳到文本首行</p>\n<p>G       最后一行</p>\n<p>nG      到第n行</p>\n<p>:n      到第n行</p>\n<p>$       移动到行尾</p>\n<p>0       移动到行首   ^</p>\n<h2 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h2><p>x 删除光标所在处字符</p>\n<p>nx  删除光标所在处后n个字符</p>\n<p>dd  删除光标所在行,ndd删除n行</p>\n<p>dG  删除光标所在行到文件末尾内容</p>\n<p>D   删除光标所在处到行尾内容</p>\n<p>:n1,n2d 删除指定范围的行</p>\n<h2 id=\"复制和剪切\"><a href=\"#复制和剪切\" class=\"headerlink\" title=\"复制和剪切\"></a>复制和剪切</h2><p>yy  复制当前行</p>\n<p>nyy 复制当前行以下n行</p>\n<p>dd  剪切当前行</p>\n<p>ndd 剪切当前行以下n行</p>\n<p>p、P 粘贴在当前光标所在行下或行上</p>\n<h2 id=\"替换和取消\"><a href=\"#替换和取消\" class=\"headerlink\" title=\"替换和取消\"></a>替换和取消</h2><p>r   取代光标所在处字符</p>\n<p>R   从光标所在处开始替换字符,按Esc结束</p>\n<p>u   取消上一步操作</p>\n<h2 id=\"搜索和搜索替换\"><a href=\"#搜索和搜索替换\" class=\"headerlink\" title=\"搜索和搜索替换\"></a>搜索和搜索替换</h2><p>/string             搜索指定字符串搜索时忽略大小写 :set ic</p>\n<p>n                   搜索指定字符串的下一个出现位置</p>\n<p>:%s/old/new/g       全文替换指定字符串</p>\n<p>:n1,n2s/old/new/g   在一定范围内替换指定字符串</p>\n<p>:set ignorecase     搜索是忽略大小写 noignorecase</p>\n<h2 id=\"保存和退出\"><a href=\"#保存和退出\" class=\"headerlink\" title=\"保存和退出\"></a>保存和退出</h2><p>:w          保存修改</p>\n<p>:w new_name 另存为指定文件</p>\n<p>:wq         保存修改并退出</p>\n<p>ZZ          快捷键,保存修改并退出</p>\n<p>:q!         不保存修改退出</p>\n<p>:wq!        保存修改并退出(文件所有者及root可使用)</p>\n<h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><p>导入命令执行结果 :r !命令</p>\n<p>定义快捷键 :map 快捷键 触发命令</p>\n<p>范例:    </p>\n<pre><code>: map ^P I#&lt;ESC&gt;\n: map ^B 0x\n</code></pre><p>连续行注释 </p>\n<pre><code>:n1,n2s/^/#/g\n:n1,n2s/^#//g\n:n1,n2s/^/\\/\\//g\n</code></pre><p>替换 </p>\n<pre><code>:ab mymail samlee@lampbrother.net\n</code></pre><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>兄弟连Linux</li>\n</ol>\n"},{"title":"word参考文献交叉引用","date":"2019-12-04T00:32:08.000Z","_content":"\n# word参考文献交叉引用\n参考文献交叉引用可以实现正文中引用链接到参考文献，避免参考文献引用出错\n\n1. 参考文献排序\n2. 插入-> 交叉引用 -> 选择对应的文献\n\n\t![交叉引用](插入.png)\n\n## 实现[1-5]形式\n- 第一种方式： 插入之后，选择不想出现的部分,然后选择字体-> 隐藏即可\n\t\n\t![隐藏](隐藏.png)\n\n- 第二种方式：\n\n\t1. 插入交叉引用1,5，右击切换域代码\n\t\t\n\t\t\t导纳控制{ REF _Re26341043 \\r \\h }{ REF _Ref26341045 \\r \\h }\n\t2. 增加代码\n\n\t\t\t导纳控制{ REF _Re26341043 \\r \\h \\#\"[0\"}{ REF _Ref26341045 \\r \\h \\#\"0]\"}\n\t3. 更新域代码,添加 \"-\", ctrl+shift++ 切换为上标\n\n\t\n# 引用\n1. [Word|如何使用交叉引用标注参考文献](https://www.jianshu.com/p/e6f71f8ba19a)\t\n2. [word参考文献交叉引用的连续多项引用?](https://jingyan.baidu.com/article/25648fc15c03439191fd0033.html)\n\t","source":"_posts/word参考文献交叉引用.md","raw":"---\ntitle: word参考文献交叉引用\ndate: 2019-12-04 08:32:08\ncategories:\n- software \ntags:\n- word\n\n---\n\n# word参考文献交叉引用\n参考文献交叉引用可以实现正文中引用链接到参考文献，避免参考文献引用出错\n\n1. 参考文献排序\n2. 插入-> 交叉引用 -> 选择对应的文献\n\n\t![交叉引用](插入.png)\n\n## 实现[1-5]形式\n- 第一种方式： 插入之后，选择不想出现的部分,然后选择字体-> 隐藏即可\n\t\n\t![隐藏](隐藏.png)\n\n- 第二种方式：\n\n\t1. 插入交叉引用1,5，右击切换域代码\n\t\t\n\t\t\t导纳控制{ REF _Re26341043 \\r \\h }{ REF _Ref26341045 \\r \\h }\n\t2. 增加代码\n\n\t\t\t导纳控制{ REF _Re26341043 \\r \\h \\#\"[0\"}{ REF _Ref26341045 \\r \\h \\#\"0]\"}\n\t3. 更新域代码,添加 \"-\", ctrl+shift++ 切换为上标\n\n\t\n# 引用\n1. [Word|如何使用交叉引用标注参考文献](https://www.jianshu.com/p/e6f71f8ba19a)\t\n2. [word参考文献交叉引用的连续多项引用?](https://jingyan.baidu.com/article/25648fc15c03439191fd0033.html)\n\t","slug":"word参考文献交叉引用","published":1,"updated":"2019-12-04T01:02:40.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci0002rmxkanroefcq7","content":"<h1 id=\"word参考文献交叉引用\"><a href=\"#word参考文献交叉引用\" class=\"headerlink\" title=\"word参考文献交叉引用\"></a>word参考文献交叉引用</h1><p>参考文献交叉引用可以实现正文中引用链接到参考文献，避免参考文献引用出错</p>\n<ol>\n<li>参考文献排序</li>\n<li><p>插入-&gt; 交叉引用 -&gt; 选择对应的文献</p>\n<p> <img src=\"/2019/12/04/word参考文献交叉引用/插入.png\" alt=\"交叉引用\"></p>\n</li>\n</ol>\n<h2 id=\"实现-1-5-形式\"><a href=\"#实现-1-5-形式\" class=\"headerlink\" title=\"实现[1-5]形式\"></a>实现[1-5]形式</h2><ul>\n<li><p>第一种方式： 插入之后，选择不想出现的部分,然后选择字体-&gt; 隐藏即可</p>\n<p>  <img src=\"/2019/12/04/word参考文献交叉引用/隐藏.png\" alt=\"隐藏\"></p>\n</li>\n<li><p>第二种方式：</p>\n<ol>\n<li><p>插入交叉引用1,5，右击切换域代码</p>\n<pre><code> 导纳控制{ REF _Re26341043 \\r \\h }{ REF _Ref26341045 \\r \\h }\n</code></pre></li>\n<li><p>增加代码</p>\n<pre><code> 导纳控制{ REF _Re26341043 \\r \\h \\#&quot;[0&quot;}{ REF _Ref26341045 \\r \\h \\#&quot;0]&quot;}\n</code></pre></li>\n<li>更新域代码,添加 “-“, ctrl+shift++ 切换为上标</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/e6f71f8ba19a\" target=\"_blank\" rel=\"noopener\">Word|如何使用交叉引用标注参考文献</a>    </li>\n<li><a href=\"https://jingyan.baidu.com/article/25648fc15c03439191fd0033.html\" target=\"_blank\" rel=\"noopener\">word参考文献交叉引用的连续多项引用?</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"word参考文献交叉引用\"><a href=\"#word参考文献交叉引用\" class=\"headerlink\" title=\"word参考文献交叉引用\"></a>word参考文献交叉引用</h1><p>参考文献交叉引用可以实现正文中引用链接到参考文献，避免参考文献引用出错</p>\n<ol>\n<li>参考文献排序</li>\n<li><p>插入-&gt; 交叉引用 -&gt; 选择对应的文献</p>\n<p> <img src=\"/2019/12/04/word参考文献交叉引用/插入.png\" alt=\"交叉引用\"></p>\n</li>\n</ol>\n<h2 id=\"实现-1-5-形式\"><a href=\"#实现-1-5-形式\" class=\"headerlink\" title=\"实现[1-5]形式\"></a>实现[1-5]形式</h2><ul>\n<li><p>第一种方式： 插入之后，选择不想出现的部分,然后选择字体-&gt; 隐藏即可</p>\n<p>  <img src=\"/2019/12/04/word参考文献交叉引用/隐藏.png\" alt=\"隐藏\"></p>\n</li>\n<li><p>第二种方式：</p>\n<ol>\n<li><p>插入交叉引用1,5，右击切换域代码</p>\n<pre><code> 导纳控制{ REF _Re26341043 \\r \\h }{ REF _Ref26341045 \\r \\h }\n</code></pre></li>\n<li><p>增加代码</p>\n<pre><code> 导纳控制{ REF _Re26341043 \\r \\h \\#&quot;[0&quot;}{ REF _Ref26341045 \\r \\h \\#&quot;0]&quot;}\n</code></pre></li>\n<li>更新域代码,添加 “-“, ctrl+shift++ 切换为上标</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/e6f71f8ba19a\" target=\"_blank\" rel=\"noopener\">Word|如何使用交叉引用标注参考文献</a>    </li>\n<li><a href=\"https://jingyan.baidu.com/article/25648fc15c03439191fd0033.html\" target=\"_blank\" rel=\"noopener\">word参考文献交叉引用的连续多项引用?</a></li>\n</ol>\n"},{"title":"位姿变换矩阵左乘和右乘理解","date":"2019-12-08T03:49:49.000Z","mathjax":true,"_content":"\n# 旋转矩阵含义\n坐标系中物体的运动：物体运动(变换算子，只涉及到全局坐标系)；坐标系反方向运动\n\n1. 变换算子   \n2. 位姿描述\n\n# X-Y-Z固定角 算子左乘\n1. 可以看作算子对一个向量的不断变换\n\n    $$\n    _{B}^{A} R_{X Y Z}(\\gamma, \\beta, \\alpha)=R_{Z}(\\alpha) R_{Y}(\\beta) R_{X}(\\gamma)\n    $$\n    \n    ![xyz固定角](xyz固定角.png)\n2. 可用位姿变换和右乘统一\n    \n    坐标系在B中旋转等效为坐标系B向相反方向旋转,比如全局 $${R_k}(\\theta )$$\n    \n    则有  \n    \n    $${}_A^BR$$ \n    \n    $${}_{B'}^BR = {R_k}{(\\theta )^{ - 1}}$$\n    \n    所以 $${}_A^{B'}R = {}_{B'}^B{R^{ - 1}} \\cdot {}_A^BR = {R_k}(\\theta ) \\cdot {}_A^BR$$\n    \n    ![位姿描述](pose.jpg)      \n    \n\n\n\n# Z-Y-X欧拉角 右乘\n坐标系描述 \n\n$$_B^AR = {}_{B'}^AR{}_{B''}^{B'}R{}_B^{B''}R{\\text{ = }}{R_Z}(\\alpha ){R_Y}(\\beta ){R_X}(\\gamma )$$  \n\n\n![zyx欧拉角](zyx欧拉角.png)\n\n# 等效角度-轴线\n1. 绕通过原点轴线旋转\n\n\t理解成全局坐标系中一向量变换到局部坐标系-》绕z轴旋转-》变回全局坐标系\n\t\n\t$_{B}^{A} R_{k}(\\theta)=R^{-1} R_{z}(\\theta) R$\n\t\n\t其中R为将全局坐标系z轴旋转到K轴的变换矩阵\n\n2. 绕不通过原点轴线旋转\n\t类似绕通过原点轴线旋转处理方式\n\n# 引用\n1. [Introduction To Robotics mechanics and control](https://book.douban.com/subject/30325317/)","source":"_posts/位姿变换矩阵左乘和右乘理解.md","raw":"---\ntitle: 位姿变换矩阵左乘和右乘理解\ndate: 2019-12-08 11:49:49\ncategories:\n- math\ntags:\n- 机器人学\n- 位姿变换\nmathjax: true\n---\n\n# 旋转矩阵含义\n坐标系中物体的运动：物体运动(变换算子，只涉及到全局坐标系)；坐标系反方向运动\n\n1. 变换算子   \n2. 位姿描述\n\n# X-Y-Z固定角 算子左乘\n1. 可以看作算子对一个向量的不断变换\n\n    $$\n    _{B}^{A} R_{X Y Z}(\\gamma, \\beta, \\alpha)=R_{Z}(\\alpha) R_{Y}(\\beta) R_{X}(\\gamma)\n    $$\n    \n    ![xyz固定角](xyz固定角.png)\n2. 可用位姿变换和右乘统一\n    \n    坐标系在B中旋转等效为坐标系B向相反方向旋转,比如全局 $${R_k}(\\theta )$$\n    \n    则有  \n    \n    $${}_A^BR$$ \n    \n    $${}_{B'}^BR = {R_k}{(\\theta )^{ - 1}}$$\n    \n    所以 $${}_A^{B'}R = {}_{B'}^B{R^{ - 1}} \\cdot {}_A^BR = {R_k}(\\theta ) \\cdot {}_A^BR$$\n    \n    ![位姿描述](pose.jpg)      \n    \n\n\n\n# Z-Y-X欧拉角 右乘\n坐标系描述 \n\n$$_B^AR = {}_{B'}^AR{}_{B''}^{B'}R{}_B^{B''}R{\\text{ = }}{R_Z}(\\alpha ){R_Y}(\\beta ){R_X}(\\gamma )$$  \n\n\n![zyx欧拉角](zyx欧拉角.png)\n\n# 等效角度-轴线\n1. 绕通过原点轴线旋转\n\n\t理解成全局坐标系中一向量变换到局部坐标系-》绕z轴旋转-》变回全局坐标系\n\t\n\t$_{B}^{A} R_{k}(\\theta)=R^{-1} R_{z}(\\theta) R$\n\t\n\t其中R为将全局坐标系z轴旋转到K轴的变换矩阵\n\n2. 绕不通过原点轴线旋转\n\t类似绕通过原点轴线旋转处理方式\n\n# 引用\n1. [Introduction To Robotics mechanics and control](https://book.douban.com/subject/30325317/)","slug":"位姿变换矩阵左乘和右乘理解","published":1,"updated":"2019-12-10T02:22:23.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci0002umxka1rfs3mu4","content":"<h1 id=\"旋转矩阵含义\"><a href=\"#旋转矩阵含义\" class=\"headerlink\" title=\"旋转矩阵含义\"></a>旋转矩阵含义</h1><p>坐标系中物体的运动：物体运动(变换算子，只涉及到全局坐标系)；坐标系反方向运动</p>\n<ol>\n<li>变换算子   </li>\n<li>位姿描述</li>\n</ol>\n<h1 id=\"X-Y-Z固定角-算子左乘\"><a href=\"#X-Y-Z固定角-算子左乘\" class=\"headerlink\" title=\"X-Y-Z固定角 算子左乘\"></a>X-Y-Z固定角 算子左乘</h1><ol>\n<li><p>可以看作算子对一个向量的不断变换</p>\n<script type=\"math/tex; mode=display\">\n _{B}^{A} R_{X Y Z}(\\gamma, \\beta, \\alpha)=R_{Z}(\\alpha) R_{Y}(\\beta) R_{X}(\\gamma)</script><p> <img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/xyz固定角.png\" alt=\"xyz固定角\"></p>\n</li>\n<li><p>可用位姿变换和右乘统一</p>\n<p> 坐标系在B中旋转等效为坐标系B向相反方向旋转,比如全局 <script type=\"math/tex\">{R_k}(\\theta )</script></p>\n<p> 则有  </p>\n<script type=\"math/tex; mode=display\">{}_A^BR</script><script type=\"math/tex; mode=display\">{}_{B'}^BR = {R_k}{(\\theta )^{ - 1}}</script><p> 所以 <script type=\"math/tex\">{}_A^{B'}R = {}_{B'}^B{R^{ - 1}} \\cdot {}_A^BR = {R_k}(\\theta ) \\cdot {}_A^BR</script></p>\n<p> <img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/pose.jpg\" alt=\"位姿描述\">      </p>\n</li>\n</ol>\n<h1 id=\"Z-Y-X欧拉角-右乘\"><a href=\"#Z-Y-X欧拉角-右乘\" class=\"headerlink\" title=\"Z-Y-X欧拉角 右乘\"></a>Z-Y-X欧拉角 右乘</h1><p>坐标系描述 </p>\n<script type=\"math/tex; mode=display\">_B^AR = {}_{B'}^AR{}_{B''}^{B'}R{}_B^{B''}R{\\text{ = }}{R_Z}(\\alpha ){R_Y}(\\beta ){R_X}(\\gamma )</script><p><img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/zyx欧拉角.png\" alt=\"zyx欧拉角\"></p>\n<h1 id=\"等效角度-轴线\"><a href=\"#等效角度-轴线\" class=\"headerlink\" title=\"等效角度-轴线\"></a>等效角度-轴线</h1><ol>\n<li><p>绕通过原点轴线旋转</p>\n<p> 理解成全局坐标系中一向量变换到局部坐标系-》绕z轴旋转-》变回全局坐标系</p>\n<p> $_{B}^{A} R_{k}(\\theta)=R^{-1} R_{z}(\\theta) R$</p>\n<p> 其中R为将全局坐标系z轴旋转到K轴的变换矩阵</p>\n</li>\n<li><p>绕不通过原点轴线旋转<br> 类似绕通过原点轴线旋转处理方式</p>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://book.douban.com/subject/30325317/\" target=\"_blank\" rel=\"noopener\">Introduction To Robotics mechanics and control</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"旋转矩阵含义\"><a href=\"#旋转矩阵含义\" class=\"headerlink\" title=\"旋转矩阵含义\"></a>旋转矩阵含义</h1><p>坐标系中物体的运动：物体运动(变换算子，只涉及到全局坐标系)；坐标系反方向运动</p>\n<ol>\n<li>变换算子   </li>\n<li>位姿描述</li>\n</ol>\n<h1 id=\"X-Y-Z固定角-算子左乘\"><a href=\"#X-Y-Z固定角-算子左乘\" class=\"headerlink\" title=\"X-Y-Z固定角 算子左乘\"></a>X-Y-Z固定角 算子左乘</h1><ol>\n<li><p>可以看作算子对一个向量的不断变换</p>\n<script type=\"math/tex; mode=display\">\n _{B}^{A} R_{X Y Z}(\\gamma, \\beta, \\alpha)=R_{Z}(\\alpha) R_{Y}(\\beta) R_{X}(\\gamma)</script><p> <img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/xyz固定角.png\" alt=\"xyz固定角\"></p>\n</li>\n<li><p>可用位姿变换和右乘统一</p>\n<p> 坐标系在B中旋转等效为坐标系B向相反方向旋转,比如全局 <script type=\"math/tex\">{R_k}(\\theta )</script></p>\n<p> 则有  </p>\n<script type=\"math/tex; mode=display\">{}_A^BR</script><script type=\"math/tex; mode=display\">{}_{B'}^BR = {R_k}{(\\theta )^{ - 1}}</script><p> 所以 <script type=\"math/tex\">{}_A^{B'}R = {}_{B'}^B{R^{ - 1}} \\cdot {}_A^BR = {R_k}(\\theta ) \\cdot {}_A^BR</script></p>\n<p> <img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/pose.jpg\" alt=\"位姿描述\">      </p>\n</li>\n</ol>\n<h1 id=\"Z-Y-X欧拉角-右乘\"><a href=\"#Z-Y-X欧拉角-右乘\" class=\"headerlink\" title=\"Z-Y-X欧拉角 右乘\"></a>Z-Y-X欧拉角 右乘</h1><p>坐标系描述 </p>\n<script type=\"math/tex; mode=display\">_B^AR = {}_{B'}^AR{}_{B''}^{B'}R{}_B^{B''}R{\\text{ = }}{R_Z}(\\alpha ){R_Y}(\\beta ){R_X}(\\gamma )</script><p><img src=\"/2019/12/08/位姿变换矩阵左乘和右乘理解/zyx欧拉角.png\" alt=\"zyx欧拉角\"></p>\n<h1 id=\"等效角度-轴线\"><a href=\"#等效角度-轴线\" class=\"headerlink\" title=\"等效角度-轴线\"></a>等效角度-轴线</h1><ol>\n<li><p>绕通过原点轴线旋转</p>\n<p> 理解成全局坐标系中一向量变换到局部坐标系-》绕z轴旋转-》变回全局坐标系</p>\n<p> $_{B}^{A} R_{k}(\\theta)=R^{-1} R_{z}(\\theta) R$</p>\n<p> 其中R为将全局坐标系z轴旋转到K轴的变换矩阵</p>\n</li>\n<li><p>绕不通过原点轴线旋转<br> 类似绕通过原点轴线旋转处理方式</p>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://book.douban.com/subject/30325317/\" target=\"_blank\" rel=\"noopener\">Introduction To Robotics mechanics and control</a></li>\n</ol>\n"},{"title":"ubuntu解压文件名字无法显示中文(中文乱码)","date":"2019-11-23T03:23:52.000Z","_content":"1. zip解压文件名乱码\n    \n    由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等。因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。\n\n        unzip -O gbk xxx.zip        \n        unzip -O gbk xxx.zip -d xxx  ## 解压到指定文件夹    \n2. gedit 文件内容乱码 \n    \n        gsettings set org.gnome.gedit.preferences.encodings candidate-encodings \"['UTF-8','CURRENT','GB18030','ISO-8859-15','UTF-16']\"\n3. vim 中文乱码\n        \n        # 建议修改本地配置文件\n        sudo gedit /etc/vim/vimrc   # 系统配置文件\n        sudo gedit .vimrc   # 本地配置文件\n        \n        # 增加下面内容\n        set fileencodings=utf-8,gb2312,gbk,gb18030\n        \n        set termencoding=utf-8\n        \n        set encoding=prc        \n\n# 引用\n1. [ubuntu 16.4解压中文名文件夹，中文乱码](https://blog.csdn.net/weixin_40009624/article/details/79019907)      \n2. [Ubuntu 16.04 解压缩zip文件中文乱码](https://blog.csdn.net/w7619370/article/details/53024281)    \n","source":"_posts/ubuntu解压文件名字无法显示中文-中文乱码.md","raw":"---\ntitle: ubuntu解压文件名字无法显示中文(中文乱码)\ndate: 2019-11-23 11:23:52\ncategories:\n- Linux\ntags:\n- 编码\n---\n1. zip解压文件名乱码\n    \n    由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等。因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。\n\n        unzip -O gbk xxx.zip        \n        unzip -O gbk xxx.zip -d xxx  ## 解压到指定文件夹    \n2. gedit 文件内容乱码 \n    \n        gsettings set org.gnome.gedit.preferences.encodings candidate-encodings \"['UTF-8','CURRENT','GB18030','ISO-8859-15','UTF-16']\"\n3. vim 中文乱码\n        \n        # 建议修改本地配置文件\n        sudo gedit /etc/vim/vimrc   # 系统配置文件\n        sudo gedit .vimrc   # 本地配置文件\n        \n        # 增加下面内容\n        set fileencodings=utf-8,gb2312,gbk,gb18030\n        \n        set termencoding=utf-8\n        \n        set encoding=prc        \n\n# 引用\n1. [ubuntu 16.4解压中文名文件夹，中文乱码](https://blog.csdn.net/weixin_40009624/article/details/79019907)      \n2. [Ubuntu 16.04 解压缩zip文件中文乱码](https://blog.csdn.net/w7619370/article/details/53024281)    \n","slug":"ubuntu解压文件名字无法显示中文-中文乱码","published":1,"updated":"2020-09-23T14:42:00.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci1002xmxkab34xz8h6","content":"<ol>\n<li><p>zip解压文件名乱码</p>\n<p> 由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等。因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。</p>\n<pre><code> unzip -O gbk xxx.zip        \n unzip -O gbk xxx.zip -d xxx  ## 解压到指定文件夹    \n</code></pre></li>\n<li><p>gedit 文件内容乱码 </p>\n<pre><code> gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#39;UTF-8&#39;,&#39;CURRENT&#39;,&#39;GB18030&#39;,&#39;ISO-8859-15&#39;,&#39;UTF-16&#39;]&quot;\n</code></pre></li>\n<li><p>vim 中文乱码</p>\n<pre><code> # 建议修改本地配置文件\n sudo gedit /etc/vim/vimrc   # 系统配置文件\n sudo gedit .vimrc   # 本地配置文件\n\n # 增加下面内容\n set fileencodings=utf-8,gb2312,gbk,gb18030\n\n set termencoding=utf-8\n\n set encoding=prc        \n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/weixin_40009624/article/details/79019907\" target=\"_blank\" rel=\"noopener\">ubuntu 16.4解压中文名文件夹，中文乱码</a>      </li>\n<li><a href=\"https://blog.csdn.net/w7619370/article/details/53024281\" target=\"_blank\" rel=\"noopener\">Ubuntu 16.04 解压缩zip文件中文乱码</a>    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>zip解压文件名乱码</p>\n<p> 由于zip格式中并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等。因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。</p>\n<pre><code> unzip -O gbk xxx.zip        \n unzip -O gbk xxx.zip -d xxx  ## 解压到指定文件夹    \n</code></pre></li>\n<li><p>gedit 文件内容乱码 </p>\n<pre><code> gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#39;UTF-8&#39;,&#39;CURRENT&#39;,&#39;GB18030&#39;,&#39;ISO-8859-15&#39;,&#39;UTF-16&#39;]&quot;\n</code></pre></li>\n<li><p>vim 中文乱码</p>\n<pre><code> # 建议修改本地配置文件\n sudo gedit /etc/vim/vimrc   # 系统配置文件\n sudo gedit .vimrc   # 本地配置文件\n\n # 增加下面内容\n set fileencodings=utf-8,gb2312,gbk,gb18030\n\n set termencoding=utf-8\n\n set encoding=prc        \n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/weixin_40009624/article/details/79019907\" target=\"_blank\" rel=\"noopener\">ubuntu 16.4解压中文名文件夹，中文乱码</a>      </li>\n<li><a href=\"https://blog.csdn.net/w7619370/article/details/53024281\" target=\"_blank\" rel=\"noopener\">Ubuntu 16.04 解压缩zip文件中文乱码</a>    </li>\n</ol>\n"},{"title":"多系统启动盘制作","date":"2019-07-21T07:18:56.000Z","_content":"\n# 软件\n\n[WinSetupFromUsb](http://www.winsetupfromusb.com/supported-sources/)\n\n# 流程\n\n![步骤](WinSetup.png)","source":"_posts/多系统启动盘制作.md","raw":"---\ntitle: 多系统启动盘制作\ndate: 2019-07-21 15:18:56\ncategories:\n- systems\ntags:\n- 重装系统\n\n---\n\n# 软件\n\n[WinSetupFromUsb](http://www.winsetupfromusb.com/supported-sources/)\n\n# 流程\n\n![步骤](WinSetup.png)","slug":"多系统启动盘制作","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci20031mxka2ev4dsyb","content":"<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h1><p><a href=\"http://www.winsetupfromusb.com/supported-sources/\" target=\"_blank\" rel=\"noopener\">WinSetupFromUsb</a></p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p><img src=\"/2019/07/21/多系统启动盘制作/WinSetup.png\" alt=\"步骤\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h1><p><a href=\"http://www.winsetupfromusb.com/supported-sources/\" target=\"_blank\" rel=\"noopener\">WinSetupFromUsb</a></p>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p><img src=\"/2019/07/21/多系统启动盘制作/WinSetup.png\" alt=\"步骤\"></p>\n"},{"title":"word排版","date":"2019-12-14T13:39:40.000Z","_content":"\n# 点(point,pt)\n是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。\n\n![中文字号](中文字号.png)\n\n\n\n\t\n# 使用word模板样式\n可将模板中的样式导入到需要用的文档\n\n![导出样式](导出样式.png)\n# 中英文对照\n学术上专业用语对照查询\n[cnki翻译助手](http://dict.cnki.net/dict_result.aspx)\n# 图表\n**word中千万不要手动拖动图片大小**\n\n在visio 设置图纸大小和字号(pt)\n\nmathtype设置好字号，公式、字母直接复制visio中\n\n图片插入到word后不要拖动调整大小\n\nps中同理设置字号，图像大小\n# 公式\nmathtype 可以插入公式序号 引用(双击公式序号) \n\n可以先在mathtype设置好格式，存储为样板(10pt)\n\n# 批量修改word图片为灰度图或彩图\nAlt+F11 进入宏界面->插入->模块->粘贴下列代码->F5运行\n\n    Sub xx()\n    Dim i As Integer\n    For i = 1 To ActiveDocument.InlineShapes.Count\n    If ActiveDocument.InlineShapes(i).Type = 3 Then\n    ActiveDocument.InlineShapes(i).PictureFormat.ColorType = msoPictureGrayscale\n    End If\n    Next\n    End Sub\n\n几种样式如下\n- 自动：msoPictureAutomatic\n- 黑白：msoPictureBlackAndWhite\n- 灰度：msoPictureGrayscale\n- 冲蚀：msoPictureMixed\n- 水印：msoPictureWatermark\n\n# 参考文献 \n\n{% post_link word参考文献交叉引用 交叉引用 %}\n\n# 引用\n1. 维基百科 [点 (印刷)](https://zh.wikipedia.org/wiki/%E9%BB%9E_(%E5%8D%B0%E5%88%B7))\n2. [Word文档里的图片怎么批量修改图片颜色灰度变回彩色](https://wenwen.sogou.com/z/q807873456.htm)","source":"_posts/word排版.md","raw":"---\ntitle: word排版\ndate: 2019-12-14 21:39:40\ncategories:\n- software\ntags:\n- matlab绘图\n\n---\n\n# 点(point,pt)\n是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。\n\n![中文字号](中文字号.png)\n\n\n\n\t\n# 使用word模板样式\n可将模板中的样式导入到需要用的文档\n\n![导出样式](导出样式.png)\n# 中英文对照\n学术上专业用语对照查询\n[cnki翻译助手](http://dict.cnki.net/dict_result.aspx)\n# 图表\n**word中千万不要手动拖动图片大小**\n\n在visio 设置图纸大小和字号(pt)\n\nmathtype设置好字号，公式、字母直接复制visio中\n\n图片插入到word后不要拖动调整大小\n\nps中同理设置字号，图像大小\n# 公式\nmathtype 可以插入公式序号 引用(双击公式序号) \n\n可以先在mathtype设置好格式，存储为样板(10pt)\n\n# 批量修改word图片为灰度图或彩图\nAlt+F11 进入宏界面->插入->模块->粘贴下列代码->F5运行\n\n    Sub xx()\n    Dim i As Integer\n    For i = 1 To ActiveDocument.InlineShapes.Count\n    If ActiveDocument.InlineShapes(i).Type = 3 Then\n    ActiveDocument.InlineShapes(i).PictureFormat.ColorType = msoPictureGrayscale\n    End If\n    Next\n    End Sub\n\n几种样式如下\n- 自动：msoPictureAutomatic\n- 黑白：msoPictureBlackAndWhite\n- 灰度：msoPictureGrayscale\n- 冲蚀：msoPictureMixed\n- 水印：msoPictureWatermark\n\n# 参考文献 \n\n{% post_link word参考文献交叉引用 交叉引用 %}\n\n# 引用\n1. 维基百科 [点 (印刷)](https://zh.wikipedia.org/wiki/%E9%BB%9E_(%E5%8D%B0%E5%88%B7))\n2. [Word文档里的图片怎么批量修改图片颜色灰度变回彩色](https://wenwen.sogou.com/z/q807873456.htm)","slug":"word排版","published":1,"updated":"2020-10-27T06:26:50.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci30034mxkaph6pv29m","content":"<h1 id=\"点-point-pt\"><a href=\"#点-point-pt\" class=\"headerlink\" title=\"点(point,pt)\"></a>点(point,pt)</h1><p>是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。</p>\n<p><img src=\"/2019/12/14/word排版/中文字号.png\" alt=\"中文字号\"></p>\n<h1 id=\"使用word模板样式\"><a href=\"#使用word模板样式\" class=\"headerlink\" title=\"使用word模板样式\"></a>使用word模板样式</h1><p>可将模板中的样式导入到需要用的文档</p>\n<p><img src=\"/2019/12/14/word排版/导出样式.png\" alt=\"导出样式\"></p>\n<h1 id=\"中英文对照\"><a href=\"#中英文对照\" class=\"headerlink\" title=\"中英文对照\"></a>中英文对照</h1><p>学术上专业用语对照查询<br><a href=\"http://dict.cnki.net/dict_result.aspx\" target=\"_blank\" rel=\"noopener\">cnki翻译助手</a></p>\n<h1 id=\"图表\"><a href=\"#图表\" class=\"headerlink\" title=\"图表\"></a>图表</h1><p><strong>word中千万不要手动拖动图片大小</strong></p>\n<p>在visio 设置图纸大小和字号(pt)</p>\n<p>mathtype设置好字号，公式、字母直接复制visio中</p>\n<p>图片插入到word后不要拖动调整大小</p>\n<p>ps中同理设置字号，图像大小</p>\n<h1 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h1><p>mathtype 可以插入公式序号 引用(双击公式序号) </p>\n<p>可以先在mathtype设置好格式，存储为样板(10pt)</p>\n<h1 id=\"批量修改word图片为灰度图或彩图\"><a href=\"#批量修改word图片为灰度图或彩图\" class=\"headerlink\" title=\"批量修改word图片为灰度图或彩图\"></a>批量修改word图片为灰度图或彩图</h1><p>Alt+F11 进入宏界面-&gt;插入-&gt;模块-&gt;粘贴下列代码-&gt;F5运行</p>\n<pre><code>Sub xx()\nDim i As Integer\nFor i = 1 To ActiveDocument.InlineShapes.Count\nIf ActiveDocument.InlineShapes(i).Type = 3 Then\nActiveDocument.InlineShapes(i).PictureFormat.ColorType = msoPictureGrayscale\nEnd If\nNext\nEnd Sub\n</code></pre><p>几种样式如下</p>\n<ul>\n<li>自动：msoPictureAutomatic</li>\n<li>黑白：msoPictureBlackAndWhite</li>\n<li>灰度：msoPictureGrayscale</li>\n<li>冲蚀：msoPictureMixed</li>\n<li>水印：msoPictureWatermark</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><a href=\"/2019/12/04/word参考文献交叉引用/\" title=\"交叉引用\">交叉引用</a>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>维基百科 <a href=\"https://zh.wikipedia.org/wiki/%E9%BB%9E_(%E5%8D%B0%E5%88%B7\" target=\"_blank\" rel=\"noopener\">点 (印刷)</a>)</li>\n<li><a href=\"https://wenwen.sogou.com/z/q807873456.htm\" target=\"_blank\" rel=\"noopener\">Word文档里的图片怎么批量修改图片颜色灰度变回彩色</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"点-point-pt\"><a href=\"#点-point-pt\" class=\"headerlink\" title=\"点(point,pt)\"></a>点(point,pt)</h1><p>是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。</p>\n<p><img src=\"/2019/12/14/word排版/中文字号.png\" alt=\"中文字号\"></p>\n<h1 id=\"使用word模板样式\"><a href=\"#使用word模板样式\" class=\"headerlink\" title=\"使用word模板样式\"></a>使用word模板样式</h1><p>可将模板中的样式导入到需要用的文档</p>\n<p><img src=\"/2019/12/14/word排版/导出样式.png\" alt=\"导出样式\"></p>\n<h1 id=\"中英文对照\"><a href=\"#中英文对照\" class=\"headerlink\" title=\"中英文对照\"></a>中英文对照</h1><p>学术上专业用语对照查询<br><a href=\"http://dict.cnki.net/dict_result.aspx\" target=\"_blank\" rel=\"noopener\">cnki翻译助手</a></p>\n<h1 id=\"图表\"><a href=\"#图表\" class=\"headerlink\" title=\"图表\"></a>图表</h1><p><strong>word中千万不要手动拖动图片大小</strong></p>\n<p>在visio 设置图纸大小和字号(pt)</p>\n<p>mathtype设置好字号，公式、字母直接复制visio中</p>\n<p>图片插入到word后不要拖动调整大小</p>\n<p>ps中同理设置字号，图像大小</p>\n<h1 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h1><p>mathtype 可以插入公式序号 引用(双击公式序号) </p>\n<p>可以先在mathtype设置好格式，存储为样板(10pt)</p>\n<h1 id=\"批量修改word图片为灰度图或彩图\"><a href=\"#批量修改word图片为灰度图或彩图\" class=\"headerlink\" title=\"批量修改word图片为灰度图或彩图\"></a>批量修改word图片为灰度图或彩图</h1><p>Alt+F11 进入宏界面-&gt;插入-&gt;模块-&gt;粘贴下列代码-&gt;F5运行</p>\n<pre><code>Sub xx()\nDim i As Integer\nFor i = 1 To ActiveDocument.InlineShapes.Count\nIf ActiveDocument.InlineShapes(i).Type = 3 Then\nActiveDocument.InlineShapes(i).PictureFormat.ColorType = msoPictureGrayscale\nEnd If\nNext\nEnd Sub\n</code></pre><p>几种样式如下</p>\n<ul>\n<li>自动：msoPictureAutomatic</li>\n<li>黑白：msoPictureBlackAndWhite</li>\n<li>灰度：msoPictureGrayscale</li>\n<li>冲蚀：msoPictureMixed</li>\n<li>水印：msoPictureWatermark</li>\n</ul>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><a href=\"/2019/12/04/word参考文献交叉引用/\" title=\"交叉引用\">交叉引用</a>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>维基百科 <a href=\"https://zh.wikipedia.org/wiki/%E9%BB%9E_(%E5%8D%B0%E5%88%B7\" target=\"_blank\" rel=\"noopener\">点 (印刷)</a>)</li>\n<li><a href=\"https://wenwen.sogou.com/z/q807873456.htm\" target=\"_blank\" rel=\"noopener\">Word文档里的图片怎么批量修改图片颜色灰度变回彩色</a></li>\n</ol>\n"},{"title":"实用小技巧汇总","date":"2019-10-20T11:12:25.000Z","_content":"# ps统一裁剪图片大小\n1. 窗口->动作　显示动作面板，在历史记录面板里面\n2. 新建动作组　录制动作\n3. 文件->自动->批处理\n\n**注意事项**：\n点击选项打开切换对话开关　可以在处理自动处理工程在裁剪处停止　手动调整裁剪的位置的大小\n\n![打开切换对话](切换对话开.png) ![关闭切换对话](切换对话关.png)\n\n# ps矫正扫描件　ppt\n扫描件\n- 复制图层　填充为白色　拉直工具(在不改变图像大小的情况下拉直)\n\nppt\n- 透视裁剪 \n\n# 视屏调整大小\n- premiere 更改视频码率　选可变码率　\n  \n码率：视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率\n\n- 固定码率：　\n- 可变码率：视频信源本身的高峰信息量是变化的，能按信源本身的信息量去分配，从而有效地利用信息资源。\n\n# 存放小文件到github方便下载\n\n仓库名网址/archive/master.zip 即可下载仓库内容 不用到仓库地址点击下载\n\n例如博客 {% post_link ubuntu下wps缺少字体 ubuntu下wps缺少字体 %} 中对应的下载字体 \n[https://github.com/yangbenbo/wps-font-symbols/archive/master.zip](https://github.com/yangbenbo/wps-font-symbols/archive/master.zip)\n\n\n# 引用\n1. [ps实用技能：如何统一裁剪图片大小](http://www.sohu.com/a/258392499_99914465)","source":"_posts/实用小技巧汇总.md","raw":"---\ntitle: 实用小技巧汇总\ndate: 2019-10-20 19:12:25\ncategories:\n- software\ntags:\n- ps\n\n---\n# ps统一裁剪图片大小\n1. 窗口->动作　显示动作面板，在历史记录面板里面\n2. 新建动作组　录制动作\n3. 文件->自动->批处理\n\n**注意事项**：\n点击选项打开切换对话开关　可以在处理自动处理工程在裁剪处停止　手动调整裁剪的位置的大小\n\n![打开切换对话](切换对话开.png) ![关闭切换对话](切换对话关.png)\n\n# ps矫正扫描件　ppt\n扫描件\n- 复制图层　填充为白色　拉直工具(在不改变图像大小的情况下拉直)\n\nppt\n- 透视裁剪 \n\n# 视屏调整大小\n- premiere 更改视频码率　选可变码率　\n  \n码率：视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率\n\n- 固定码率：　\n- 可变码率：视频信源本身的高峰信息量是变化的，能按信源本身的信息量去分配，从而有效地利用信息资源。\n\n# 存放小文件到github方便下载\n\n仓库名网址/archive/master.zip 即可下载仓库内容 不用到仓库地址点击下载\n\n例如博客 {% post_link ubuntu下wps缺少字体 ubuntu下wps缺少字体 %} 中对应的下载字体 \n[https://github.com/yangbenbo/wps-font-symbols/archive/master.zip](https://github.com/yangbenbo/wps-font-symbols/archive/master.zip)\n\n\n# 引用\n1. [ps实用技能：如何统一裁剪图片大小](http://www.sohu.com/a/258392499_99914465)","slug":"实用小技巧汇总","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci40036mxka9v6gi8ab","content":"<h1 id=\"ps统一裁剪图片大小\"><a href=\"#ps统一裁剪图片大小\" class=\"headerlink\" title=\"ps统一裁剪图片大小\"></a>ps统一裁剪图片大小</h1><ol>\n<li>窗口-&gt;动作　显示动作面板，在历史记录面板里面</li>\n<li>新建动作组　录制动作</li>\n<li>文件-&gt;自动-&gt;批处理</li>\n</ol>\n<p><strong>注意事项</strong>：<br>点击选项打开切换对话开关　可以在处理自动处理工程在裁剪处停止　手动调整裁剪的位置的大小</p>\n<p><img src=\"/2019/10/20/实用小技巧汇总/切换对话开.png\" alt=\"打开切换对话\"> <img src=\"/2019/10/20/实用小技巧汇总/切换对话关.png\" alt=\"关闭切换对话\"></p>\n<h1 id=\"ps矫正扫描件-ppt\"><a href=\"#ps矫正扫描件-ppt\" class=\"headerlink\" title=\"ps矫正扫描件　ppt\"></a>ps矫正扫描件　ppt</h1><p>扫描件</p>\n<ul>\n<li>复制图层　填充为白色　拉直工具(在不改变图像大小的情况下拉直)</li>\n</ul>\n<p>ppt</p>\n<ul>\n<li>透视裁剪 </li>\n</ul>\n<h1 id=\"视屏调整大小\"><a href=\"#视屏调整大小\" class=\"headerlink\" title=\"视屏调整大小\"></a>视屏调整大小</h1><ul>\n<li>premiere 更改视频码率　选可变码率　</li>\n</ul>\n<p>码率：视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率</p>\n<ul>\n<li>固定码率：　</li>\n<li>可变码率：视频信源本身的高峰信息量是变化的，能按信源本身的信息量去分配，从而有效地利用信息资源。</li>\n</ul>\n<h1 id=\"存放小文件到github方便下载\"><a href=\"#存放小文件到github方便下载\" class=\"headerlink\" title=\"存放小文件到github方便下载\"></a>存放小文件到github方便下载</h1><p>仓库名网址/archive/master.zip 即可下载仓库内容 不用到仓库地址点击下载</p>\n<p>例如博客 <a href=\"/2019/12/22/ubuntu下wps缺少字体/\" title=\"ubuntu下wps缺少字体\">ubuntu下wps缺少字体</a> 中对应的下载字体<br><a href=\"https://github.com/yangbenbo/wps-font-symbols/archive/master.zip\" target=\"_blank\" rel=\"noopener\">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://www.sohu.com/a/258392499_99914465\" target=\"_blank\" rel=\"noopener\">ps实用技能：如何统一裁剪图片大小</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ps统一裁剪图片大小\"><a href=\"#ps统一裁剪图片大小\" class=\"headerlink\" title=\"ps统一裁剪图片大小\"></a>ps统一裁剪图片大小</h1><ol>\n<li>窗口-&gt;动作　显示动作面板，在历史记录面板里面</li>\n<li>新建动作组　录制动作</li>\n<li>文件-&gt;自动-&gt;批处理</li>\n</ol>\n<p><strong>注意事项</strong>：<br>点击选项打开切换对话开关　可以在处理自动处理工程在裁剪处停止　手动调整裁剪的位置的大小</p>\n<p><img src=\"/2019/10/20/实用小技巧汇总/切换对话开.png\" alt=\"打开切换对话\"> <img src=\"/2019/10/20/实用小技巧汇总/切换对话关.png\" alt=\"关闭切换对话\"></p>\n<h1 id=\"ps矫正扫描件-ppt\"><a href=\"#ps矫正扫描件-ppt\" class=\"headerlink\" title=\"ps矫正扫描件　ppt\"></a>ps矫正扫描件　ppt</h1><p>扫描件</p>\n<ul>\n<li>复制图层　填充为白色　拉直工具(在不改变图像大小的情况下拉直)</li>\n</ul>\n<p>ppt</p>\n<ul>\n<li>透视裁剪 </li>\n</ul>\n<h1 id=\"视屏调整大小\"><a href=\"#视屏调整大小\" class=\"headerlink\" title=\"视屏调整大小\"></a>视屏调整大小</h1><ul>\n<li>premiere 更改视频码率　选可变码率　</li>\n</ul>\n<p>码率：视频码率就是数据传输时单位时间传送的数据位数，一般我们用的单位是kbps即千位每秒。通俗一点的理解就是取样率</p>\n<ul>\n<li>固定码率：　</li>\n<li>可变码率：视频信源本身的高峰信息量是变化的，能按信源本身的信息量去分配，从而有效地利用信息资源。</li>\n</ul>\n<h1 id=\"存放小文件到github方便下载\"><a href=\"#存放小文件到github方便下载\" class=\"headerlink\" title=\"存放小文件到github方便下载\"></a>存放小文件到github方便下载</h1><p>仓库名网址/archive/master.zip 即可下载仓库内容 不用到仓库地址点击下载</p>\n<p>例如博客 <a href=\"/2019/12/22/ubuntu下wps缺少字体/\" title=\"ubuntu下wps缺少字体\">ubuntu下wps缺少字体</a> 中对应的下载字体<br><a href=\"https://github.com/yangbenbo/wps-font-symbols/archive/master.zip\" target=\"_blank\" rel=\"noopener\">https://github.com/yangbenbo/wps-font-symbols/archive/master.zip</a></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"http://www.sohu.com/a/258392499_99914465\" target=\"_blank\" rel=\"noopener\">ps实用技能：如何统一裁剪图片大小</a></li>\n</ol>\n"},{"title":"常用软件快捷键","date":"2019-10-07T11:57:38.000Z","_content":"# ubuntu\n有的需要自行设置　Setting->Keyboard->Shortcuts\n\n相比Windows快捷键,很多只是多增加了ctrl  \n  - shift+1 切换到左边工作区　\n  - ctrl+shift+1 把当前窗口移动到左边工作区 \n  - shift+2 切换到左边工作区　\n  - ctrl+shift+2 把当前窗口移动到右边工作区 \n\n# qtcreator\n自定义死快捷键:tools->options->environment->keyboard\n\n    Esc\t切换到代码编辑状态\n    F1\t查看帮助\n    F2\t在光标选中对象的声明和定义之间切换\n    F4\t头文件和源文件之间切换\n    F10\t单步跳过\n    F11\t单步进入\n    Ctrl + B\t编译工程\n    Ctrl + /\t多行注释/取消多行注释\n    \n    Alt + Enter\t将光标移动到h文件中的方法声明，按Alt+Enter，再按回车键将在cpp中添加对应的方法实体\n    \n    Ctrl + Shift + <\t折叠代码块\n    Ctrl + Shift + >\t展开代码块\n    Ctrl + Alt + .      全部折叠/展开代码(自定义)\n    Alt + 左\t光标返回到上一位置\n    Alt + 右\t光标前进到下一位置\n    Alt + [1-7]   快速打开对应窗口,和clion类似\n    \n    Ctrl + Shift + U\t查找所有使用该符号的地方\n    Ctrl + Shift + R\t局部变量统一修改（将光标移动到需要更改的变量上,按Ctrl+Shift+ R,当前变量名称外框为红色时,表示已经已激活全局修改功能,当修改此处变量名称时将一同修改代码中所有使用该变量的变量名。），全局变量开启全局替换窗口\n    Ctrl + I\t代码格式化\n    Ctrl + [\t跳到代码块的头部\n    Ctrl + ] \t跳到代码块的尾部\n\n# visual studio code\ncode自带快捷键\n\n    F1  打开命令面板\n    F12         跳转到引用\n    shift + F12 找到所用引用\n    alt + up/down   上下移动行\n       \n    ctrl + F    当前文件中查找\n    ctrl + shift + F    整个文件夹中查找\n    ctrl + B    侧边栏显隐(具体那一栏展开可以把鼠标放上去就可以看到快捷键)\n    ctrl + N    新建文件 可以现在资源管理器对应文件夹点一下,这样保存就会在这里\n    ctrl + shift + N    打开新窗口以打开多个文件夹项目\n    ctrl + u            回退到上一个光标操作\n    ctrl + shift L      选中当前文件所有匹配的字 同时修改 谨慎使用 不区分大小写\n    \n    # 自定义或者查看快捷键,有的快捷键和系统冲突了也要改\n    File -> Preferences -> Keyboard Shortcuts\ncode使用ipython,后缀名可以使.py\n    \n    # %% 指明是代码模块\n    # %% [markdown]  指明是markdown笔记模块 在正常笔记基础之上注释了而已,如下\n    \n    # %% [markdown]\n    # ## test markdown\n    # content    \n    \n    # 快捷键基本和code自带的一直\n    shift + Enter   运行当前节,如果在最后使用则会增加一节   \n    转格式为jupyter     右键保存为jupyter\n    \ncode运行jupyter,文件后缀名.ipynb,跳转一直没配置好\n    \n    # jupyter相关\n    Enter   转入编辑模式\n    \n    ESC     退出编辑模式\n    M       单元转入markdown模式\n    Y       单元转入代码模式\n    up/down 上下单元选择\n    A   上方插入新单元\n    B   下方插入新单元\n    D + D   删除当前单元\n    Alt + up/down   向上向下移动行\n    ctrl + shift + Alt + up/down   向上向下复制行\n    shift + delete  删除行\n    \n    shift + Enter   运行当前节并前进到下一节,如果到了最后一节会新建一节\n    ctrl + Enter    运行本单元\n\n    L       显示与隐藏单元行号\n    ctrl + H    单元内查找与替换\n    ctrl + shift + \\    调到匹配的括号\n**开启代码提示功能**\n\n文件-首选项-设置 中搜索“prevent”,取消选中“控制在活动代码片段内是否禁用快速建议”(Snippets Prevent Quick Suggestions),重启即可    \n    \n# chorme\n标签切换 ctrl+PgUp / ctrl+PgDn   (ctrl+Tab / ctrl+Shift+Tab)\n\n# matlab\n字符串拼接\n    \n    a = 'abc';\n    b = 'opq';\n    c = [a, b]; \n    title(['New reproductions with GMR r= ',num2str(r_length)]);  //画图title\n           \n\n# simulink\n打开模型浏览器： ctrl + shift + L\n\n视图放大：r\n\n视图缩小：v\n\n视图平铺到整个模型：空格/f\n\n回到默认视图：1\n\n用鼠标拖动视图：按住q或者p，用鼠标左键按住拖动。这个快捷键在视图比较大时候用到。\n\n更新模型：ctrl+D\n\n打开model explorer：ctrl+E\n\n仿真开始：ctrl+T\n\n查看simple time： ctrl+J\n# clion\n可以自行添加修改\nCtrl + Shift + D   //添加函数定义 Alt+Insert\nCtrl + Alt + home  // 设置->keymap->related symbol\n## debug\n鼠标放在变量上　查看变量值　ctrl+F1\n\nF9 选择调试程序\n\nshift+F9  //开始debug\n\nctrl+F9  //编译程序\n\nctrl+F2  //停止debug\n\nctrl+shift+F6    //evalute expression\n\nctrl+shift+S     //setting\n\nctrl+F8  //设置断点   ctrl+Shift+F8  断点详细设置　可以打开**异常断点**　抛出异常地方地址\n\n调试的时候可以直接设置变量值\n\n添加监视　watch\n\n评估表达　即计算表达式的值　可把表达式值添加到watch ctrl+shift+enter\n\n调试#define PR(x) cout << #x\"= \"<<x<<endl;      之后直接调用  PR(a) 等效于\ncout<<\"a= \"<<a<<endl;\n\n## 其他\nF5  //运行程序\n\nF10  //终止程序\n\nctrl+Tab+T  //调出clion终端\n\nctrl+D  //复制并粘贴对应行\n\nEsc  //光标退回到程序界面，配合Alt+1 使用\n\nctrl+Home  //页面初始位置 End  多结合Ctrl 使用\n\nctrl+PageUp  //当前显示页面初始  PageDown\n\nctrl+Shift+F  //查找  ctrl+F\n\n# QtCreator\n1. 帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法）\n\n2. .h 文件和对应.cpp 文件切换：F4\n\n3. 编译并运行：Ctrl + R\n\n4. 函数声明和定义(函数调用和定义)切换：F2\n\n5. 代码注释取消注释：Ctrl + / （选中代码再按快捷键）\n\n6. 字体变大变小：Ctrl + 鼠标滚轮向上向下\n\n7. 移动代码：选中所要移动的代码 -> 按住 ctrl + shift -> 键盘方向键\n\n8. 查找替换关键字：ctrl + f\n\n9. 快速打开代码所在目录：编辑模式下 -> 选中项目文件 -> 右击 -> 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录）\n# word\n\nAlt+Shift+ +　　　　　　扩展标题下的文本\n\nAlt+Shift+ -　　　　　　折叠标题下的文本\n\n# excel\nAlt+Enter             换行\n\n    \n# 引用\n1. [详细，Qt Creator快捷键大全，附快捷键配置方法](https://blog.csdn.net/desert187/article/details/23996821?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n2. [VSCode - Jupyter快捷键](https://www.cnblogs.com/gwzz/p/13385076.html)\n3. [在Visual Studio Code中使用Jupyter Notebook](https://blog.csdn.net/sinat_21835983/article/details/93896664)\n4. [VSCode+python中代码（函数）不提示的解决办法之一](https://blog.csdn.net/m0_37174192/article/details/99226127?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf)","source":"_posts/常用软件快捷键.md","raw":"---\ntitle: 常用软件快捷键\ndate: 2019-10-07 19:57:38\ncategories:\n- software\ntags:\n- 快捷键\n- simulink\n- clion\n- world\n- excel\n\n---\n# ubuntu\n有的需要自行设置　Setting->Keyboard->Shortcuts\n\n相比Windows快捷键,很多只是多增加了ctrl  \n  - shift+1 切换到左边工作区　\n  - ctrl+shift+1 把当前窗口移动到左边工作区 \n  - shift+2 切换到左边工作区　\n  - ctrl+shift+2 把当前窗口移动到右边工作区 \n\n# qtcreator\n自定义死快捷键:tools->options->environment->keyboard\n\n    Esc\t切换到代码编辑状态\n    F1\t查看帮助\n    F2\t在光标选中对象的声明和定义之间切换\n    F4\t头文件和源文件之间切换\n    F10\t单步跳过\n    F11\t单步进入\n    Ctrl + B\t编译工程\n    Ctrl + /\t多行注释/取消多行注释\n    \n    Alt + Enter\t将光标移动到h文件中的方法声明，按Alt+Enter，再按回车键将在cpp中添加对应的方法实体\n    \n    Ctrl + Shift + <\t折叠代码块\n    Ctrl + Shift + >\t展开代码块\n    Ctrl + Alt + .      全部折叠/展开代码(自定义)\n    Alt + 左\t光标返回到上一位置\n    Alt + 右\t光标前进到下一位置\n    Alt + [1-7]   快速打开对应窗口,和clion类似\n    \n    Ctrl + Shift + U\t查找所有使用该符号的地方\n    Ctrl + Shift + R\t局部变量统一修改（将光标移动到需要更改的变量上,按Ctrl+Shift+ R,当前变量名称外框为红色时,表示已经已激活全局修改功能,当修改此处变量名称时将一同修改代码中所有使用该变量的变量名。），全局变量开启全局替换窗口\n    Ctrl + I\t代码格式化\n    Ctrl + [\t跳到代码块的头部\n    Ctrl + ] \t跳到代码块的尾部\n\n# visual studio code\ncode自带快捷键\n\n    F1  打开命令面板\n    F12         跳转到引用\n    shift + F12 找到所用引用\n    alt + up/down   上下移动行\n       \n    ctrl + F    当前文件中查找\n    ctrl + shift + F    整个文件夹中查找\n    ctrl + B    侧边栏显隐(具体那一栏展开可以把鼠标放上去就可以看到快捷键)\n    ctrl + N    新建文件 可以现在资源管理器对应文件夹点一下,这样保存就会在这里\n    ctrl + shift + N    打开新窗口以打开多个文件夹项目\n    ctrl + u            回退到上一个光标操作\n    ctrl + shift L      选中当前文件所有匹配的字 同时修改 谨慎使用 不区分大小写\n    \n    # 自定义或者查看快捷键,有的快捷键和系统冲突了也要改\n    File -> Preferences -> Keyboard Shortcuts\ncode使用ipython,后缀名可以使.py\n    \n    # %% 指明是代码模块\n    # %% [markdown]  指明是markdown笔记模块 在正常笔记基础之上注释了而已,如下\n    \n    # %% [markdown]\n    # ## test markdown\n    # content    \n    \n    # 快捷键基本和code自带的一直\n    shift + Enter   运行当前节,如果在最后使用则会增加一节   \n    转格式为jupyter     右键保存为jupyter\n    \ncode运行jupyter,文件后缀名.ipynb,跳转一直没配置好\n    \n    # jupyter相关\n    Enter   转入编辑模式\n    \n    ESC     退出编辑模式\n    M       单元转入markdown模式\n    Y       单元转入代码模式\n    up/down 上下单元选择\n    A   上方插入新单元\n    B   下方插入新单元\n    D + D   删除当前单元\n    Alt + up/down   向上向下移动行\n    ctrl + shift + Alt + up/down   向上向下复制行\n    shift + delete  删除行\n    \n    shift + Enter   运行当前节并前进到下一节,如果到了最后一节会新建一节\n    ctrl + Enter    运行本单元\n\n    L       显示与隐藏单元行号\n    ctrl + H    单元内查找与替换\n    ctrl + shift + \\    调到匹配的括号\n**开启代码提示功能**\n\n文件-首选项-设置 中搜索“prevent”,取消选中“控制在活动代码片段内是否禁用快速建议”(Snippets Prevent Quick Suggestions),重启即可    \n    \n# chorme\n标签切换 ctrl+PgUp / ctrl+PgDn   (ctrl+Tab / ctrl+Shift+Tab)\n\n# matlab\n字符串拼接\n    \n    a = 'abc';\n    b = 'opq';\n    c = [a, b]; \n    title(['New reproductions with GMR r= ',num2str(r_length)]);  //画图title\n           \n\n# simulink\n打开模型浏览器： ctrl + shift + L\n\n视图放大：r\n\n视图缩小：v\n\n视图平铺到整个模型：空格/f\n\n回到默认视图：1\n\n用鼠标拖动视图：按住q或者p，用鼠标左键按住拖动。这个快捷键在视图比较大时候用到。\n\n更新模型：ctrl+D\n\n打开model explorer：ctrl+E\n\n仿真开始：ctrl+T\n\n查看simple time： ctrl+J\n# clion\n可以自行添加修改\nCtrl + Shift + D   //添加函数定义 Alt+Insert\nCtrl + Alt + home  // 设置->keymap->related symbol\n## debug\n鼠标放在变量上　查看变量值　ctrl+F1\n\nF9 选择调试程序\n\nshift+F9  //开始debug\n\nctrl+F9  //编译程序\n\nctrl+F2  //停止debug\n\nctrl+shift+F6    //evalute expression\n\nctrl+shift+S     //setting\n\nctrl+F8  //设置断点   ctrl+Shift+F8  断点详细设置　可以打开**异常断点**　抛出异常地方地址\n\n调试的时候可以直接设置变量值\n\n添加监视　watch\n\n评估表达　即计算表达式的值　可把表达式值添加到watch ctrl+shift+enter\n\n调试#define PR(x) cout << #x\"= \"<<x<<endl;      之后直接调用  PR(a) 等效于\ncout<<\"a= \"<<a<<endl;\n\n## 其他\nF5  //运行程序\n\nF10  //终止程序\n\nctrl+Tab+T  //调出clion终端\n\nctrl+D  //复制并粘贴对应行\n\nEsc  //光标退回到程序界面，配合Alt+1 使用\n\nctrl+Home  //页面初始位置 End  多结合Ctrl 使用\n\nctrl+PageUp  //当前显示页面初始  PageDown\n\nctrl+Shift+F  //查找  ctrl+F\n\n# QtCreator\n1. 帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法）\n\n2. .h 文件和对应.cpp 文件切换：F4\n\n3. 编译并运行：Ctrl + R\n\n4. 函数声明和定义(函数调用和定义)切换：F2\n\n5. 代码注释取消注释：Ctrl + / （选中代码再按快捷键）\n\n6. 字体变大变小：Ctrl + 鼠标滚轮向上向下\n\n7. 移动代码：选中所要移动的代码 -> 按住 ctrl + shift -> 键盘方向键\n\n8. 查找替换关键字：ctrl + f\n\n9. 快速打开代码所在目录：编辑模式下 -> 选中项目文件 -> 右击 -> 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录）\n# word\n\nAlt+Shift+ +　　　　　　扩展标题下的文本\n\nAlt+Shift+ -　　　　　　折叠标题下的文本\n\n# excel\nAlt+Enter             换行\n\n    \n# 引用\n1. [详细，Qt Creator快捷键大全，附快捷键配置方法](https://blog.csdn.net/desert187/article/details/23996821?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)\n2. [VSCode - Jupyter快捷键](https://www.cnblogs.com/gwzz/p/13385076.html)\n3. [在Visual Studio Code中使用Jupyter Notebook](https://blog.csdn.net/sinat_21835983/article/details/93896664)\n4. [VSCode+python中代码（函数）不提示的解决办法之一](https://blog.csdn.net/m0_37174192/article/details/99226127?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf)","slug":"常用软件快捷键","published":1,"updated":"2020-11-15T09:33:12.075Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci5003bmxkazy4jkhvd","content":"<h1 id=\"ubuntu\"><a href=\"#ubuntu\" class=\"headerlink\" title=\"ubuntu\"></a>ubuntu</h1><p>有的需要自行设置　Setting-&gt;Keyboard-&gt;Shortcuts</p>\n<p>相比Windows快捷键,很多只是多增加了ctrl  </p>\n<ul>\n<li>shift+1 切换到左边工作区　</li>\n<li>ctrl+shift+1 把当前窗口移动到左边工作区 </li>\n<li>shift+2 切换到左边工作区　</li>\n<li>ctrl+shift+2 把当前窗口移动到右边工作区 </li>\n</ul>\n<h1 id=\"qtcreator\"><a href=\"#qtcreator\" class=\"headerlink\" title=\"qtcreator\"></a>qtcreator</h1><p>自定义死快捷键:tools-&gt;options-&gt;environment-&gt;keyboard</p>\n<pre><code>Esc    切换到代码编辑状态\nF1    查看帮助\nF2    在光标选中对象的声明和定义之间切换\nF4    头文件和源文件之间切换\nF10    单步跳过\nF11    单步进入\nCtrl + B    编译工程\nCtrl + /    多行注释/取消多行注释\n\nAlt + Enter    将光标移动到h文件中的方法声明，按Alt+Enter，再按回车键将在cpp中添加对应的方法实体\n\nCtrl + Shift + &lt;    折叠代码块\nCtrl + Shift + &gt;    展开代码块\nCtrl + Alt + .      全部折叠/展开代码(自定义)\nAlt + 左    光标返回到上一位置\nAlt + 右    光标前进到下一位置\nAlt + [1-7]   快速打开对应窗口,和clion类似\n\nCtrl + Shift + U    查找所有使用该符号的地方\nCtrl + Shift + R    局部变量统一修改（将光标移动到需要更改的变量上,按Ctrl+Shift+ R,当前变量名称外框为红色时,表示已经已激活全局修改功能,当修改此处变量名称时将一同修改代码中所有使用该变量的变量名。），全局变量开启全局替换窗口\nCtrl + I    代码格式化\nCtrl + [    跳到代码块的头部\nCtrl + ]     跳到代码块的尾部\n</code></pre><h1 id=\"visual-studio-code\"><a href=\"#visual-studio-code\" class=\"headerlink\" title=\"visual studio code\"></a>visual studio code</h1><p>code自带快捷键</p>\n<pre><code>F1  打开命令面板\nF12         跳转到引用\nshift + F12 找到所用引用\nalt + up/down   上下移动行\n\nctrl + F    当前文件中查找\nctrl + shift + F    整个文件夹中查找\nctrl + B    侧边栏显隐(具体那一栏展开可以把鼠标放上去就可以看到快捷键)\nctrl + N    新建文件 可以现在资源管理器对应文件夹点一下,这样保存就会在这里\nctrl + shift + N    打开新窗口以打开多个文件夹项目\nctrl + u            回退到上一个光标操作\nctrl + shift L      选中当前文件所有匹配的字 同时修改 谨慎使用 不区分大小写\n\n# 自定义或者查看快捷键,有的快捷键和系统冲突了也要改\nFile -&gt; Preferences -&gt; Keyboard Shortcuts\n</code></pre><p>code使用ipython,后缀名可以使.py</p>\n<pre><code># %% 指明是代码模块\n# %% [markdown]  指明是markdown笔记模块 在正常笔记基础之上注释了而已,如下\n\n# %% [markdown]\n# ## test markdown\n# content    \n\n# 快捷键基本和code自带的一直\nshift + Enter   运行当前节,如果在最后使用则会增加一节   \n转格式为jupyter     右键保存为jupyter\n</code></pre><p>code运行jupyter,文件后缀名.ipynb,跳转一直没配置好</p>\n<pre><code># jupyter相关\nEnter   转入编辑模式\n\nESC     退出编辑模式\nM       单元转入markdown模式\nY       单元转入代码模式\nup/down 上下单元选择\nA   上方插入新单元\nB   下方插入新单元\nD + D   删除当前单元\nAlt + up/down   向上向下移动行\nctrl + shift + Alt + up/down   向上向下复制行\nshift + delete  删除行\n\nshift + Enter   运行当前节并前进到下一节,如果到了最后一节会新建一节\nctrl + Enter    运行本单元\n\nL       显示与隐藏单元行号\nctrl + H    单元内查找与替换\nctrl + shift + \\    调到匹配的括号\n</code></pre><p><strong>开启代码提示功能</strong></p>\n<p>文件-首选项-设置 中搜索“prevent”,取消选中“控制在活动代码片段内是否禁用快速建议”(Snippets Prevent Quick Suggestions),重启即可    </p>\n<h1 id=\"chorme\"><a href=\"#chorme\" class=\"headerlink\" title=\"chorme\"></a>chorme</h1><p>标签切换 ctrl+PgUp / ctrl+PgDn   (ctrl+Tab / ctrl+Shift+Tab)</p>\n<h1 id=\"matlab\"><a href=\"#matlab\" class=\"headerlink\" title=\"matlab\"></a>matlab</h1><p>字符串拼接</p>\n<pre><code>a = &#39;abc&#39;;\nb = &#39;opq&#39;;\nc = [a, b]; \ntitle([&#39;New reproductions with GMR r= &#39;,num2str(r_length)]);  //画图title\n</code></pre><h1 id=\"simulink\"><a href=\"#simulink\" class=\"headerlink\" title=\"simulink\"></a>simulink</h1><p>打开模型浏览器： ctrl + shift + L</p>\n<p>视图放大：r</p>\n<p>视图缩小：v</p>\n<p>视图平铺到整个模型：空格/f</p>\n<p>回到默认视图：1</p>\n<p>用鼠标拖动视图：按住q或者p，用鼠标左键按住拖动。这个快捷键在视图比较大时候用到。</p>\n<p>更新模型：ctrl+D</p>\n<p>打开model explorer：ctrl+E</p>\n<p>仿真开始：ctrl+T</p>\n<p>查看simple time： ctrl+J</p>\n<h1 id=\"clion\"><a href=\"#clion\" class=\"headerlink\" title=\"clion\"></a>clion</h1><p>可以自行添加修改<br>Ctrl + Shift + D   //添加函数定义 Alt+Insert<br>Ctrl + Alt + home  // 设置-&gt;keymap-&gt;related symbol</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>鼠标放在变量上　查看变量值　ctrl+F1</p>\n<p>F9 选择调试程序</p>\n<p>shift+F9  //开始debug</p>\n<p>ctrl+F9  //编译程序</p>\n<p>ctrl+F2  //停止debug</p>\n<p>ctrl+shift+F6    //evalute expression</p>\n<p>ctrl+shift+S     //setting</p>\n<p>ctrl+F8  //设置断点   ctrl+Shift+F8  断点详细设置　可以打开<strong>异常断点</strong>　抛出异常地方地址</p>\n<p>调试的时候可以直接设置变量值</p>\n<p>添加监视　watch</p>\n<p>评估表达　即计算表达式的值　可把表达式值添加到watch ctrl+shift+enter</p>\n<p>调试#define PR(x) cout &lt;&lt; #x”= “&lt;&lt;x&lt;&lt;endl;      之后直接调用  PR(a) 等效于<br>cout&lt;&lt;”a= “&lt;&lt;a&lt;&lt;endl;</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>F5  //运行程序</p>\n<p>F10  //终止程序</p>\n<p>ctrl+Tab+T  //调出clion终端</p>\n<p>ctrl+D  //复制并粘贴对应行</p>\n<p>Esc  //光标退回到程序界面，配合Alt+1 使用</p>\n<p>ctrl+Home  //页面初始位置 End  多结合Ctrl 使用</p>\n<p>ctrl+PageUp  //当前显示页面初始  PageDown</p>\n<p>ctrl+Shift+F  //查找  ctrl+F</p>\n<h1 id=\"QtCreator\"><a href=\"#QtCreator\" class=\"headerlink\" title=\"QtCreator\"></a>QtCreator</h1><ol>\n<li><p>帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法）</p>\n</li>\n<li><p>.h 文件和对应.cpp 文件切换：F4</p>\n</li>\n<li><p>编译并运行：Ctrl + R</p>\n</li>\n<li><p>函数声明和定义(函数调用和定义)切换：F2</p>\n</li>\n<li><p>代码注释取消注释：Ctrl + / （选中代码再按快捷键）</p>\n</li>\n<li><p>字体变大变小：Ctrl + 鼠标滚轮向上向下</p>\n</li>\n<li><p>移动代码：选中所要移动的代码 -&gt; 按住 ctrl + shift -&gt; 键盘方向键</p>\n</li>\n<li><p>查找替换关键字：ctrl + f</p>\n</li>\n<li><p>快速打开代码所在目录：编辑模式下 -&gt; 选中项目文件 -&gt; 右击 -&gt; 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录）</p>\n<h1 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h1></li>\n</ol>\n<p>Alt+Shift+ +　　　　　　扩展标题下的文本</p>\n<p>Alt+Shift+ -　　　　　　折叠标题下的文本</p>\n<h1 id=\"excel\"><a href=\"#excel\" class=\"headerlink\" title=\"excel\"></a>excel</h1><p>Alt+Enter             换行</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/desert187/article/details/23996821?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">详细，Qt Creator快捷键大全，附快捷键配置方法</a></li>\n<li><a href=\"https://www.cnblogs.com/gwzz/p/13385076.html\" target=\"_blank\" rel=\"noopener\">VSCode - Jupyter快捷键</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_21835983/article/details/93896664\" target=\"_blank\" rel=\"noopener\">在Visual Studio Code中使用Jupyter Notebook</a></li>\n<li><a href=\"https://blog.csdn.net/m0_37174192/article/details/99226127?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf\" target=\"_blank\" rel=\"noopener\">VSCode+python中代码（函数）不提示的解决办法之一</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ubuntu\"><a href=\"#ubuntu\" class=\"headerlink\" title=\"ubuntu\"></a>ubuntu</h1><p>有的需要自行设置　Setting-&gt;Keyboard-&gt;Shortcuts</p>\n<p>相比Windows快捷键,很多只是多增加了ctrl  </p>\n<ul>\n<li>shift+1 切换到左边工作区　</li>\n<li>ctrl+shift+1 把当前窗口移动到左边工作区 </li>\n<li>shift+2 切换到左边工作区　</li>\n<li>ctrl+shift+2 把当前窗口移动到右边工作区 </li>\n</ul>\n<h1 id=\"qtcreator\"><a href=\"#qtcreator\" class=\"headerlink\" title=\"qtcreator\"></a>qtcreator</h1><p>自定义死快捷键:tools-&gt;options-&gt;environment-&gt;keyboard</p>\n<pre><code>Esc    切换到代码编辑状态\nF1    查看帮助\nF2    在光标选中对象的声明和定义之间切换\nF4    头文件和源文件之间切换\nF10    单步跳过\nF11    单步进入\nCtrl + B    编译工程\nCtrl + /    多行注释/取消多行注释\n\nAlt + Enter    将光标移动到h文件中的方法声明，按Alt+Enter，再按回车键将在cpp中添加对应的方法实体\n\nCtrl + Shift + &lt;    折叠代码块\nCtrl + Shift + &gt;    展开代码块\nCtrl + Alt + .      全部折叠/展开代码(自定义)\nAlt + 左    光标返回到上一位置\nAlt + 右    光标前进到下一位置\nAlt + [1-7]   快速打开对应窗口,和clion类似\n\nCtrl + Shift + U    查找所有使用该符号的地方\nCtrl + Shift + R    局部变量统一修改（将光标移动到需要更改的变量上,按Ctrl+Shift+ R,当前变量名称外框为红色时,表示已经已激活全局修改功能,当修改此处变量名称时将一同修改代码中所有使用该变量的变量名。），全局变量开启全局替换窗口\nCtrl + I    代码格式化\nCtrl + [    跳到代码块的头部\nCtrl + ]     跳到代码块的尾部\n</code></pre><h1 id=\"visual-studio-code\"><a href=\"#visual-studio-code\" class=\"headerlink\" title=\"visual studio code\"></a>visual studio code</h1><p>code自带快捷键</p>\n<pre><code>F1  打开命令面板\nF12         跳转到引用\nshift + F12 找到所用引用\nalt + up/down   上下移动行\n\nctrl + F    当前文件中查找\nctrl + shift + F    整个文件夹中查找\nctrl + B    侧边栏显隐(具体那一栏展开可以把鼠标放上去就可以看到快捷键)\nctrl + N    新建文件 可以现在资源管理器对应文件夹点一下,这样保存就会在这里\nctrl + shift + N    打开新窗口以打开多个文件夹项目\nctrl + u            回退到上一个光标操作\nctrl + shift L      选中当前文件所有匹配的字 同时修改 谨慎使用 不区分大小写\n\n# 自定义或者查看快捷键,有的快捷键和系统冲突了也要改\nFile -&gt; Preferences -&gt; Keyboard Shortcuts\n</code></pre><p>code使用ipython,后缀名可以使.py</p>\n<pre><code># %% 指明是代码模块\n# %% [markdown]  指明是markdown笔记模块 在正常笔记基础之上注释了而已,如下\n\n# %% [markdown]\n# ## test markdown\n# content    \n\n# 快捷键基本和code自带的一直\nshift + Enter   运行当前节,如果在最后使用则会增加一节   \n转格式为jupyter     右键保存为jupyter\n</code></pre><p>code运行jupyter,文件后缀名.ipynb,跳转一直没配置好</p>\n<pre><code># jupyter相关\nEnter   转入编辑模式\n\nESC     退出编辑模式\nM       单元转入markdown模式\nY       单元转入代码模式\nup/down 上下单元选择\nA   上方插入新单元\nB   下方插入新单元\nD + D   删除当前单元\nAlt + up/down   向上向下移动行\nctrl + shift + Alt + up/down   向上向下复制行\nshift + delete  删除行\n\nshift + Enter   运行当前节并前进到下一节,如果到了最后一节会新建一节\nctrl + Enter    运行本单元\n\nL       显示与隐藏单元行号\nctrl + H    单元内查找与替换\nctrl + shift + \\    调到匹配的括号\n</code></pre><p><strong>开启代码提示功能</strong></p>\n<p>文件-首选项-设置 中搜索“prevent”,取消选中“控制在活动代码片段内是否禁用快速建议”(Snippets Prevent Quick Suggestions),重启即可    </p>\n<h1 id=\"chorme\"><a href=\"#chorme\" class=\"headerlink\" title=\"chorme\"></a>chorme</h1><p>标签切换 ctrl+PgUp / ctrl+PgDn   (ctrl+Tab / ctrl+Shift+Tab)</p>\n<h1 id=\"matlab\"><a href=\"#matlab\" class=\"headerlink\" title=\"matlab\"></a>matlab</h1><p>字符串拼接</p>\n<pre><code>a = &#39;abc&#39;;\nb = &#39;opq&#39;;\nc = [a, b]; \ntitle([&#39;New reproductions with GMR r= &#39;,num2str(r_length)]);  //画图title\n</code></pre><h1 id=\"simulink\"><a href=\"#simulink\" class=\"headerlink\" title=\"simulink\"></a>simulink</h1><p>打开模型浏览器： ctrl + shift + L</p>\n<p>视图放大：r</p>\n<p>视图缩小：v</p>\n<p>视图平铺到整个模型：空格/f</p>\n<p>回到默认视图：1</p>\n<p>用鼠标拖动视图：按住q或者p，用鼠标左键按住拖动。这个快捷键在视图比较大时候用到。</p>\n<p>更新模型：ctrl+D</p>\n<p>打开model explorer：ctrl+E</p>\n<p>仿真开始：ctrl+T</p>\n<p>查看simple time： ctrl+J</p>\n<h1 id=\"clion\"><a href=\"#clion\" class=\"headerlink\" title=\"clion\"></a>clion</h1><p>可以自行添加修改<br>Ctrl + Shift + D   //添加函数定义 Alt+Insert<br>Ctrl + Alt + home  // 设置-&gt;keymap-&gt;related symbol</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>鼠标放在变量上　查看变量值　ctrl+F1</p>\n<p>F9 选择调试程序</p>\n<p>shift+F9  //开始debug</p>\n<p>ctrl+F9  //编译程序</p>\n<p>ctrl+F2  //停止debug</p>\n<p>ctrl+shift+F6    //evalute expression</p>\n<p>ctrl+shift+S     //setting</p>\n<p>ctrl+F8  //设置断点   ctrl+Shift+F8  断点详细设置　可以打开<strong>异常断点</strong>　抛出异常地方地址</p>\n<p>调试的时候可以直接设置变量值</p>\n<p>添加监视　watch</p>\n<p>评估表达　即计算表达式的值　可把表达式值添加到watch ctrl+shift+enter</p>\n<p>调试#define PR(x) cout &lt;&lt; #x”= “&lt;&lt;x&lt;&lt;endl;      之后直接调用  PR(a) 等效于<br>cout&lt;&lt;”a= “&lt;&lt;a&lt;&lt;endl;</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>F5  //运行程序</p>\n<p>F10  //终止程序</p>\n<p>ctrl+Tab+T  //调出clion终端</p>\n<p>ctrl+D  //复制并粘贴对应行</p>\n<p>Esc  //光标退回到程序界面，配合Alt+1 使用</p>\n<p>ctrl+Home  //页面初始位置 End  多结合Ctrl 使用</p>\n<p>ctrl+PageUp  //当前显示页面初始  PageDown</p>\n<p>ctrl+Shift+F  //查找  ctrl+F</p>\n<h1 id=\"QtCreator\"><a href=\"#QtCreator\" class=\"headerlink\" title=\"QtCreator\"></a>QtCreator</h1><ol>\n<li><p>帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法）</p>\n</li>\n<li><p>.h 文件和对应.cpp 文件切换：F4</p>\n</li>\n<li><p>编译并运行：Ctrl + R</p>\n</li>\n<li><p>函数声明和定义(函数调用和定义)切换：F2</p>\n</li>\n<li><p>代码注释取消注释：Ctrl + / （选中代码再按快捷键）</p>\n</li>\n<li><p>字体变大变小：Ctrl + 鼠标滚轮向上向下</p>\n</li>\n<li><p>移动代码：选中所要移动的代码 -&gt; 按住 ctrl + shift -&gt; 键盘方向键</p>\n</li>\n<li><p>查找替换关键字：ctrl + f</p>\n</li>\n<li><p>快速打开代码所在目录：编辑模式下 -&gt; 选中项目文件 -&gt; 右击 -&gt; 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录）</p>\n<h1 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h1></li>\n</ol>\n<p>Alt+Shift+ +　　　　　　扩展标题下的文本</p>\n<p>Alt+Shift+ -　　　　　　折叠标题下的文本</p>\n<h1 id=\"excel\"><a href=\"#excel\" class=\"headerlink\" title=\"excel\"></a>excel</h1><p>Alt+Enter             换行</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/desert187/article/details/23996821?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">详细，Qt Creator快捷键大全，附快捷键配置方法</a></li>\n<li><a href=\"https://www.cnblogs.com/gwzz/p/13385076.html\" target=\"_blank\" rel=\"noopener\">VSCode - Jupyter快捷键</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_21835983/article/details/93896664\" target=\"_blank\" rel=\"noopener\">在Visual Studio Code中使用Jupyter Notebook</a></li>\n<li><a href=\"https://blog.csdn.net/m0_37174192/article/details/99226127?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.add_param_isCf\" target=\"_blank\" rel=\"noopener\">VSCode+python中代码（函数）不提示的解决办法之一</a></li>\n</ol>\n"},{"title":"惯性张量","date":"2019-12-30T13:39:22.000Z","mathjax":true,"_content":"\n# 转动惯量\n转动惯量又称惯性矩\n\n转动惯量是一个物体对于其旋转运动的惯性大小的量度.\n转动惯量在转动力学中的角色相当于线性动力学中的质量,\n描述角动量、角速度、力矩和角加速度等数个量之间的关系.\n\n# 惯性张量\n\n直角坐标系${O_{xyz}}$ 中,一个刚体的转动惯量为\n\n$$\n\\mathbf{I}=\\left[\\begin{array}{lll}\n{I_{x x}} & {I_{x y}} & {I_{x z}} \\\\\n{I_{y x}} & {I_{y y}} & {I_{y z}} \\\\\n{I_{z x}} & {I_{z y}} & {I_{z z}}\n\\end{array}\\right]\n$$\n\n其中**转动惯量**\n$$\n\\begin{aligned}\n&I_{x x} \\stackrel{\\text { def }}{=} \\int\\left(y^{2}+z^{2}\\right) d m\\\\\n&I_{y y} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+z^{2}\\right) d m\\\\\n&I_{z z} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+y^{2}\\right) d m\\\n\\end{aligned}\n$$\n\n矩阵对角元素,**惯性积**,有时候惯性矩前面没有负号\n$$\n\\begin{aligned}\n&I_{x y}=I_{y x} \\stackrel{\\text { def }}{=}-\\int x y d m\\\\\n&I_{x z}=I_{z x} \\stackrel{\\text { def }}{=}-\\int x z d m\\\\\n&I_{y z}=I_{z y} \\stackrel{\\text { def }}{=}-\\int y z d m\\\n\\end{aligned}\n$$\n\n选取坐标系姿态使得惯性积为0,则对这个坐标系,惯性张量是对角型的,\n此坐标系称为惯性主轴,相应的惯性矩为主惯性矩\n\n## 伪惯性矩阵\n$$\n\\overline{\\mathbf{I}}=\\iiint_{V} \\mathbf{r r}^{\\mathrm{T}} \\mathrm{d} m\n$$\n式中r为行向量\\[x y z 1]\n\n$$\n\\overline{\\mathbf{I}}=\\iiint_{V}\\left[\\begin{array}{cccc}\n{x^{2}} & {x y} & {x z} & {x} \\\\\n{x y} & {y^{2}} & {y z} & {y} \\\\\n{x z} & {y z} & {z^{2}} & {z} \\\\\n{x} & {y} & {z} & {1}\n\\end{array}\\right] \\mathrm{d} m\n$$\n \n\n## 惯性张量性质\n\n1. 坐标系姿态改变时,若A与C共原点,则$^{A} \\mathbf{I}=_{C}^{A} \\mathbf{R}^{C} \\mathbf{I}_{C}^{A} \\mathbf{R}^{\\mathrm{T}}$\n2. 惯性张量的特征值和特征向量分别是刚体对应的主惯性矩和惯性主轴\n\n可用平行移轴矢量形式和定义证明\n$$\n^{A} \\mathbf{I}=^{C} \\mathbf{I}+m\\left(\\mathbf{p}_{c}^{\\mathrm{T}} \\mathbf{p}_{c} \\mathbf{I}_{3}-\\mathbf{p}_{c} \\mathbf{p}_{c}^{\\mathrm{T}}\\right)\n$$\n\n\n\n式中 Pc为行量 [x y z]\n\n# 引用\n1. [转动惯量](https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F#%E6%85%A3%E6%80%A7%E5%BC%B5%E9%87%8F)\n2. [干货 | 机械臂的动力学（一）：牛顿欧拉法](https://mp.weixin.qq.com/s/dkOxmuTzOasvOZoMTH2nQg)\n3. [刚体质量分布与牛顿-欧拉方程](https://www.cnblogs.com/21207-iHome/p/7765508.html)\n4. 机器人学 建模 控制与视觉 熊友伦 华中科技大学出版社\n5. [Modern Robotics mechanics,planning,and control](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)\n","source":"_posts/惯性张量.md","raw":"---\ntitle: 惯性张量\ndate: 2019-12-30 21:39:22\ncategories:\n- math\ntags:\n- 机器人学\nmathjax: true\n---\n\n# 转动惯量\n转动惯量又称惯性矩\n\n转动惯量是一个物体对于其旋转运动的惯性大小的量度.\n转动惯量在转动力学中的角色相当于线性动力学中的质量,\n描述角动量、角速度、力矩和角加速度等数个量之间的关系.\n\n# 惯性张量\n\n直角坐标系${O_{xyz}}$ 中,一个刚体的转动惯量为\n\n$$\n\\mathbf{I}=\\left[\\begin{array}{lll}\n{I_{x x}} & {I_{x y}} & {I_{x z}} \\\\\n{I_{y x}} & {I_{y y}} & {I_{y z}} \\\\\n{I_{z x}} & {I_{z y}} & {I_{z z}}\n\\end{array}\\right]\n$$\n\n其中**转动惯量**\n$$\n\\begin{aligned}\n&I_{x x} \\stackrel{\\text { def }}{=} \\int\\left(y^{2}+z^{2}\\right) d m\\\\\n&I_{y y} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+z^{2}\\right) d m\\\\\n&I_{z z} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+y^{2}\\right) d m\\\n\\end{aligned}\n$$\n\n矩阵对角元素,**惯性积**,有时候惯性矩前面没有负号\n$$\n\\begin{aligned}\n&I_{x y}=I_{y x} \\stackrel{\\text { def }}{=}-\\int x y d m\\\\\n&I_{x z}=I_{z x} \\stackrel{\\text { def }}{=}-\\int x z d m\\\\\n&I_{y z}=I_{z y} \\stackrel{\\text { def }}{=}-\\int y z d m\\\n\\end{aligned}\n$$\n\n选取坐标系姿态使得惯性积为0,则对这个坐标系,惯性张量是对角型的,\n此坐标系称为惯性主轴,相应的惯性矩为主惯性矩\n\n## 伪惯性矩阵\n$$\n\\overline{\\mathbf{I}}=\\iiint_{V} \\mathbf{r r}^{\\mathrm{T}} \\mathrm{d} m\n$$\n式中r为行向量\\[x y z 1]\n\n$$\n\\overline{\\mathbf{I}}=\\iiint_{V}\\left[\\begin{array}{cccc}\n{x^{2}} & {x y} & {x z} & {x} \\\\\n{x y} & {y^{2}} & {y z} & {y} \\\\\n{x z} & {y z} & {z^{2}} & {z} \\\\\n{x} & {y} & {z} & {1}\n\\end{array}\\right] \\mathrm{d} m\n$$\n \n\n## 惯性张量性质\n\n1. 坐标系姿态改变时,若A与C共原点,则$^{A} \\mathbf{I}=_{C}^{A} \\mathbf{R}^{C} \\mathbf{I}_{C}^{A} \\mathbf{R}^{\\mathrm{T}}$\n2. 惯性张量的特征值和特征向量分别是刚体对应的主惯性矩和惯性主轴\n\n可用平行移轴矢量形式和定义证明\n$$\n^{A} \\mathbf{I}=^{C} \\mathbf{I}+m\\left(\\mathbf{p}_{c}^{\\mathrm{T}} \\mathbf{p}_{c} \\mathbf{I}_{3}-\\mathbf{p}_{c} \\mathbf{p}_{c}^{\\mathrm{T}}\\right)\n$$\n\n\n\n式中 Pc为行量 [x y z]\n\n# 引用\n1. [转动惯量](https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F#%E6%85%A3%E6%80%A7%E5%BC%B5%E9%87%8F)\n2. [干货 | 机械臂的动力学（一）：牛顿欧拉法](https://mp.weixin.qq.com/s/dkOxmuTzOasvOZoMTH2nQg)\n3. [刚体质量分布与牛顿-欧拉方程](https://www.cnblogs.com/21207-iHome/p/7765508.html)\n4. 机器人学 建模 控制与视觉 熊友伦 华中科技大学出版社\n5. [Modern Robotics mechanics,planning,and control](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)\n","slug":"惯性张量","published":1,"updated":"2020-11-14T08:03:18.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci6003dmxkalja31e75","content":"<h1 id=\"转动惯量\"><a href=\"#转动惯量\" class=\"headerlink\" title=\"转动惯量\"></a>转动惯量</h1><p>转动惯量又称惯性矩</p>\n<p>转动惯量是一个物体对于其旋转运动的惯性大小的量度.<br>转动惯量在转动力学中的角色相当于线性动力学中的质量,<br>描述角动量、角速度、力矩和角加速度等数个量之间的关系.</p>\n<h1 id=\"惯性张量\"><a href=\"#惯性张量\" class=\"headerlink\" title=\"惯性张量\"></a>惯性张量</h1><p>直角坐标系${O_{xyz}}$ 中,一个刚体的转动惯量为</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{I}=\\left[\\begin{array}{lll}\n{I_{x x}} & {I_{x y}} & {I_{x z}} \\\\\n{I_{y x}} & {I_{y y}} & {I_{y z}} \\\\\n{I_{z x}} & {I_{z y}} & {I_{z z}}\n\\end{array}\\right]</script><p>其中<strong>转动惯量</strong></p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&I_{x x} \\stackrel{\\text { def }}{=} \\int\\left(y^{2}+z^{2}\\right) d m\\\\\n&I_{y y} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+z^{2}\\right) d m\\\\\n&I_{z z} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+y^{2}\\right) d m\\\n\\end{aligned}</script><p>矩阵对角元素,<strong>惯性积</strong>,有时候惯性矩前面没有负号</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&I_{x y}=I_{y x} \\stackrel{\\text { def }}{=}-\\int x y d m\\\\\n&I_{x z}=I_{z x} \\stackrel{\\text { def }}{=}-\\int x z d m\\\\\n&I_{y z}=I_{z y} \\stackrel{\\text { def }}{=}-\\int y z d m\\\n\\end{aligned}</script><p>选取坐标系姿态使得惯性积为0,则对这个坐标系,惯性张量是对角型的,<br>此坐标系称为惯性主轴,相应的惯性矩为主惯性矩</p>\n<h2 id=\"伪惯性矩阵\"><a href=\"#伪惯性矩阵\" class=\"headerlink\" title=\"伪惯性矩阵\"></a>伪惯性矩阵</h2><script type=\"math/tex; mode=display\">\n\\overline{\\mathbf{I}}=\\iiint_{V} \\mathbf{r r}^{\\mathrm{T}} \\mathrm{d} m</script><p>式中r为行向量[x y z 1]</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\mathbf{I}}=\\iiint_{V}\\left[\\begin{array}{cccc}\n{x^{2}} & {x y} & {x z} & {x} \\\\\n{x y} & {y^{2}} & {y z} & {y} \\\\\n{x z} & {y z} & {z^{2}} & {z} \\\\\n{x} & {y} & {z} & {1}\n\\end{array}\\right] \\mathrm{d} m</script><h2 id=\"惯性张量性质\"><a href=\"#惯性张量性质\" class=\"headerlink\" title=\"惯性张量性质\"></a>惯性张量性质</h2><ol>\n<li>坐标系姿态改变时,若A与C共原点,则$^{A} \\mathbf{I}=_{C}^{A} \\mathbf{R}^{C} \\mathbf{I}_{C}^{A} \\mathbf{R}^{\\mathrm{T}}$</li>\n<li>惯性张量的特征值和特征向量分别是刚体对应的主惯性矩和惯性主轴</li>\n</ol>\n<p>可用平行移轴矢量形式和定义证明</p>\n<script type=\"math/tex; mode=display\">\n^{A} \\mathbf{I}=^{C} \\mathbf{I}+m\\left(\\mathbf{p}_{c}^{\\mathrm{T}} \\mathbf{p}_{c} \\mathbf{I}_{3}-\\mathbf{p}_{c} \\mathbf{p}_{c}^{\\mathrm{T}}\\right)</script><p>式中 Pc为行量 [x y z]</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F#%E6%85%A3%E6%80%A7%E5%BC%B5%E9%87%8F\" target=\"_blank\" rel=\"noopener\">转动惯量</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/dkOxmuTzOasvOZoMTH2nQg\" target=\"_blank\" rel=\"noopener\">干货 | 机械臂的动力学（一）：牛顿欧拉法</a></li>\n<li><a href=\"https://www.cnblogs.com/21207-iHome/p/7765508.html\" target=\"_blank\" rel=\"noopener\">刚体质量分布与牛顿-欧拉方程</a></li>\n<li>机器人学 建模 控制与视觉 熊友伦 华中科技大学出版社</li>\n<li><a href=\"http://hades.mech.northwestern.edu/index.php/Modern_Robotics\" target=\"_blank\" rel=\"noopener\">Modern Robotics mechanics,planning,and control</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"转动惯量\"><a href=\"#转动惯量\" class=\"headerlink\" title=\"转动惯量\"></a>转动惯量</h1><p>转动惯量又称惯性矩</p>\n<p>转动惯量是一个物体对于其旋转运动的惯性大小的量度.<br>转动惯量在转动力学中的角色相当于线性动力学中的质量,<br>描述角动量、角速度、力矩和角加速度等数个量之间的关系.</p>\n<h1 id=\"惯性张量\"><a href=\"#惯性张量\" class=\"headerlink\" title=\"惯性张量\"></a>惯性张量</h1><p>直角坐标系${O_{xyz}}$ 中,一个刚体的转动惯量为</p>\n<script type=\"math/tex; mode=display\">\n\\mathbf{I}=\\left[\\begin{array}{lll}\n{I_{x x}} & {I_{x y}} & {I_{x z}} \\\\\n{I_{y x}} & {I_{y y}} & {I_{y z}} \\\\\n{I_{z x}} & {I_{z y}} & {I_{z z}}\n\\end{array}\\right]</script><p>其中<strong>转动惯量</strong></p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&I_{x x} \\stackrel{\\text { def }}{=} \\int\\left(y^{2}+z^{2}\\right) d m\\\\\n&I_{y y} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+z^{2}\\right) d m\\\\\n&I_{z z} \\stackrel{\\text { def }}{=} \\int\\left(x^{2}+y^{2}\\right) d m\\\n\\end{aligned}</script><p>矩阵对角元素,<strong>惯性积</strong>,有时候惯性矩前面没有负号</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&I_{x y}=I_{y x} \\stackrel{\\text { def }}{=}-\\int x y d m\\\\\n&I_{x z}=I_{z x} \\stackrel{\\text { def }}{=}-\\int x z d m\\\\\n&I_{y z}=I_{z y} \\stackrel{\\text { def }}{=}-\\int y z d m\\\n\\end{aligned}</script><p>选取坐标系姿态使得惯性积为0,则对这个坐标系,惯性张量是对角型的,<br>此坐标系称为惯性主轴,相应的惯性矩为主惯性矩</p>\n<h2 id=\"伪惯性矩阵\"><a href=\"#伪惯性矩阵\" class=\"headerlink\" title=\"伪惯性矩阵\"></a>伪惯性矩阵</h2><script type=\"math/tex; mode=display\">\n\\overline{\\mathbf{I}}=\\iiint_{V} \\mathbf{r r}^{\\mathrm{T}} \\mathrm{d} m</script><p>式中r为行向量[x y z 1]</p>\n<script type=\"math/tex; mode=display\">\n\\overline{\\mathbf{I}}=\\iiint_{V}\\left[\\begin{array}{cccc}\n{x^{2}} & {x y} & {x z} & {x} \\\\\n{x y} & {y^{2}} & {y z} & {y} \\\\\n{x z} & {y z} & {z^{2}} & {z} \\\\\n{x} & {y} & {z} & {1}\n\\end{array}\\right] \\mathrm{d} m</script><h2 id=\"惯性张量性质\"><a href=\"#惯性张量性质\" class=\"headerlink\" title=\"惯性张量性质\"></a>惯性张量性质</h2><ol>\n<li>坐标系姿态改变时,若A与C共原点,则$^{A} \\mathbf{I}=_{C}^{A} \\mathbf{R}^{C} \\mathbf{I}_{C}^{A} \\mathbf{R}^{\\mathrm{T}}$</li>\n<li>惯性张量的特征值和特征向量分别是刚体对应的主惯性矩和惯性主轴</li>\n</ol>\n<p>可用平行移轴矢量形式和定义证明</p>\n<script type=\"math/tex; mode=display\">\n^{A} \\mathbf{I}=^{C} \\mathbf{I}+m\\left(\\mathbf{p}_{c}^{\\mathrm{T}} \\mathbf{p}_{c} \\mathbf{I}_{3}-\\mathbf{p}_{c} \\mathbf{p}_{c}^{\\mathrm{T}}\\right)</script><p>式中 Pc为行量 [x y z]</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%89%E5%8B%95%E6%85%A3%E9%87%8F#%E6%85%A3%E6%80%A7%E5%BC%B5%E9%87%8F\" target=\"_blank\" rel=\"noopener\">转动惯量</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/dkOxmuTzOasvOZoMTH2nQg\" target=\"_blank\" rel=\"noopener\">干货 | 机械臂的动力学（一）：牛顿欧拉法</a></li>\n<li><a href=\"https://www.cnblogs.com/21207-iHome/p/7765508.html\" target=\"_blank\" rel=\"noopener\">刚体质量分布与牛顿-欧拉方程</a></li>\n<li>机器人学 建模 控制与视觉 熊友伦 华中科技大学出版社</li>\n<li><a href=\"http://hades.mech.northwestern.edu/index.php/Modern_Robotics\" target=\"_blank\" rel=\"noopener\">Modern Robotics mechanics,planning,and control</a></li>\n</ol>\n"},{"title":"傅里叶变换理解","date":"2019-11-30T11:38:48.000Z","mathjax":true,"_content":"\n用正交函数理解傅里叶变换，详细推到请看[纯干货数学推导_傅里叶级数与傅里叶变换](https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0)\n\n# 向量正交\n向量正交：两个向量内积为0\n\n<math display='block'>\n <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>a</mi></mstyle><mo>,</mo><mstyle mathvariant='bold' mathsize='normal'><mi>b</mi></mstyle><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n一个向量可以分解到一组正交基上（坐标系）\n\n向量a在向量b上的投影长度\n\n<math display='block'>\n <mi>c</mi><mo>=</mo><mfrac>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>a</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>b</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n </mfrac>\n \n</math>\n\n\n如果b是坐标轴上的单位向量或者方向沿着坐标轴方向，则c就是对应的坐标\n# 正交函数\n函数正交：两个函数内积为0\n\n<math display='block'>\n <mo>&#x2329;</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n引入函数内积，在向量内积的基础上变成了积分（对应点的内积），这里是复变函数内积\n$$\n\\left\\langle g_{i}, g_{j}\\right\\rangle=\\int_{i_{i}}^{t_{2}} g_{i}(t) \\cdot g_{j}^{*}(t) d t\n$$\n\n\n一个函数f在另一个函数g上的投影\n\n$$\nc_{i}=\\frac{\\left\\langle f, g_{i}\\right\\rangle}{\\left\\langle g_{i}, g_{i}\\right\\rangle}=\\frac{1}{k_{i}} \\int_{t}^{t_{i}} f(t) \\cdot g_{i}(t) d t\n$$\n\n一个函数可以分解到一组完备正交函数集合上，三角函数集合和指数函数集合都是完备正交函数集合\n\n## 三角函数集合\n三角函数分解\n\n$$\n\\begin{array}{l}{f(t)=a_{0}+\\sum_{n=1}^{+\\infty} a_{n} \\cos n \\omega_{1} t+\\sum_{n=1}^{+\\infty} b_{n} \\sin n \\omega_{1} t} \\\\ {a_{0}=\\frac{\\langle f, 1\\rangle}{\\langle 1,1\\rangle}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) d t} \\\\ {a_{n}=\\frac{\\left\\langle f, \\cos n \\omega_{1} t\\right\\rangle}{\\left\\langle\\cos n \\omega_{1} t, \\cos n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\cos n \\omega_{1} t d t} \\\\ {b_{n}=\\frac{\\left\\langle f, \\sin n \\omega_{1} t\\right\\rangle}{\\left\\langle\\sin n \\omega_{1} t, \\sin n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\sin n \\omega_{1} t d t}\\end{array}\n$$\n\n其中\n$$\n\\omega_{1}=\\frac{2 \\pi}{T_{1}}\n$$\n\n## 指数函数集合\n指数函数分解\n\n$$\n\\begin{aligned}\\left\\langle e^{j n \\omega_{1} t}, e^{j m \\omega_{1} t}\\right\\rangle &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j n \\omega_{1} t} \\cdot e^{-j m \\omega_{1} t} d t \\\\ &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j(n-m) \\omega_{1} t} d t=\\left\\{\\begin{array}{ll}{T_{1}} & {n=m} \\\\ {0} & {n \\neq m}\\end{array}\\right.\\end{aligned}\n$$\n\n则对应的函数分解为\n$$\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} F_{n} e^{j n \\omega_{1} t}} \\\\ {F_{n}=\\frac{\\left\\langle f(t), e^{j n \\omega_{1} t}\\right\\rangle}{\\left\\|e^{j n \\omega_{1} t}\\right\\|_{2}}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t}\\end{array}\n$$\n\n# 傅里叶变换\n周期无穷大，加和变成了积分，时间从0开始到无穷大，如下式所示，内层就是傅里叶变换，外层就是反变换\n$$\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} \\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t e^{j n \\omega_{1} t}} \\\\ {f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{\\infty} \\int_{0}^{\\infty} f(t) e^{-j \\omega t} d t e^{j \\omega t} d w}\\end{array}\n$$\n\n# 拉式变换\n是傅里叶变换的推广，傅里叶变换是拉式变换在虚轴上的投影，可以看乘的指数部分，拉式变换是复数包含了傅里叶变换的纯虚数\n$$\nX(s)=\\int_{0}^{\\infty} x(t) e^{-s t} d t\n$$\n\n\n# 引用\n1. [正交函数集合](https://blog.csdn.net/Einstellung/article/details/77478203)\n2. [纯干货数学推导_傅里叶级数与傅里叶变换](https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0)\n","source":"_posts/傅里叶变换理解.md","raw":"---\ntitle: 傅里叶变换理解\ndate: 2019-11-30 19:38:48\ncategories:\n- math\ntags:\n- 傅里叶变换\nmathjax: true\n\n---\n\n用正交函数理解傅里叶变换，详细推到请看[纯干货数学推导_傅里叶级数与傅里叶变换](https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0)\n\n# 向量正交\n向量正交：两个向量内积为0\n\n<math display='block'>\n <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>a</mi></mstyle><mo>,</mo><mstyle mathvariant='bold' mathsize='normal'><mi>b</mi></mstyle><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n一个向量可以分解到一组正交基上（坐标系）\n\n向量a在向量b上的投影长度\n\n<math display='block'>\n <mi>c</mi><mo>=</mo><mfrac>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>a</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>b</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n </mfrac>\n \n</math>\n\n\n如果b是坐标轴上的单位向量或者方向沿着坐标轴方向，则c就是对应的坐标\n# 正交函数\n函数正交：两个函数内积为0\n\n<math display='block'>\n <mo>&#x2329;</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n引入函数内积，在向量内积的基础上变成了积分（对应点的内积），这里是复变函数内积\n$$\n\\left\\langle g_{i}, g_{j}\\right\\rangle=\\int_{i_{i}}^{t_{2}} g_{i}(t) \\cdot g_{j}^{*}(t) d t\n$$\n\n\n一个函数f在另一个函数g上的投影\n\n$$\nc_{i}=\\frac{\\left\\langle f, g_{i}\\right\\rangle}{\\left\\langle g_{i}, g_{i}\\right\\rangle}=\\frac{1}{k_{i}} \\int_{t}^{t_{i}} f(t) \\cdot g_{i}(t) d t\n$$\n\n一个函数可以分解到一组完备正交函数集合上，三角函数集合和指数函数集合都是完备正交函数集合\n\n## 三角函数集合\n三角函数分解\n\n$$\n\\begin{array}{l}{f(t)=a_{0}+\\sum_{n=1}^{+\\infty} a_{n} \\cos n \\omega_{1} t+\\sum_{n=1}^{+\\infty} b_{n} \\sin n \\omega_{1} t} \\\\ {a_{0}=\\frac{\\langle f, 1\\rangle}{\\langle 1,1\\rangle}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) d t} \\\\ {a_{n}=\\frac{\\left\\langle f, \\cos n \\omega_{1} t\\right\\rangle}{\\left\\langle\\cos n \\omega_{1} t, \\cos n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\cos n \\omega_{1} t d t} \\\\ {b_{n}=\\frac{\\left\\langle f, \\sin n \\omega_{1} t\\right\\rangle}{\\left\\langle\\sin n \\omega_{1} t, \\sin n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\sin n \\omega_{1} t d t}\\end{array}\n$$\n\n其中\n$$\n\\omega_{1}=\\frac{2 \\pi}{T_{1}}\n$$\n\n## 指数函数集合\n指数函数分解\n\n$$\n\\begin{aligned}\\left\\langle e^{j n \\omega_{1} t}, e^{j m \\omega_{1} t}\\right\\rangle &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j n \\omega_{1} t} \\cdot e^{-j m \\omega_{1} t} d t \\\\ &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j(n-m) \\omega_{1} t} d t=\\left\\{\\begin{array}{ll}{T_{1}} & {n=m} \\\\ {0} & {n \\neq m}\\end{array}\\right.\\end{aligned}\n$$\n\n则对应的函数分解为\n$$\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} F_{n} e^{j n \\omega_{1} t}} \\\\ {F_{n}=\\frac{\\left\\langle f(t), e^{j n \\omega_{1} t}\\right\\rangle}{\\left\\|e^{j n \\omega_{1} t}\\right\\|_{2}}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t}\\end{array}\n$$\n\n# 傅里叶变换\n周期无穷大，加和变成了积分，时间从0开始到无穷大，如下式所示，内层就是傅里叶变换，外层就是反变换\n$$\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} \\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t e^{j n \\omega_{1} t}} \\\\ {f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{\\infty} \\int_{0}^{\\infty} f(t) e^{-j \\omega t} d t e^{j \\omega t} d w}\\end{array}\n$$\n\n# 拉式变换\n是傅里叶变换的推广，傅里叶变换是拉式变换在虚轴上的投影，可以看乘的指数部分，拉式变换是复数包含了傅里叶变换的纯虚数\n$$\nX(s)=\\int_{0}^{\\infty} x(t) e^{-s t} d t\n$$\n\n\n# 引用\n1. [正交函数集合](https://blog.csdn.net/Einstellung/article/details/77478203)\n2. [纯干货数学推导_傅里叶级数与傅里叶变换](https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0)\n","slug":"傅里叶变换理解","published":1,"updated":"2019-12-01T08:01:29.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci7003gmxkahejzzej8","content":"<p>用正交函数理解傅里叶变换，详细推到请看<a href=\"https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0\" target=\"_blank\" rel=\"noopener\">纯干货数学推导_傅里叶级数与傅里叶变换</a></p>\n<h1 id=\"向量正交\"><a href=\"#向量正交\" class=\"headerlink\" title=\"向量正交\"></a>向量正交</h1><p>向量正交：两个向量内积为0</p>\n<math display=\"block\">\n <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>a</mi></mstyle><mo>,</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>b</mi></mstyle><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n<p>一个向量可以分解到一组正交基上（坐标系）</p>\n<p>向量a在向量b上的投影长度</p>\n<math display=\"block\">\n <mi>c</mi><mo>=</mo><mfrac>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>a</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>b</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n </mfrac>\n\n</math>\n\n\n<p>如果b是坐标轴上的单位向量或者方向沿着坐标轴方向，则c就是对应的坐标</p>\n<h1 id=\"正交函数\"><a href=\"#正交函数\" class=\"headerlink\" title=\"正交函数\"></a>正交函数</h1><p>函数正交：两个函数内积为0</p>\n<math display=\"block\">\n <mo>&#x2329;</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n<p>引入函数内积，在向量内积的基础上变成了积分（对应点的内积），这里是复变函数内积</p>\n<script type=\"math/tex; mode=display\">\n\\left\\langle g_{i}, g_{j}\\right\\rangle=\\int_{i_{i}}^{t_{2}} g_{i}(t) \\cdot g_{j}^{*}(t) d t</script><p>一个函数f在另一个函数g上的投影</p>\n<script type=\"math/tex; mode=display\">\nc_{i}=\\frac{\\left\\langle f, g_{i}\\right\\rangle}{\\left\\langle g_{i}, g_{i}\\right\\rangle}=\\frac{1}{k_{i}} \\int_{t}^{t_{i}} f(t) \\cdot g_{i}(t) d t</script><p>一个函数可以分解到一组完备正交函数集合上，三角函数集合和指数函数集合都是完备正交函数集合</p>\n<h2 id=\"三角函数集合\"><a href=\"#三角函数集合\" class=\"headerlink\" title=\"三角函数集合\"></a>三角函数集合</h2><p>三角函数分解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=a_{0}+\\sum_{n=1}^{+\\infty} a_{n} \\cos n \\omega_{1} t+\\sum_{n=1}^{+\\infty} b_{n} \\sin n \\omega_{1} t} \\\\ {a_{0}=\\frac{\\langle f, 1\\rangle}{\\langle 1,1\\rangle}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) d t} \\\\ {a_{n}=\\frac{\\left\\langle f, \\cos n \\omega_{1} t\\right\\rangle}{\\left\\langle\\cos n \\omega_{1} t, \\cos n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\cos n \\omega_{1} t d t} \\\\ {b_{n}=\\frac{\\left\\langle f, \\sin n \\omega_{1} t\\right\\rangle}{\\left\\langle\\sin n \\omega_{1} t, \\sin n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\sin n \\omega_{1} t d t}\\end{array}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\omega_{1}=\\frac{2 \\pi}{T_{1}}</script><h2 id=\"指数函数集合\"><a href=\"#指数函数集合\" class=\"headerlink\" title=\"指数函数集合\"></a>指数函数集合</h2><p>指数函数分解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\\left\\langle e^{j n \\omega_{1} t}, e^{j m \\omega_{1} t}\\right\\rangle &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j n \\omega_{1} t} \\cdot e^{-j m \\omega_{1} t} d t \\\\ &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j(n-m) \\omega_{1} t} d t=\\left\\{\\begin{array}{ll}{T_{1}} & {n=m} \\\\ {0} & {n \\neq m}\\end{array}\\right.\\end{aligned}</script><p>则对应的函数分解为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} F_{n} e^{j n \\omega_{1} t}} \\\\ {F_{n}=\\frac{\\left\\langle f(t), e^{j n \\omega_{1} t}\\right\\rangle}{\\left\\|e^{j n \\omega_{1} t}\\right\\|_{2}}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t}\\end{array}</script><h1 id=\"傅里叶变换\"><a href=\"#傅里叶变换\" class=\"headerlink\" title=\"傅里叶变换\"></a>傅里叶变换</h1><p>周期无穷大，加和变成了积分，时间从0开始到无穷大，如下式所示，内层就是傅里叶变换，外层就是反变换</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} \\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t e^{j n \\omega_{1} t}} \\\\ {f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{\\infty} \\int_{0}^{\\infty} f(t) e^{-j \\omega t} d t e^{j \\omega t} d w}\\end{array}</script><h1 id=\"拉式变换\"><a href=\"#拉式变换\" class=\"headerlink\" title=\"拉式变换\"></a>拉式变换</h1><p>是傅里叶变换的推广，傅里叶变换是拉式变换在虚轴上的投影，可以看乘的指数部分，拉式变换是复数包含了傅里叶变换的纯虚数</p>\n<script type=\"math/tex; mode=display\">\nX(s)=\\int_{0}^{\\infty} x(t) e^{-s t} d t</script><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/Einstellung/article/details/77478203\" target=\"_blank\" rel=\"noopener\">正交函数集合</a></li>\n<li><a href=\"https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0\" target=\"_blank\" rel=\"noopener\">纯干货数学推导_傅里叶级数与傅里叶变换</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>用正交函数理解傅里叶变换，详细推到请看<a href=\"https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0\" target=\"_blank\" rel=\"noopener\">纯干货数学推导_傅里叶级数与傅里叶变换</a></p>\n<h1 id=\"向量正交\"><a href=\"#向量正交\" class=\"headerlink\" title=\"向量正交\"></a>向量正交</h1><p>向量正交：两个向量内积为0</p>\n<math display=\"block\">\n <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>a</mi></mstyle><mo>,</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>b</mi></mstyle><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n<p>一个向量可以分解到一组正交基上（坐标系）</p>\n<p>向量a在向量b上的投影长度</p>\n<math display=\"block\">\n <mi>c</mi><mo>=</mo><mfrac>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>a</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n  <mrow>\n   <mo>&#x2329;</mo><mstyle mathvariant=\"bold\" mathsize=\"normal\"><mi>b</mi><mo>,</mo><mi>b</mi></mstyle><mo>&#x232A;</mo></mrow>\n </mfrac>\n\n</math>\n\n\n<p>如果b是坐标轴上的单位向量或者方向沿着坐标轴方向，则c就是对应的坐标</p>\n<h1 id=\"正交函数\"><a href=\"#正交函数\" class=\"headerlink\" title=\"正交函数\"></a>正交函数</h1><p>函数正交：两个函数内积为0</p>\n<math display=\"block\">\n <mo>&#x2329;</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo>&#x232A;</mo><mo>=</mo><mn>0</mn>\n</math>\n\n<p>引入函数内积，在向量内积的基础上变成了积分（对应点的内积），这里是复变函数内积</p>\n<script type=\"math/tex; mode=display\">\n\\left\\langle g_{i}, g_{j}\\right\\rangle=\\int_{i_{i}}^{t_{2}} g_{i}(t) \\cdot g_{j}^{*}(t) d t</script><p>一个函数f在另一个函数g上的投影</p>\n<script type=\"math/tex; mode=display\">\nc_{i}=\\frac{\\left\\langle f, g_{i}\\right\\rangle}{\\left\\langle g_{i}, g_{i}\\right\\rangle}=\\frac{1}{k_{i}} \\int_{t}^{t_{i}} f(t) \\cdot g_{i}(t) d t</script><p>一个函数可以分解到一组完备正交函数集合上，三角函数集合和指数函数集合都是完备正交函数集合</p>\n<h2 id=\"三角函数集合\"><a href=\"#三角函数集合\" class=\"headerlink\" title=\"三角函数集合\"></a>三角函数集合</h2><p>三角函数分解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=a_{0}+\\sum_{n=1}^{+\\infty} a_{n} \\cos n \\omega_{1} t+\\sum_{n=1}^{+\\infty} b_{n} \\sin n \\omega_{1} t} \\\\ {a_{0}=\\frac{\\langle f, 1\\rangle}{\\langle 1,1\\rangle}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) d t} \\\\ {a_{n}=\\frac{\\left\\langle f, \\cos n \\omega_{1} t\\right\\rangle}{\\left\\langle\\cos n \\omega_{1} t, \\cos n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\cos n \\omega_{1} t d t} \\\\ {b_{n}=\\frac{\\left\\langle f, \\sin n \\omega_{1} t\\right\\rangle}{\\left\\langle\\sin n \\omega_{1} t, \\sin n \\omega_{1} t\\right\\rangle}=\\frac{2}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) \\cdot \\sin n \\omega_{1} t d t}\\end{array}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\n\\omega_{1}=\\frac{2 \\pi}{T_{1}}</script><h2 id=\"指数函数集合\"><a href=\"#指数函数集合\" class=\"headerlink\" title=\"指数函数集合\"></a>指数函数集合</h2><p>指数函数分解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\\left\\langle e^{j n \\omega_{1} t}, e^{j m \\omega_{1} t}\\right\\rangle &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j n \\omega_{1} t} \\cdot e^{-j m \\omega_{1} t} d t \\\\ &=\\int_{t_{0}}^{t_{0}+T_{1}} e^{j(n-m) \\omega_{1} t} d t=\\left\\{\\begin{array}{ll}{T_{1}} & {n=m} \\\\ {0} & {n \\neq m}\\end{array}\\right.\\end{aligned}</script><p>则对应的函数分解为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} F_{n} e^{j n \\omega_{1} t}} \\\\ {F_{n}=\\frac{\\left\\langle f(t), e^{j n \\omega_{1} t}\\right\\rangle}{\\left\\|e^{j n \\omega_{1} t}\\right\\|_{2}}=\\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t}\\end{array}</script><h1 id=\"傅里叶变换\"><a href=\"#傅里叶变换\" class=\"headerlink\" title=\"傅里叶变换\"></a>傅里叶变换</h1><p>周期无穷大，加和变成了积分，时间从0开始到无穷大，如下式所示，内层就是傅里叶变换，外层就是反变换</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{f(t)=\\sum_{n=-\\infty}^{+\\infty} \\frac{1}{T_{1}} \\int_{t_{0}}^{t_{0}+T_{1}} f(t) e^{-j n \\omega_{1} t} d t e^{j n \\omega_{1} t}} \\\\ {f(t)=\\frac{1}{2 \\pi} \\int_{-\\infty}^{\\infty} \\int_{0}^{\\infty} f(t) e^{-j \\omega t} d t e^{j \\omega t} d w}\\end{array}</script><h1 id=\"拉式变换\"><a href=\"#拉式变换\" class=\"headerlink\" title=\"拉式变换\"></a>拉式变换</h1><p>是傅里叶变换的推广，傅里叶变换是拉式变换在虚轴上的投影，可以看乘的指数部分，拉式变换是复数包含了傅里叶变换的纯虚数</p>\n<script type=\"math/tex; mode=display\">\nX(s)=\\int_{0}^{\\infty} x(t) e^{-s t} d t</script><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/Einstellung/article/details/77478203\" target=\"_blank\" rel=\"noopener\">正交函数集合</a></li>\n<li><a href=\"https://www.bilibili.com/video/av34364399/?spm_id_from=333.788.videocard.0\" target=\"_blank\" rel=\"noopener\">纯干货数学推导_傅里叶级数与傅里叶变换</a></li>\n</ol>\n"},{"title":"多线程","date":"2020-11-14T13:07:02.000Z","_content":"\n## c++ 使用线程注意事项\n1. 限定符避免编译器优化\n    {% post_link c++记录 参考限定符部分 %},不过没用好像也没什么问题   \n     \n        // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值)\n        volatile int val;\n2. 锁同一个对象需要同一个锁,如全局变量或类对象        \n        \n        std::mutex mut  \n        //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁\n        lock_guard<mutex> lock (mut);  \n3. sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长\n    \n        std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        \n4. 线程销毁 \n    - thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常\n    - thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达--这是两个独立的事情.\n    - 执行到析构函数时要么join,要么detach线程\n\n## c++11院子操作(atomic operation)    \n所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,\n类似互斥锁,但是原子操作更加接近底层，因而效率更高.\n\n使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型\n        \n    #include <atomic>      \n    \n    atomic_long total(0);\n    total++;\n\n\n\n## 引用\n1. [C++11：多线程与锁](https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)\n2. [C++11中std::mutex的使用](https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf)\n3. [thread中join和detach的区别](https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf)\n4. [C++11中的原子操作（atomic operation）](https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control)","source":"_posts/多线程.md","raw":"---\ntitle: 多线程\ndate: 2020-11-14 21:07:02\ncategories:\n- program\ntags:\n- 多线程\n---\n\n## c++ 使用线程注意事项\n1. 限定符避免编译器优化\n    {% post_link c++记录 参考限定符部分 %},不过没用好像也没什么问题   \n     \n        // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值)\n        volatile int val;\n2. 锁同一个对象需要同一个锁,如全局变量或类对象        \n        \n        std::mutex mut  \n        //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁\n        lock_guard<mutex> lock (mut);  \n3. sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长\n    \n        std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        \n4. 线程销毁 \n    - thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常\n    - thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达--这是两个独立的事情.\n    - 执行到析构函数时要么join,要么detach线程\n\n## c++11院子操作(atomic operation)    \n所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,\n类似互斥锁,但是原子操作更加接近底层，因而效率更高.\n\n使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型\n        \n    #include <atomic>      \n    \n    atomic_long total(0);\n    total++;\n\n\n\n## 引用\n1. [C++11：多线程与锁](https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf)\n2. [C++11中std::mutex的使用](https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf)\n3. [thread中join和detach的区别](https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf)\n4. [C++11中的原子操作（atomic operation）](https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control)","slug":"多线程","published":1,"updated":"2020-11-21T02:30:18.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ci8003jmxkauftjrn6x","content":"<h2 id=\"c-使用线程注意事项\"><a href=\"#c-使用线程注意事项\" class=\"headerlink\" title=\"c++ 使用线程注意事项\"></a>c++ 使用线程注意事项</h2><ol>\n<li><p>限定符避免编译器优化<br> <a href=\"/2019/10/06/c++记录/\" title=\"参考限定符部分\">参考限定符部分</a>,不过没用好像也没什么问题   </p>\n<pre><code> // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值)\n volatile int val;\n</code></pre></li>\n<li><p>锁同一个对象需要同一个锁,如全局变量或类对象        </p>\n<pre><code> std::mutex mut  \n //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁\n lock_guard&lt;mutex&gt; lock (mut);  \n</code></pre></li>\n<li><p>sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长</p>\n<pre><code> std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        \n</code></pre></li>\n<li>线程销毁 <ul>\n<li>thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常</li>\n<li>thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达—这是两个独立的事情.</li>\n<li>执行到析构函数时要么join,要么detach线程</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"c-11院子操作-atomic-operation\"><a href=\"#c-11院子操作-atomic-operation\" class=\"headerlink\" title=\"c++11院子操作(atomic operation)\"></a>c++11院子操作(atomic operation)</h2><p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,<br>类似互斥锁,但是原子操作更加接近底层，因而效率更高.</p>\n<p>使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型</p>\n<pre><code>#include &lt;atomic&gt;      \n\natomic_long total(0);\ntotal++;\n</code></pre><h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf\" target=\"_blank\" rel=\"noopener\">C++11：多线程与锁</a></li>\n<li><a href=\"https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf\" target=\"_blank\" rel=\"noopener\">C++11中std::mutex的使用</a></li>\n<li><a href=\"https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf\" target=\"_blank\" rel=\"noopener\">thread中join和detach的区别</a></li>\n<li><a href=\"https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control\" target=\"_blank\" rel=\"noopener\">C++11中的原子操作（atomic operation）</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"c-使用线程注意事项\"><a href=\"#c-使用线程注意事项\" class=\"headerlink\" title=\"c++ 使用线程注意事项\"></a>c++ 使用线程注意事项</h2><ol>\n<li><p>限定符避免编译器优化<br> <a href=\"/2019/10/06/c++记录/\" title=\"参考限定符部分\">参考限定符部分</a>,不过没用好像也没什么问题   </p>\n<pre><code> // 线程操作对象需要增加volatile,避免编译器优化(直接从变量地址读取而不是上次的值)\n volatile int val;\n</code></pre></li>\n<li><p>锁同一个对象需要同一个锁,如全局变量或类对象        </p>\n<pre><code> std::mutex mut  \n //构造函数加锁,析构函数解锁,避免程序意外终止结果没来得及解锁\n lock_guard&lt;mutex&gt; lock (mut);  \n</code></pre></li>\n<li><p>sleep_for,线程休眠指定时间后唤醒,不过由于线程调度等原因,实际睡眠时间可能更长</p>\n<pre><code> std::this_thread::sleep_for( std::chrono::milliseconds(2000) );        \n</code></pre></li>\n<li>线程销毁 <ul>\n<li>thread::join()调用后,调用它的线程会被block，直到线程的执行被完成.如果一个c++线程对象销毁时还可以join就会抛出异常</li>\n<li>thread::detach()函数被调用后,执行的线程从线程对象中被分离,已不再被一个线程对象所表达—这是两个独立的事情.</li>\n<li>执行到析构函数时要么join,要么detach线程</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"c-11院子操作-atomic-operation\"><a href=\"#c-11院子操作-atomic-operation\" class=\"headerlink\" title=\"c++11院子操作(atomic operation)\"></a>c++11院子操作(atomic operation)</h2><p>所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义.确保同一时刻只有唯一的线程对指定的全局资源进行访问,<br>类似互斥锁,但是原子操作更加接近底层，因而效率更高.</p>\n<p>使用非常简单,只是类型不一样,且不用加锁就能保证线程访问的安全性,类型包括atomic_bool,atomic_int等常用简单类型</p>\n<pre><code>#include &lt;atomic&gt;      \n\natomic_long total(0);\ntotal++;\n</code></pre><h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/fawdlstty/article/details/49492197?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf\" target=\"_blank\" rel=\"noopener\">C++11：多线程与锁</a></li>\n<li><a href=\"https://blog.csdn.net/fengbingchun/article/details/73521630?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf\" target=\"_blank\" rel=\"noopener\">C++11中std::mutex的使用</a></li>\n<li><a href=\"https://blog.csdn.net/xibeichengf/article/details/71173543?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf\" target=\"_blank\" rel=\"noopener\">thread中join和detach的区别</a></li>\n<li><a href=\"https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control\" target=\"_blank\" rel=\"noopener\">C++11中的原子操作（atomic operation）</a></li>\n</ol>\n"},{"title":"拉氏变换","date":"2019-12-27T06:43:06.000Z","mathjax":true,"_content":"\n线性时不变系统(LTI)\n- 线性:满足叠加原理,输出信号为各输入单独对应输出的叠加\n- 时不变:系统参数不随时间变化,即输入信号时间滞后,输出信号形状不变,时间滞后相同\n\n求系统在一般输入信号下的响应,把一般输入信号转换分解成简单的基本信号(脉冲信号和指数函数信号),\n然后由叠加原理得到一般输入的响应.傅里叶变换形式中有指数函数分解,正交函数,够丰富\n\n# 卷积响应\n将输入分解成单位脉冲,脉冲响应的和为系统的响应\n\n$$\ny(t)=\\int_{-\\infty}^{\\infty} u(\\tau) h(t-\\tau) d \\tau\n$$\n\n变量代换$\\tau_{1}=t-\\tau$得\n\n$$\ny(t)=\\int_{\\infty}^{-\\infty} u\\left(t-\\tau_{1}\\right) h\\left(\\tau_{1}\\right)\\left(-d \\tau_{1}\\right)=\\int_{-\\infty}^{\\infty} h(\\tau) u(t-\\tau) d \\tau\n$$\n\n# 传递函数\n基本信号指数函数${e^{st}}$作为输入,得到传递函数就是脉冲响应的拉氏变换$H(s)$\n\n$$\\eqalign{\n  & y(t) = \\int_{ - \\infty }^\\infty  h (\\tau )u(t - \\tau )d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{s(t - \\tau )}}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{st}}{e^{ - s\\tau }}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{ - s\\tau }}d\\tau {e^{st}}  \\cr \n  & \\;\\;\\;\\;\\;\\; = H(s){e^{st}} \\cr} $$\n\n![卷积](卷积.png)\n\n# 引用\n1. [线性时不变系统LTI](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA)","source":"_posts/拉氏变换.md","raw":"---\ntitle: 拉氏变换\ndate: 2019-12-27 14:43:06\ncategories:\n- math\ntags:\n- 自动控制原理\nmathjax: true\n\n---\n\n线性时不变系统(LTI)\n- 线性:满足叠加原理,输出信号为各输入单独对应输出的叠加\n- 时不变:系统参数不随时间变化,即输入信号时间滞后,输出信号形状不变,时间滞后相同\n\n求系统在一般输入信号下的响应,把一般输入信号转换分解成简单的基本信号(脉冲信号和指数函数信号),\n然后由叠加原理得到一般输入的响应.傅里叶变换形式中有指数函数分解,正交函数,够丰富\n\n# 卷积响应\n将输入分解成单位脉冲,脉冲响应的和为系统的响应\n\n$$\ny(t)=\\int_{-\\infty}^{\\infty} u(\\tau) h(t-\\tau) d \\tau\n$$\n\n变量代换$\\tau_{1}=t-\\tau$得\n\n$$\ny(t)=\\int_{\\infty}^{-\\infty} u\\left(t-\\tau_{1}\\right) h\\left(\\tau_{1}\\right)\\left(-d \\tau_{1}\\right)=\\int_{-\\infty}^{\\infty} h(\\tau) u(t-\\tau) d \\tau\n$$\n\n# 传递函数\n基本信号指数函数${e^{st}}$作为输入,得到传递函数就是脉冲响应的拉氏变换$H(s)$\n\n$$\\eqalign{\n  & y(t) = \\int_{ - \\infty }^\\infty  h (\\tau )u(t - \\tau )d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{s(t - \\tau )}}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{st}}{e^{ - s\\tau }}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{ - s\\tau }}d\\tau {e^{st}}  \\cr \n  & \\;\\;\\;\\;\\;\\; = H(s){e^{st}} \\cr} $$\n\n![卷积](卷积.png)\n\n# 引用\n1. [线性时不变系统LTI](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA)","slug":"拉氏变换","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cia003mmxkahsjoc7f5","content":"<p>线性时不变系统(LTI)</p>\n<ul>\n<li>线性:满足叠加原理,输出信号为各输入单独对应输出的叠加</li>\n<li>时不变:系统参数不随时间变化,即输入信号时间滞后,输出信号形状不变,时间滞后相同</li>\n</ul>\n<p>求系统在一般输入信号下的响应,把一般输入信号转换分解成简单的基本信号(脉冲信号和指数函数信号),<br>然后由叠加原理得到一般输入的响应.傅里叶变换形式中有指数函数分解,正交函数,够丰富</p>\n<h1 id=\"卷积响应\"><a href=\"#卷积响应\" class=\"headerlink\" title=\"卷积响应\"></a>卷积响应</h1><p>将输入分解成单位脉冲,脉冲响应的和为系统的响应</p>\n<script type=\"math/tex; mode=display\">\ny(t)=\\int_{-\\infty}^{\\infty} u(\\tau) h(t-\\tau) d \\tau</script><p>变量代换$\\tau_{1}=t-\\tau$得</p>\n<script type=\"math/tex; mode=display\">\ny(t)=\\int_{\\infty}^{-\\infty} u\\left(t-\\tau_{1}\\right) h\\left(\\tau_{1}\\right)\\left(-d \\tau_{1}\\right)=\\int_{-\\infty}^{\\infty} h(\\tau) u(t-\\tau) d \\tau</script><h1 id=\"传递函数\"><a href=\"#传递函数\" class=\"headerlink\" title=\"传递函数\"></a>传递函数</h1><p>基本信号指数函数${e^{st}}$作为输入,得到传递函数就是脉冲响应的拉氏变换$H(s)$</p>\n<script type=\"math/tex; mode=display\">\\eqalign{\n  & y(t) = \\int_{ - \\infty }^\\infty  h (\\tau )u(t - \\tau )d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{s(t - \\tau )}}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{st}}{e^{ - s\\tau }}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{ - s\\tau }}d\\tau {e^{st}}  \\cr \n  & \\;\\;\\;\\;\\;\\; = H(s){e^{st}} \\cr}</script><p><img src=\"/2019/12/27/拉氏变换/卷积.png\" alt=\"卷积\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">线性时不变系统LTI</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>线性时不变系统(LTI)</p>\n<ul>\n<li>线性:满足叠加原理,输出信号为各输入单独对应输出的叠加</li>\n<li>时不变:系统参数不随时间变化,即输入信号时间滞后,输出信号形状不变,时间滞后相同</li>\n</ul>\n<p>求系统在一般输入信号下的响应,把一般输入信号转换分解成简单的基本信号(脉冲信号和指数函数信号),<br>然后由叠加原理得到一般输入的响应.傅里叶变换形式中有指数函数分解,正交函数,够丰富</p>\n<h1 id=\"卷积响应\"><a href=\"#卷积响应\" class=\"headerlink\" title=\"卷积响应\"></a>卷积响应</h1><p>将输入分解成单位脉冲,脉冲响应的和为系统的响应</p>\n<script type=\"math/tex; mode=display\">\ny(t)=\\int_{-\\infty}^{\\infty} u(\\tau) h(t-\\tau) d \\tau</script><p>变量代换$\\tau_{1}=t-\\tau$得</p>\n<script type=\"math/tex; mode=display\">\ny(t)=\\int_{\\infty}^{-\\infty} u\\left(t-\\tau_{1}\\right) h\\left(\\tau_{1}\\right)\\left(-d \\tau_{1}\\right)=\\int_{-\\infty}^{\\infty} h(\\tau) u(t-\\tau) d \\tau</script><h1 id=\"传递函数\"><a href=\"#传递函数\" class=\"headerlink\" title=\"传递函数\"></a>传递函数</h1><p>基本信号指数函数${e^{st}}$作为输入,得到传递函数就是脉冲响应的拉氏变换$H(s)$</p>\n<script type=\"math/tex; mode=display\">\\eqalign{\n  & y(t) = \\int_{ - \\infty }^\\infty  h (\\tau )u(t - \\tau )d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{s(t - \\tau )}}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{st}}{e^{ - s\\tau }}d\\tau   \\cr \n  & \\;\\;\\;\\;\\;\\; = \\int_{ - \\infty }^\\infty  h (\\tau ){e^{ - s\\tau }}d\\tau {e^{st}}  \\cr \n  & \\;\\;\\;\\;\\;\\; = H(s){e^{st}} \\cr}</script><p><img src=\"/2019/12/27/拉氏变换/卷积.png\" alt=\"卷积\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA\" target=\"_blank\" rel=\"noopener\">线性时不变系统LTI</a></li>\n</ol>\n"},{"title":"排序算法","date":"2020-03-16T07:37:00.000Z","mathjax":true,"_content":"\n常用的排序算法:冒泡,归并,快排\n\n# 快排\n快速排序采用分治策略:找到一个轴点,比它小的放在左侧,大的放在右侧,不断划分\n\n最坏情况O(n^2),大多数情况下平均效率O(nlogn),常系数比其它的小,实际的平均运行时间比同类的更少.\n但是快速排序无法保证数据之间的相对次序(主要针对重复元素)\n\n    #include <cstdlib>\n    #include <iostream>\n    using namespace std;\n    \n    // [lo hi) sort\n    template <typename T>\n    int partition(T arr[], int lo, int hi){\n        int index = lo + rand()%(hi-lo);\n    //    swap arr[lo] and arr[index]\n        T mi = arr[index];\n        arr[index] = arr[lo];\n        arr[lo] = mi;\n        hi--;  // point to last data\n        // < 勤于交换 相对于<=更好,能较为均衡划分 \n        while(lo < hi){\n            while(lo < hi){\n                if(mi < arr[hi]){ hi--; }\n                else{arr[lo++] = arr[hi]; break;}\n            }\n            while(lo < hi){\n                if(arr[lo] < mi){lo++; }\n                else{arr[hi--] = arr[lo]; break;}\n            }\n        }\n        arr[lo] = mi;\n        return lo;\n    }\n    \n    template <typename T>\n    void quicksort(T arr[], int length, int lo, int hi){\n    //    judge the input\n        if(hi < lo || hi - lo > length|| arr == NULL){\n            cout << \"invalid input\";\n            exit(1);\n        }\n        if(hi-lo < 2)\n            return;\n    //    partition and sort\n        int middle = partition(arr, lo, hi);\n        quicksort(arr, length, lo, middle);\n        quicksort(arr, length, middle+1, hi);\n    }\n\n    // override\n    template <typename T>\n    void quicksort(T arr[], int length){\n        quicksort(arr, length, 0, length);\n    }\n\n# 归并\n从中间分成两部分,然后分别排序,最后归并\n每一层递归消耗时间稳定在$\\Theta(n)$,共有$\\Theta\\left(\\log _{2} n\\right)$层,共计$\\Theta(\\text {n} 1 \\text {ogn})$\n\n    template <typename T>\n    void merge(T arr[], int lo, int middle, int hi){\n        int len_l = middle - lo;\n        int len_r = hi - middle;\n        T *temp_left = new T[len_l];\n        for(int i=0;i<len_l;i++){temp_left[i] = arr[lo+i]; }\n        T *temp_right = arr + middle;\n        T *glo_arr = arr + lo;\n        for(int i=0,j=0,k=0;j< len_l || k < len_r;){\n            if(j < len_l && (temp_left[j] <= temp_right[k] || k == len_r)){glo_arr[i++] = temp_left[j++];}\n            if(k < len_r && (temp_right[k] < temp_left[j] || j == len_l)){glo_arr[i++] = temp_right[k++];}\n        }\n        delete [] temp_left;\n    }\n    \n    template <typename T>\n    void mergesort(T arr[], int length, int lo, int hi){\n    //    judge the input\n        if(hi-lo > length || hi<lo){\n            cout<< \"invalid input\";\n            exit(1);\n        }\n        if(hi - lo < 2)\n            return;\n        int middle = (lo + hi)>>1;\n        mergesort(arr, length, lo, middle);\n        mergesort(arr, length, middle, hi);\n        merge(arr, lo, middle, hi);\n    }\n    \n    template <typename T>\n    void mergesort(T arr[], int length){\n        mergesort(arr, length, 0, length);\n    }     \n    \n# 冒泡\n复杂度O(n^2)\n    \n    template <typename T>\n    void bubblesort(T arr[], int length){\n        for(int i=0;i<length-1;i++){\n            for(int j=0;j<length-1-i;j++){\n                if(arr[j] > arr[j+1]){\n                    T temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }  \n     ","source":"_posts/排序算法.md","raw":"---\ntitle: 排序算法\ndate: 2020-03-16 15:37:00\ncategories:\n- program\ntags:\n- sort\nmathjax: true\n---\n\n常用的排序算法:冒泡,归并,快排\n\n# 快排\n快速排序采用分治策略:找到一个轴点,比它小的放在左侧,大的放在右侧,不断划分\n\n最坏情况O(n^2),大多数情况下平均效率O(nlogn),常系数比其它的小,实际的平均运行时间比同类的更少.\n但是快速排序无法保证数据之间的相对次序(主要针对重复元素)\n\n    #include <cstdlib>\n    #include <iostream>\n    using namespace std;\n    \n    // [lo hi) sort\n    template <typename T>\n    int partition(T arr[], int lo, int hi){\n        int index = lo + rand()%(hi-lo);\n    //    swap arr[lo] and arr[index]\n        T mi = arr[index];\n        arr[index] = arr[lo];\n        arr[lo] = mi;\n        hi--;  // point to last data\n        // < 勤于交换 相对于<=更好,能较为均衡划分 \n        while(lo < hi){\n            while(lo < hi){\n                if(mi < arr[hi]){ hi--; }\n                else{arr[lo++] = arr[hi]; break;}\n            }\n            while(lo < hi){\n                if(arr[lo] < mi){lo++; }\n                else{arr[hi--] = arr[lo]; break;}\n            }\n        }\n        arr[lo] = mi;\n        return lo;\n    }\n    \n    template <typename T>\n    void quicksort(T arr[], int length, int lo, int hi){\n    //    judge the input\n        if(hi < lo || hi - lo > length|| arr == NULL){\n            cout << \"invalid input\";\n            exit(1);\n        }\n        if(hi-lo < 2)\n            return;\n    //    partition and sort\n        int middle = partition(arr, lo, hi);\n        quicksort(arr, length, lo, middle);\n        quicksort(arr, length, middle+1, hi);\n    }\n\n    // override\n    template <typename T>\n    void quicksort(T arr[], int length){\n        quicksort(arr, length, 0, length);\n    }\n\n# 归并\n从中间分成两部分,然后分别排序,最后归并\n每一层递归消耗时间稳定在$\\Theta(n)$,共有$\\Theta\\left(\\log _{2} n\\right)$层,共计$\\Theta(\\text {n} 1 \\text {ogn})$\n\n    template <typename T>\n    void merge(T arr[], int lo, int middle, int hi){\n        int len_l = middle - lo;\n        int len_r = hi - middle;\n        T *temp_left = new T[len_l];\n        for(int i=0;i<len_l;i++){temp_left[i] = arr[lo+i]; }\n        T *temp_right = arr + middle;\n        T *glo_arr = arr + lo;\n        for(int i=0,j=0,k=0;j< len_l || k < len_r;){\n            if(j < len_l && (temp_left[j] <= temp_right[k] || k == len_r)){glo_arr[i++] = temp_left[j++];}\n            if(k < len_r && (temp_right[k] < temp_left[j] || j == len_l)){glo_arr[i++] = temp_right[k++];}\n        }\n        delete [] temp_left;\n    }\n    \n    template <typename T>\n    void mergesort(T arr[], int length, int lo, int hi){\n    //    judge the input\n        if(hi-lo > length || hi<lo){\n            cout<< \"invalid input\";\n            exit(1);\n        }\n        if(hi - lo < 2)\n            return;\n        int middle = (lo + hi)>>1;\n        mergesort(arr, length, lo, middle);\n        mergesort(arr, length, middle, hi);\n        merge(arr, lo, middle, hi);\n    }\n    \n    template <typename T>\n    void mergesort(T arr[], int length){\n        mergesort(arr, length, 0, length);\n    }     \n    \n# 冒泡\n复杂度O(n^2)\n    \n    template <typename T>\n    void bubblesort(T arr[], int length){\n        for(int i=0;i<length-1;i++){\n            for(int j=0;j<length-1-i;j++){\n                if(arr[j] > arr[j+1]){\n                    T temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }  \n     ","slug":"排序算法","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cib003pmxkatxvig2qj","content":"<p>常用的排序算法:冒泡,归并,快排</p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><p>快速排序采用分治策略:找到一个轴点,比它小的放在左侧,大的放在右侧,不断划分</p>\n<p>最坏情况O(n^2),大多数情况下平均效率O(nlogn),常系数比其它的小,实际的平均运行时间比同类的更少.<br>但是快速排序无法保证数据之间的相对次序(主要针对重复元素)</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// [lo hi) sort\ntemplate &lt;typename T&gt;\nint partition(T arr[], int lo, int hi){\n    int index = lo + rand()%(hi-lo);\n//    swap arr[lo] and arr[index]\n    T mi = arr[index];\n    arr[index] = arr[lo];\n    arr[lo] = mi;\n    hi--;  // point to last data\n    // &lt; 勤于交换 相对于&lt;=更好,能较为均衡划分 \n    while(lo &lt; hi){\n        while(lo &lt; hi){\n            if(mi &lt; arr[hi]){ hi--; }\n            else{arr[lo++] = arr[hi]; break;}\n        }\n        while(lo &lt; hi){\n            if(arr[lo] &lt; mi){lo++; }\n            else{arr[hi--] = arr[lo]; break;}\n        }\n    }\n    arr[lo] = mi;\n    return lo;\n}\n\ntemplate &lt;typename T&gt;\nvoid quicksort(T arr[], int length, int lo, int hi){\n//    judge the input\n    if(hi &lt; lo || hi - lo &gt; length|| arr == NULL){\n        cout &lt;&lt; &quot;invalid input&quot;;\n        exit(1);\n    }\n    if(hi-lo &lt; 2)\n        return;\n//    partition and sort\n    int middle = partition(arr, lo, hi);\n    quicksort(arr, length, lo, middle);\n    quicksort(arr, length, middle+1, hi);\n}\n\n// override\ntemplate &lt;typename T&gt;\nvoid quicksort(T arr[], int length){\n    quicksort(arr, length, 0, length);\n}\n</code></pre><h1 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h1><p>从中间分成两部分,然后分别排序,最后归并<br>每一层递归消耗时间稳定在$\\Theta(n)$,共有$\\Theta\\left(\\log _{2} n\\right)$层,共计$\\Theta(\\text {n} 1 \\text {ogn})$</p>\n<pre><code>template &lt;typename T&gt;\nvoid merge(T arr[], int lo, int middle, int hi){\n    int len_l = middle - lo;\n    int len_r = hi - middle;\n    T *temp_left = new T[len_l];\n    for(int i=0;i&lt;len_l;i++){temp_left[i] = arr[lo+i]; }\n    T *temp_right = arr + middle;\n    T *glo_arr = arr + lo;\n    for(int i=0,j=0,k=0;j&lt; len_l || k &lt; len_r;){\n        if(j &lt; len_l &amp;&amp; (temp_left[j] &lt;= temp_right[k] || k == len_r)){glo_arr[i++] = temp_left[j++];}\n        if(k &lt; len_r &amp;&amp; (temp_right[k] &lt; temp_left[j] || j == len_l)){glo_arr[i++] = temp_right[k++];}\n    }\n    delete [] temp_left;\n}\n\ntemplate &lt;typename T&gt;\nvoid mergesort(T arr[], int length, int lo, int hi){\n//    judge the input\n    if(hi-lo &gt; length || hi&lt;lo){\n        cout&lt;&lt; &quot;invalid input&quot;;\n        exit(1);\n    }\n    if(hi - lo &lt; 2)\n        return;\n    int middle = (lo + hi)&gt;&gt;1;\n    mergesort(arr, length, lo, middle);\n    mergesort(arr, length, middle, hi);\n    merge(arr, lo, middle, hi);\n}\n\ntemplate &lt;typename T&gt;\nvoid mergesort(T arr[], int length){\n    mergesort(arr, length, 0, length);\n}     \n</code></pre><h1 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h1><p>复杂度O(n^2)</p>\n<pre><code>template &lt;typename T&gt;\nvoid bubblesort(T arr[], int length){\n    for(int i=0;i&lt;length-1;i++){\n        for(int j=0;j&lt;length-1-i;j++){\n            if(arr[j] &gt; arr[j+1]){\n                T temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}  \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>常用的排序算法:冒泡,归并,快排</p>\n<h1 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h1><p>快速排序采用分治策略:找到一个轴点,比它小的放在左侧,大的放在右侧,不断划分</p>\n<p>最坏情况O(n^2),大多数情况下平均效率O(nlogn),常系数比其它的小,实际的平均运行时间比同类的更少.<br>但是快速排序无法保证数据之间的相对次序(主要针对重复元素)</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// [lo hi) sort\ntemplate &lt;typename T&gt;\nint partition(T arr[], int lo, int hi){\n    int index = lo + rand()%(hi-lo);\n//    swap arr[lo] and arr[index]\n    T mi = arr[index];\n    arr[index] = arr[lo];\n    arr[lo] = mi;\n    hi--;  // point to last data\n    // &lt; 勤于交换 相对于&lt;=更好,能较为均衡划分 \n    while(lo &lt; hi){\n        while(lo &lt; hi){\n            if(mi &lt; arr[hi]){ hi--; }\n            else{arr[lo++] = arr[hi]; break;}\n        }\n        while(lo &lt; hi){\n            if(arr[lo] &lt; mi){lo++; }\n            else{arr[hi--] = arr[lo]; break;}\n        }\n    }\n    arr[lo] = mi;\n    return lo;\n}\n\ntemplate &lt;typename T&gt;\nvoid quicksort(T arr[], int length, int lo, int hi){\n//    judge the input\n    if(hi &lt; lo || hi - lo &gt; length|| arr == NULL){\n        cout &lt;&lt; &quot;invalid input&quot;;\n        exit(1);\n    }\n    if(hi-lo &lt; 2)\n        return;\n//    partition and sort\n    int middle = partition(arr, lo, hi);\n    quicksort(arr, length, lo, middle);\n    quicksort(arr, length, middle+1, hi);\n}\n\n// override\ntemplate &lt;typename T&gt;\nvoid quicksort(T arr[], int length){\n    quicksort(arr, length, 0, length);\n}\n</code></pre><h1 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h1><p>从中间分成两部分,然后分别排序,最后归并<br>每一层递归消耗时间稳定在$\\Theta(n)$,共有$\\Theta\\left(\\log _{2} n\\right)$层,共计$\\Theta(\\text {n} 1 \\text {ogn})$</p>\n<pre><code>template &lt;typename T&gt;\nvoid merge(T arr[], int lo, int middle, int hi){\n    int len_l = middle - lo;\n    int len_r = hi - middle;\n    T *temp_left = new T[len_l];\n    for(int i=0;i&lt;len_l;i++){temp_left[i] = arr[lo+i]; }\n    T *temp_right = arr + middle;\n    T *glo_arr = arr + lo;\n    for(int i=0,j=0,k=0;j&lt; len_l || k &lt; len_r;){\n        if(j &lt; len_l &amp;&amp; (temp_left[j] &lt;= temp_right[k] || k == len_r)){glo_arr[i++] = temp_left[j++];}\n        if(k &lt; len_r &amp;&amp; (temp_right[k] &lt; temp_left[j] || j == len_l)){glo_arr[i++] = temp_right[k++];}\n    }\n    delete [] temp_left;\n}\n\ntemplate &lt;typename T&gt;\nvoid mergesort(T arr[], int length, int lo, int hi){\n//    judge the input\n    if(hi-lo &gt; length || hi&lt;lo){\n        cout&lt;&lt; &quot;invalid input&quot;;\n        exit(1);\n    }\n    if(hi - lo &lt; 2)\n        return;\n    int middle = (lo + hi)&gt;&gt;1;\n    mergesort(arr, length, lo, middle);\n    mergesort(arr, length, middle, hi);\n    merge(arr, lo, middle, hi);\n}\n\ntemplate &lt;typename T&gt;\nvoid mergesort(T arr[], int length){\n    mergesort(arr, length, 0, length);\n}     \n</code></pre><h1 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h1><p>复杂度O(n^2)</p>\n<pre><code>template &lt;typename T&gt;\nvoid bubblesort(T arr[], int length){\n    for(int i=0;i&lt;length-1;i++){\n        for(int j=0;j&lt;length-1-i;j++){\n            if(arr[j] &gt; arr[j+1]){\n                T temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}  \n</code></pre>"},{"title":"数据结构c++","date":"2020-02-15T01:20:59.000Z","mathjax":true,"_content":"\n常用复杂度:常数,对数,线性,多项式,指数.\nO(1),O(logn)、O(sqrt(n))、O(n)、O(nlogn)、O(n^2)、和O(2^n)\n\n# 输入规模\n对算法复杂度的界定都是相对于输入规模而言.\n\n严格地说,所谓待计算问题的输入规模,应严格定义为“用以描述输入所需的空间规模”。\n\n1. 例子\n    \n        int countOnes(unsigned int n) { //统计整数n癿二迕刢展开中数位1癿总数：O(logn)\n            int ones = 0; //计数器复位\n            while (0 < n) { //在n缩减至0乀前，反复地\n                ones += (1 & n); //检查最低位，若为1则计数\n                n >>= 1; //右秱一位\n            }\n            return ones; //迒回计数\n        } //等效亍glibc癿内置函数int __builtin_popcount (unsigned int n)\n    现对于n本身数值来说,复杂度为log(n);相对于n的二进制展开的宽度$r=1+\\left\\lfloor\\log _{2} n\\right\\rfloor$(向下取整),则复杂度为O(r)\n    \n    这里选择后一种表达方式O(r),前一种称为伪对数复杂度        \n\n# 递归\nFibonacci数:线性递归\n\n    __int64 fib(int n, __int64& prev) { //计算Fibonacci数列第n顷(线性逑弻版):入口形式fib(n, prev)\n        if (0 == n) //若刡达逑弻基,则\n        \n            { prev = 1; return 0; } //直接叏值:fib(-1) = 1, fib(0) = 0\n            else { //否则\n            __int64 prevPrev; prev = fib(n - 1, prevPrev); //逑弻计算前两顷\n            return prevPrev + prev; //其和即为正解  \n        }\n    } //用辅劣发量记弽前一顷,迒回数列癿弼前顷,O(n)\n\n原二分递归版本中对应于fib(n - 2)的另一次递归,在这里被省略掉了。其对应\n的解答,可借助形式参数的机制,通过变量prevPrev“调阅”此前的记录直接获得。\n\n更高效的方式是迭代,这里注意对已经计算出来的变量进行调阅的方式\n\n# 参考\n1. [数据结构(c++语言版)第三版_邓俊辉](https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about?jwt_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6Im5ld194dWV0YW5neCIsInVzZXJfaWQiOjEwODMzMjMzfQ.wmH12o6YjppbHX4TzGdkpjfJHPmG4xSjHlZUBenKAOM&owner=new_xuetangx)","source":"_posts/数据结构c.md","raw":"---\ntitle: 数据结构c++\ndate: 2020-02-15 09:20:59\ncategories:\n- program\ntags:\n- 数据结构\n\nmathjax: true\n---\n\n常用复杂度:常数,对数,线性,多项式,指数.\nO(1),O(logn)、O(sqrt(n))、O(n)、O(nlogn)、O(n^2)、和O(2^n)\n\n# 输入规模\n对算法复杂度的界定都是相对于输入规模而言.\n\n严格地说,所谓待计算问题的输入规模,应严格定义为“用以描述输入所需的空间规模”。\n\n1. 例子\n    \n        int countOnes(unsigned int n) { //统计整数n癿二迕刢展开中数位1癿总数：O(logn)\n            int ones = 0; //计数器复位\n            while (0 < n) { //在n缩减至0乀前，反复地\n                ones += (1 & n); //检查最低位，若为1则计数\n                n >>= 1; //右秱一位\n            }\n            return ones; //迒回计数\n        } //等效亍glibc癿内置函数int __builtin_popcount (unsigned int n)\n    现对于n本身数值来说,复杂度为log(n);相对于n的二进制展开的宽度$r=1+\\left\\lfloor\\log _{2} n\\right\\rfloor$(向下取整),则复杂度为O(r)\n    \n    这里选择后一种表达方式O(r),前一种称为伪对数复杂度        \n\n# 递归\nFibonacci数:线性递归\n\n    __int64 fib(int n, __int64& prev) { //计算Fibonacci数列第n顷(线性逑弻版):入口形式fib(n, prev)\n        if (0 == n) //若刡达逑弻基,则\n        \n            { prev = 1; return 0; } //直接叏值:fib(-1) = 1, fib(0) = 0\n            else { //否则\n            __int64 prevPrev; prev = fib(n - 1, prevPrev); //逑弻计算前两顷\n            return prevPrev + prev; //其和即为正解  \n        }\n    } //用辅劣发量记弽前一顷,迒回数列癿弼前顷,O(n)\n\n原二分递归版本中对应于fib(n - 2)的另一次递归,在这里被省略掉了。其对应\n的解答,可借助形式参数的机制,通过变量prevPrev“调阅”此前的记录直接获得。\n\n更高效的方式是迭代,这里注意对已经计算出来的变量进行调阅的方式\n\n# 参考\n1. [数据结构(c++语言版)第三版_邓俊辉](https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about?jwt_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6Im5ld194dWV0YW5neCIsInVzZXJfaWQiOjEwODMzMjMzfQ.wmH12o6YjppbHX4TzGdkpjfJHPmG4xSjHlZUBenKAOM&owner=new_xuetangx)","slug":"数据结构c","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cic003tmxka30tuhgkj","content":"<p>常用复杂度:常数,对数,线性,多项式,指数.<br>O(1),O(logn)、O(sqrt(n))、O(n)、O(nlogn)、O(n^2)、和O(2^n)</p>\n<h1 id=\"输入规模\"><a href=\"#输入规模\" class=\"headerlink\" title=\"输入规模\"></a>输入规模</h1><p>对算法复杂度的界定都是相对于输入规模而言.</p>\n<p>严格地说,所谓待计算问题的输入规模,应严格定义为“用以描述输入所需的空间规模”。</p>\n<ol>\n<li><p>例子</p>\n<pre><code> int countOnes(unsigned int n) { //统计整数n癿二迕刢展开中数位1癿总数：O(logn)\n     int ones = 0; //计数器复位\n     while (0 &lt; n) { //在n缩减至0乀前，反复地\n         ones += (1 &amp; n); //检查最低位，若为1则计数\n         n &gt;&gt;= 1; //右秱一位\n     }\n     return ones; //迒回计数\n } //等效亍glibc癿内置函数int __builtin_popcount (unsigned int n)\n</code></pre><p> 现对于n本身数值来说,复杂度为log(n);相对于n的二进制展开的宽度$r=1+\\left\\lfloor\\log _{2} n\\right\\rfloor$(向下取整),则复杂度为O(r)</p>\n<p> 这里选择后一种表达方式O(r),前一种称为伪对数复杂度        </p>\n</li>\n</ol>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>Fibonacci数:线性递归</p>\n<pre><code>__int64 fib(int n, __int64&amp; prev) { //计算Fibonacci数列第n顷(线性逑弻版):入口形式fib(n, prev)\n    if (0 == n) //若刡达逑弻基,则\n\n        { prev = 1; return 0; } //直接叏值:fib(-1) = 1, fib(0) = 0\n        else { //否则\n        __int64 prevPrev; prev = fib(n - 1, prevPrev); //逑弻计算前两顷\n        return prevPrev + prev; //其和即为正解  \n    }\n} //用辅劣发量记弽前一顷,迒回数列癿弼前顷,O(n)\n</code></pre><p>原二分递归版本中对应于fib(n - 2)的另一次递归,在这里被省略掉了。其对应<br>的解答,可借助形式参数的机制,通过变量prevPrev“调阅”此前的记录直接获得。</p>\n<p>更高效的方式是迭代,这里注意对已经计算出来的变量进行调阅的方式</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about?jwt_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6Im5ld194dWV0YW5neCIsInVzZXJfaWQiOjEwODMzMjMzfQ.wmH12o6YjppbHX4TzGdkpjfJHPmG4xSjHlZUBenKAOM&amp;owner=new_xuetangx\" target=\"_blank\" rel=\"noopener\">数据结构(c++语言版)第三版_邓俊辉</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>常用复杂度:常数,对数,线性,多项式,指数.<br>O(1),O(logn)、O(sqrt(n))、O(n)、O(nlogn)、O(n^2)、和O(2^n)</p>\n<h1 id=\"输入规模\"><a href=\"#输入规模\" class=\"headerlink\" title=\"输入规模\"></a>输入规模</h1><p>对算法复杂度的界定都是相对于输入规模而言.</p>\n<p>严格地说,所谓待计算问题的输入规模,应严格定义为“用以描述输入所需的空间规模”。</p>\n<ol>\n<li><p>例子</p>\n<pre><code> int countOnes(unsigned int n) { //统计整数n癿二迕刢展开中数位1癿总数：O(logn)\n     int ones = 0; //计数器复位\n     while (0 &lt; n) { //在n缩减至0乀前，反复地\n         ones += (1 &amp; n); //检查最低位，若为1则计数\n         n &gt;&gt;= 1; //右秱一位\n     }\n     return ones; //迒回计数\n } //等效亍glibc癿内置函数int __builtin_popcount (unsigned int n)\n</code></pre><p> 现对于n本身数值来说,复杂度为log(n);相对于n的二进制展开的宽度$r=1+\\left\\lfloor\\log _{2} n\\right\\rfloor$(向下取整),则复杂度为O(r)</p>\n<p> 这里选择后一种表达方式O(r),前一种称为伪对数复杂度        </p>\n</li>\n</ol>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>Fibonacci数:线性递归</p>\n<pre><code>__int64 fib(int n, __int64&amp; prev) { //计算Fibonacci数列第n顷(线性逑弻版):入口形式fib(n, prev)\n    if (0 == n) //若刡达逑弻基,则\n\n        { prev = 1; return 0; } //直接叏值:fib(-1) = 1, fib(0) = 0\n        else { //否则\n        __int64 prevPrev; prev = fib(n - 1, prevPrev); //逑弻计算前两顷\n        return prevPrev + prev; //其和即为正解  \n    }\n} //用辅劣发量记弽前一顷,迒回数列癿弼前顷,O(n)\n</code></pre><p>原二分递归版本中对应于fib(n - 2)的另一次递归,在这里被省略掉了。其对应<br>的解答,可借助形式参数的机制,通过变量prevPrev“调阅”此前的记录直接获得。</p>\n<p>更高效的方式是迭代,这里注意对已经计算出来的变量进行调阅的方式</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about?jwt_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJvd25lciI6Im5ld194dWV0YW5neCIsInVzZXJfaWQiOjEwODMzMjMzfQ.wmH12o6YjppbHX4TzGdkpjfJHPmG4xSjHlZUBenKAOM&amp;owner=new_xuetangx\" target=\"_blank\" rel=\"noopener\">数据结构(c++语言版)第三版_邓俊辉</a></li>\n</ol>\n"},{"title":"样本方差分母为什么是n-1","date":"2019-08-31T04:40:25.000Z","mathjax":true,"_content":"\n样本方差如下\n\n$$\nS^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}=\\frac{1}{n-1}\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\n$$\n\n直觉告诉我们似乎分母应该是n，但实际上是n-1，为什么呢？\n\n##参数估计中的无偏性\n\n设a是未知参数b的估计量，若E(a)=b，则称a是b的无偏估计，否则是有偏估计。\n\n样本均值：　$\\overline{X}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}$\n\n易得\n\n$$\nE(\\overline{X})=\\mu, D(\\overline{X})=\\frac{\\sigma^{2}}{n}\n$$\n\n$$\nD\\left(X_{i}\\right)=D(X)=\\sigma^{2}(i=1,2, \\cdots, n)\n$$\n\n\n$$\n\\begin{array}{c}{E\\left(X_{i}^{2}\\right)=D\\left(X_{i}\\right)+\\left[E\\left(X_{i}\\right)\\right]^{2}=\\sigma^{2}+\\mu^{2}(i=1,2, \\cdots, n)} \\\\ {E\\left(\\overline{X}^{2}\\right)=D(\\overline{X})+[E(\\overline{X})]^{2}=\\frac{\\sigma^{2}}{n}+\\mu^{2}}\\end{array}\n$$\n\n则有\n\n$$\n\\begin{aligned} E\\left(S^{2}\\right) &=E\\left[\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}\\right]=\\frac{1}{n-1} E\\left[\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\\right] \\\\ &=\\frac{1}{n-1}\\left[\\sum_{i=1}^{n} E\\left(X_{i}^{2}\\right)-n E\\left(\\overline{X}^{2}\\right)\\right]=\\frac{1}{n-1}\\left[n\\left(\\mu^{2}+\\sigma^{2}\\right)-n\\left(\\mu^{2}+\\frac{\\sigma^{2}}{n}\\right)\\right] \\\\ &=\\frac{1}{n-1}(n-1) \\sigma^{2}=\\sigma^{2} \\end{aligned}\n$$\n\n所以样本方差为总体方差的无偏估计\n\n形象理解ｎ－１\n\n参数估计除了需要保证采样随机，还需要保证样本之间相互独立，在统计上用自由度（Degrees of freedom），计算样本方差时引入了样本均值，减小了一个自由度，导致样本方差减小（因为均值和样本之间不具有独立性，是折中），所以需要调整分母为ｎ－１修正。\n##参考\n\n１．形象化理解可参考[知乎问答](https://www.zhihu.com/question/20099757)\n","source":"_posts/样本方差分母为什么是n-1.md","raw":"---\ntitle: 样本方差分母为什么是n-1\ndate: 2019-08-31 12:40:25\ncategories:\n- math\ntags:\n- 概率论\nmathjax: true\n\n---\n\n样本方差如下\n\n$$\nS^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}=\\frac{1}{n-1}\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\n$$\n\n直觉告诉我们似乎分母应该是n，但实际上是n-1，为什么呢？\n\n##参数估计中的无偏性\n\n设a是未知参数b的估计量，若E(a)=b，则称a是b的无偏估计，否则是有偏估计。\n\n样本均值：　$\\overline{X}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}$\n\n易得\n\n$$\nE(\\overline{X})=\\mu, D(\\overline{X})=\\frac{\\sigma^{2}}{n}\n$$\n\n$$\nD\\left(X_{i}\\right)=D(X)=\\sigma^{2}(i=1,2, \\cdots, n)\n$$\n\n\n$$\n\\begin{array}{c}{E\\left(X_{i}^{2}\\right)=D\\left(X_{i}\\right)+\\left[E\\left(X_{i}\\right)\\right]^{2}=\\sigma^{2}+\\mu^{2}(i=1,2, \\cdots, n)} \\\\ {E\\left(\\overline{X}^{2}\\right)=D(\\overline{X})+[E(\\overline{X})]^{2}=\\frac{\\sigma^{2}}{n}+\\mu^{2}}\\end{array}\n$$\n\n则有\n\n$$\n\\begin{aligned} E\\left(S^{2}\\right) &=E\\left[\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}\\right]=\\frac{1}{n-1} E\\left[\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\\right] \\\\ &=\\frac{1}{n-1}\\left[\\sum_{i=1}^{n} E\\left(X_{i}^{2}\\right)-n E\\left(\\overline{X}^{2}\\right)\\right]=\\frac{1}{n-1}\\left[n\\left(\\mu^{2}+\\sigma^{2}\\right)-n\\left(\\mu^{2}+\\frac{\\sigma^{2}}{n}\\right)\\right] \\\\ &=\\frac{1}{n-1}(n-1) \\sigma^{2}=\\sigma^{2} \\end{aligned}\n$$\n\n所以样本方差为总体方差的无偏估计\n\n形象理解ｎ－１\n\n参数估计除了需要保证采样随机，还需要保证样本之间相互独立，在统计上用自由度（Degrees of freedom），计算样本方差时引入了样本均值，减小了一个自由度，导致样本方差减小（因为均值和样本之间不具有独立性，是折中），所以需要调整分母为ｎ－１修正。\n##参考\n\n１．形象化理解可参考[知乎问答](https://www.zhihu.com/question/20099757)\n","slug":"样本方差分母为什么是n-1","published":1,"updated":"2019-10-03T04:38:52.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cid003wmxkaw1be2i4s","content":"<p>样本方差如下</p>\n<script type=\"math/tex; mode=display\">\nS^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}=\\frac{1}{n-1}\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)</script><p>直觉告诉我们似乎分母应该是n，但实际上是n-1，为什么呢？</p>\n<h2 id=\"参数估计中的无偏性\"><a href=\"#参数估计中的无偏性\" class=\"headerlink\" title=\"参数估计中的无偏性\"></a>参数估计中的无偏性</h2><p>设a是未知参数b的估计量，若E(a)=b，则称a是b的无偏估计，否则是有偏估计。</p>\n<p>样本均值：　$\\overline{X}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}$</p>\n<p>易得</p>\n<script type=\"math/tex; mode=display\">\nE(\\overline{X})=\\mu, D(\\overline{X})=\\frac{\\sigma^{2}}{n}</script><script type=\"math/tex; mode=display\">\nD\\left(X_{i}\\right)=D(X)=\\sigma^{2}(i=1,2, \\cdots, n)</script><script type=\"math/tex; mode=display\">\n\\begin{array}{c}{E\\left(X_{i}^{2}\\right)=D\\left(X_{i}\\right)+\\left[E\\left(X_{i}\\right)\\right]^{2}=\\sigma^{2}+\\mu^{2}(i=1,2, \\cdots, n)} \\\\ {E\\left(\\overline{X}^{2}\\right)=D(\\overline{X})+[E(\\overline{X})]^{2}=\\frac{\\sigma^{2}}{n}+\\mu^{2}}\\end{array}</script><p>则有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} E\\left(S^{2}\\right) &=E\\left[\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}\\right]=\\frac{1}{n-1} E\\left[\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\\right] \\\\ &=\\frac{1}{n-1}\\left[\\sum_{i=1}^{n} E\\left(X_{i}^{2}\\right)-n E\\left(\\overline{X}^{2}\\right)\\right]=\\frac{1}{n-1}\\left[n\\left(\\mu^{2}+\\sigma^{2}\\right)-n\\left(\\mu^{2}+\\frac{\\sigma^{2}}{n}\\right)\\right] \\\\ &=\\frac{1}{n-1}(n-1) \\sigma^{2}=\\sigma^{2} \\end{aligned}</script><p>所以样本方差为总体方差的无偏估计</p>\n<p>形象理解ｎ－１</p>\n<p>参数估计除了需要保证采样随机，还需要保证样本之间相互独立，在统计上用自由度（Degrees of freedom），计算样本方差时引入了样本均值，减小了一个自由度，导致样本方差减小（因为均值和样本之间不具有独立性，是折中），所以需要调整分母为ｎ－１修正。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>１．形象化理解可参考<a href=\"https://www.zhihu.com/question/20099757\" target=\"_blank\" rel=\"noopener\">知乎问答</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>样本方差如下</p>\n<script type=\"math/tex; mode=display\">\nS^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}=\\frac{1}{n-1}\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)</script><p>直觉告诉我们似乎分母应该是n，但实际上是n-1，为什么呢？</p>\n<h2 id=\"参数估计中的无偏性\"><a href=\"#参数估计中的无偏性\" class=\"headerlink\" title=\"参数估计中的无偏性\"></a>参数估计中的无偏性</h2><p>设a是未知参数b的估计量，若E(a)=b，则称a是b的无偏估计，否则是有偏估计。</p>\n<p>样本均值：　$\\overline{X}=\\frac{1}{n} \\sum_{i=1}^{n} X_{i}$</p>\n<p>易得</p>\n<script type=\"math/tex; mode=display\">\nE(\\overline{X})=\\mu, D(\\overline{X})=\\frac{\\sigma^{2}}{n}</script><script type=\"math/tex; mode=display\">\nD\\left(X_{i}\\right)=D(X)=\\sigma^{2}(i=1,2, \\cdots, n)</script><script type=\"math/tex; mode=display\">\n\\begin{array}{c}{E\\left(X_{i}^{2}\\right)=D\\left(X_{i}\\right)+\\left[E\\left(X_{i}\\right)\\right]^{2}=\\sigma^{2}+\\mu^{2}(i=1,2, \\cdots, n)} \\\\ {E\\left(\\overline{X}^{2}\\right)=D(\\overline{X})+[E(\\overline{X})]^{2}=\\frac{\\sigma^{2}}{n}+\\mu^{2}}\\end{array}</script><p>则有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} E\\left(S^{2}\\right) &=E\\left[\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(X_{i}-\\overline{X}\\right)^{2}\\right]=\\frac{1}{n-1} E\\left[\\left(\\sum_{i=1}^{n} X_{i}^{2}-n \\overline{X}^{2}\\right)\\right] \\\\ &=\\frac{1}{n-1}\\left[\\sum_{i=1}^{n} E\\left(X_{i}^{2}\\right)-n E\\left(\\overline{X}^{2}\\right)\\right]=\\frac{1}{n-1}\\left[n\\left(\\mu^{2}+\\sigma^{2}\\right)-n\\left(\\mu^{2}+\\frac{\\sigma^{2}}{n}\\right)\\right] \\\\ &=\\frac{1}{n-1}(n-1) \\sigma^{2}=\\sigma^{2} \\end{aligned}</script><p>所以样本方差为总体方差的无偏估计</p>\n<p>形象理解ｎ－１</p>\n<p>参数估计除了需要保证采样随机，还需要保证样本之间相互独立，在统计上用自由度（Degrees of freedom），计算样本方差时引入了样本均值，减小了一个自由度，导致样本方差减小（因为均值和样本之间不具有独立性，是折中），所以需要调整分母为ｎ－１修正。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>１．形象化理解可参考<a href=\"https://www.zhihu.com/question/20099757\" target=\"_blank\" rel=\"noopener\">知乎问答</a></p>\n"},{"title":"根轨迹","date":"2020-03-28T09:02:54.000Z","mathjax":true,"_content":"\n# 根轨迹定义\n一个基本的反馈系统传递函数为\n$$\\frac{Y(s)}{R(s)}=\\mathcal{T}(s)=\\frac{D_{c}(s) G(s)}{1+D_{c}(s) G(s) H(s)}$$\n\n极点为分母等于0时对应的根,换一种方式,求解根在K从0到无穷大对应的轨迹,\n就可以得到不同K下系统的极点,从而得到系统的脉冲响应函数\n\n$$1+K L(s)=0 \\text { where } L(s)=\\frac{b(s)}{a(s)}$$\n\n![close-loop](close-loop.png)\n\n根轨迹不局限于系统增益K,也可以求解相对于任何在特征方程中线性的参数的根轨迹\n\n比如在求解K=1是不同c下的根轨迹\n$$1+G(s)=1+\\frac{1}{s(s+c)}$$\n$$1+c \\frac{s}{s^{2}+1}=0$$\n\n# 根轨迹准则\nL(s)\n- b(s) 极点个数为n 用x表示\n- a(s) 零点个数为m 用o表示\n\n1. n条根轨迹从L(s)极点出发,m条轨迹终止于L(s)零点;\nn>m,则有n-m条根轨迹从极点指向无穷,反之m-n条轨迹从无穷指向零点\n\n    从根轨迹公式 $a(s)+K b(s)=0$ 可以得出K=0时,a(s)=0,即为L(s)的极点,K趋向于无穷时,b(s)=0,为L(s)的零点\n\n2. 根轨迹在实轴上从左往右奇数点左边有根轨迹.\n    \n    根轨迹方程的一种表示 $L(s)=-\\frac{1}{K}$ 从复数相位看左边的相位=右边的相位=180°\n    - 用$\\psi_{i}$表示零点对应项在复平面上任意一点对应的相角度,即零点指向对应点构成向量的角度\n    - 用$\\phi_{i}$表示极点对应项在复平面上任意一点对应的相角度,即极点点指向对应点构成向量的角度\n    $$\\sum \\psi_{i}-\\sum \\phi_{i}=180^{\\circ}+360^{\\circ}(l-1)$$\n    \n    为保证相位不难理解实轴上根轨迹需要在奇数点左边        \n    ![example](measureing phase.png)\n    \n3. 对于很大的s和K,n-m条根轨迹的渐近线为从实轴上中心点 $s=\\alpha$出发的射线,射线角度 $\\phi_{l}$ \n    \n    $$\\begin{aligned}\n    \\phi_{l} &=\\frac{180^{\\circ}+360^{\\circ}(l-1)}{n-m}, \\quad l=1,2, \\ldots, n-m \\\\\n    \\alpha &=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n    \\end{aligned}$$    \n\n    当K很大时变换根轨迹方程\n    $$1+K \\frac{\\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}{(s-\\alpha)^{n-m} \\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}=0$$\n    \n    从而得到\n    $$\\begin{aligned}\n    &(n-m) \\alpha+\\sum z_{i}=\\sum p_{i}\\\\\n    &\\alpha=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n    \\end{aligned}$$\n\n4. 一或多个极点从一个点离开的方向\n$$q \\phi_{l, d e p}=\\sum \\psi_{i}-\\sum \\phi_{i}-180^{\\circ}-360^{\\circ}(l-1)$$\n    可以用一个很靠近极点的点来推导角度,到达零点的方向也可类似推导\n    $$q \\psi_{l, a r r}=\\sum \\phi_{i}-\\sum \\psi_{i}+180^{\\circ}+360^{\\circ}(l-1)$$\n    可用于靠近虚轴方向的判断,看是否忘复平面左边走\n    \n5. 同一个点可以有q个根,从点离开的方向\n$$\\frac{180^{\\circ}+360^{\\circ}(l-1)}{q}$$\n\n# 应用\n$$H(s)=\\frac{s-z}{s-p}$$\n- 超前补偿器:|z|<|p|\n- 滞后补偿器:|p|<|z|\n可以看补偿器的伯德图来理解\n\n# 引用\n1. Feedback Control of Dynamic Systems by Gene F. Franklin\n2. [DR_CAN自动控制原理](https://www.bilibili.com/video/BV1JJ411i7ph?t=498)         \n    \n    ","source":"_posts/根轨迹.md","raw":"---\ntitle: 根轨迹\ndate: 2020-03-28 17:02:54\ncategories:\n- math\ntags:\n- 根轨迹\nmathjax: true\n\n---\n\n# 根轨迹定义\n一个基本的反馈系统传递函数为\n$$\\frac{Y(s)}{R(s)}=\\mathcal{T}(s)=\\frac{D_{c}(s) G(s)}{1+D_{c}(s) G(s) H(s)}$$\n\n极点为分母等于0时对应的根,换一种方式,求解根在K从0到无穷大对应的轨迹,\n就可以得到不同K下系统的极点,从而得到系统的脉冲响应函数\n\n$$1+K L(s)=0 \\text { where } L(s)=\\frac{b(s)}{a(s)}$$\n\n![close-loop](close-loop.png)\n\n根轨迹不局限于系统增益K,也可以求解相对于任何在特征方程中线性的参数的根轨迹\n\n比如在求解K=1是不同c下的根轨迹\n$$1+G(s)=1+\\frac{1}{s(s+c)}$$\n$$1+c \\frac{s}{s^{2}+1}=0$$\n\n# 根轨迹准则\nL(s)\n- b(s) 极点个数为n 用x表示\n- a(s) 零点个数为m 用o表示\n\n1. n条根轨迹从L(s)极点出发,m条轨迹终止于L(s)零点;\nn>m,则有n-m条根轨迹从极点指向无穷,反之m-n条轨迹从无穷指向零点\n\n    从根轨迹公式 $a(s)+K b(s)=0$ 可以得出K=0时,a(s)=0,即为L(s)的极点,K趋向于无穷时,b(s)=0,为L(s)的零点\n\n2. 根轨迹在实轴上从左往右奇数点左边有根轨迹.\n    \n    根轨迹方程的一种表示 $L(s)=-\\frac{1}{K}$ 从复数相位看左边的相位=右边的相位=180°\n    - 用$\\psi_{i}$表示零点对应项在复平面上任意一点对应的相角度,即零点指向对应点构成向量的角度\n    - 用$\\phi_{i}$表示极点对应项在复平面上任意一点对应的相角度,即极点点指向对应点构成向量的角度\n    $$\\sum \\psi_{i}-\\sum \\phi_{i}=180^{\\circ}+360^{\\circ}(l-1)$$\n    \n    为保证相位不难理解实轴上根轨迹需要在奇数点左边        \n    ![example](measureing phase.png)\n    \n3. 对于很大的s和K,n-m条根轨迹的渐近线为从实轴上中心点 $s=\\alpha$出发的射线,射线角度 $\\phi_{l}$ \n    \n    $$\\begin{aligned}\n    \\phi_{l} &=\\frac{180^{\\circ}+360^{\\circ}(l-1)}{n-m}, \\quad l=1,2, \\ldots, n-m \\\\\n    \\alpha &=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n    \\end{aligned}$$    \n\n    当K很大时变换根轨迹方程\n    $$1+K \\frac{\\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}{(s-\\alpha)^{n-m} \\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}=0$$\n    \n    从而得到\n    $$\\begin{aligned}\n    &(n-m) \\alpha+\\sum z_{i}=\\sum p_{i}\\\\\n    &\\alpha=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n    \\end{aligned}$$\n\n4. 一或多个极点从一个点离开的方向\n$$q \\phi_{l, d e p}=\\sum \\psi_{i}-\\sum \\phi_{i}-180^{\\circ}-360^{\\circ}(l-1)$$\n    可以用一个很靠近极点的点来推导角度,到达零点的方向也可类似推导\n    $$q \\psi_{l, a r r}=\\sum \\phi_{i}-\\sum \\psi_{i}+180^{\\circ}+360^{\\circ}(l-1)$$\n    可用于靠近虚轴方向的判断,看是否忘复平面左边走\n    \n5. 同一个点可以有q个根,从点离开的方向\n$$\\frac{180^{\\circ}+360^{\\circ}(l-1)}{q}$$\n\n# 应用\n$$H(s)=\\frac{s-z}{s-p}$$\n- 超前补偿器:|z|<|p|\n- 滞后补偿器:|p|<|z|\n可以看补偿器的伯德图来理解\n\n# 引用\n1. Feedback Control of Dynamic Systems by Gene F. Franklin\n2. [DR_CAN自动控制原理](https://www.bilibili.com/video/BV1JJ411i7ph?t=498)         \n    \n    ","slug":"根轨迹","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cif003zmxkacbfocpiu","content":"<h1 id=\"根轨迹定义\"><a href=\"#根轨迹定义\" class=\"headerlink\" title=\"根轨迹定义\"></a>根轨迹定义</h1><p>一个基本的反馈系统传递函数为</p>\n<script type=\"math/tex; mode=display\">\\frac{Y(s)}{R(s)}=\\mathcal{T}(s)=\\frac{D_{c}(s) G(s)}{1+D_{c}(s) G(s) H(s)}</script><p>极点为分母等于0时对应的根,换一种方式,求解根在K从0到无穷大对应的轨迹,<br>就可以得到不同K下系统的极点,从而得到系统的脉冲响应函数</p>\n<script type=\"math/tex; mode=display\">1+K L(s)=0 \\text { where } L(s)=\\frac{b(s)}{a(s)}</script><p><img src=\"/2020/03/28/根轨迹/close-loop.png\" alt=\"close-loop\"></p>\n<p>根轨迹不局限于系统增益K,也可以求解相对于任何在特征方程中线性的参数的根轨迹</p>\n<p>比如在求解K=1是不同c下的根轨迹</p>\n<script type=\"math/tex; mode=display\">1+G(s)=1+\\frac{1}{s(s+c)}</script><script type=\"math/tex; mode=display\">1+c \\frac{s}{s^{2}+1}=0</script><h1 id=\"根轨迹准则\"><a href=\"#根轨迹准则\" class=\"headerlink\" title=\"根轨迹准则\"></a>根轨迹准则</h1><p>L(s)</p>\n<ul>\n<li>b(s) 极点个数为n 用x表示</li>\n<li>a(s) 零点个数为m 用o表示</li>\n</ul>\n<ol>\n<li><p>n条根轨迹从L(s)极点出发,m条轨迹终止于L(s)零点;<br>n&gt;m,则有n-m条根轨迹从极点指向无穷,反之m-n条轨迹从无穷指向零点</p>\n<p> 从根轨迹公式 $a(s)+K b(s)=0$ 可以得出K=0时,a(s)=0,即为L(s)的极点,K趋向于无穷时,b(s)=0,为L(s)的零点</p>\n</li>\n<li><p>根轨迹在实轴上从左往右奇数点左边有根轨迹.</p>\n<p> 根轨迹方程的一种表示 $L(s)=-\\frac{1}{K}$ 从复数相位看左边的相位=右边的相位=180°</p>\n<ul>\n<li>用$\\psi_{i}$表示零点对应项在复平面上任意一点对应的相角度,即零点指向对应点构成向量的角度</li>\n<li><p>用$\\phi_{i}$表示极点对应项在复平面上任意一点对应的相角度,即极点点指向对应点构成向量的角度</p>\n<script type=\"math/tex; mode=display\">\\sum \\psi_{i}-\\sum \\phi_{i}=180^{\\circ}+360^{\\circ}(l-1)</script><p>为保证相位不难理解实轴上根轨迹需要在奇数点左边<br><img src=\"/2020/03/28/根轨迹/measureing phase.png\" alt=\"example\"></p>\n</li>\n</ul>\n</li>\n<li><p>对于很大的s和K,n-m条根轨迹的渐近线为从实轴上中心点 $s=\\alpha$出发的射线,射线角度 $\\phi_{l}$ </p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n \\phi_{l} &=\\frac{180^{\\circ}+360^{\\circ}(l-1)}{n-m}, \\quad l=1,2, \\ldots, n-m \\\\\n \\alpha &=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n \\end{aligned}</script><p> 当K很大时变换根轨迹方程</p>\n<script type=\"math/tex; mode=display\">1+K \\frac{\\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}{(s-\\alpha)^{n-m} \\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}=0</script><p> 从而得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n &(n-m) \\alpha+\\sum z_{i}=\\sum p_{i}\\\\\n &\\alpha=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n \\end{aligned}</script></li>\n<li><p>一或多个极点从一个点离开的方向</p>\n<script type=\"math/tex; mode=display\">q \\phi_{l, d e p}=\\sum \\psi_{i}-\\sum \\phi_{i}-180^{\\circ}-360^{\\circ}(l-1)</script><p> 可以用一个很靠近极点的点来推导角度,到达零点的方向也可类似推导</p>\n<script type=\"math/tex; mode=display\">q \\psi_{l, a r r}=\\sum \\phi_{i}-\\sum \\psi_{i}+180^{\\circ}+360^{\\circ}(l-1)</script><p> 可用于靠近虚轴方向的判断,看是否忘复平面左边走</p>\n</li>\n<li><p>同一个点可以有q个根,从点离开的方向</p>\n<script type=\"math/tex; mode=display\">\\frac{180^{\\circ}+360^{\\circ}(l-1)}{q}</script></li>\n</ol>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><script type=\"math/tex; mode=display\">H(s)=\\frac{s-z}{s-p}</script><ul>\n<li>超前补偿器:|z|&lt;|p|</li>\n<li>滞后补偿器:|p|&lt;|z|<br>可以看补偿器的伯德图来理解</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>Feedback Control of Dynamic Systems by Gene F. Franklin</li>\n<li><a href=\"https://www.bilibili.com/video/BV1JJ411i7ph?t=498\" target=\"_blank\" rel=\"noopener\">DR_CAN自动控制原理</a>         </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"根轨迹定义\"><a href=\"#根轨迹定义\" class=\"headerlink\" title=\"根轨迹定义\"></a>根轨迹定义</h1><p>一个基本的反馈系统传递函数为</p>\n<script type=\"math/tex; mode=display\">\\frac{Y(s)}{R(s)}=\\mathcal{T}(s)=\\frac{D_{c}(s) G(s)}{1+D_{c}(s) G(s) H(s)}</script><p>极点为分母等于0时对应的根,换一种方式,求解根在K从0到无穷大对应的轨迹,<br>就可以得到不同K下系统的极点,从而得到系统的脉冲响应函数</p>\n<script type=\"math/tex; mode=display\">1+K L(s)=0 \\text { where } L(s)=\\frac{b(s)}{a(s)}</script><p><img src=\"/2020/03/28/根轨迹/close-loop.png\" alt=\"close-loop\"></p>\n<p>根轨迹不局限于系统增益K,也可以求解相对于任何在特征方程中线性的参数的根轨迹</p>\n<p>比如在求解K=1是不同c下的根轨迹</p>\n<script type=\"math/tex; mode=display\">1+G(s)=1+\\frac{1}{s(s+c)}</script><script type=\"math/tex; mode=display\">1+c \\frac{s}{s^{2}+1}=0</script><h1 id=\"根轨迹准则\"><a href=\"#根轨迹准则\" class=\"headerlink\" title=\"根轨迹准则\"></a>根轨迹准则</h1><p>L(s)</p>\n<ul>\n<li>b(s) 极点个数为n 用x表示</li>\n<li>a(s) 零点个数为m 用o表示</li>\n</ul>\n<ol>\n<li><p>n条根轨迹从L(s)极点出发,m条轨迹终止于L(s)零点;<br>n&gt;m,则有n-m条根轨迹从极点指向无穷,反之m-n条轨迹从无穷指向零点</p>\n<p> 从根轨迹公式 $a(s)+K b(s)=0$ 可以得出K=0时,a(s)=0,即为L(s)的极点,K趋向于无穷时,b(s)=0,为L(s)的零点</p>\n</li>\n<li><p>根轨迹在实轴上从左往右奇数点左边有根轨迹.</p>\n<p> 根轨迹方程的一种表示 $L(s)=-\\frac{1}{K}$ 从复数相位看左边的相位=右边的相位=180°</p>\n<ul>\n<li>用$\\psi_{i}$表示零点对应项在复平面上任意一点对应的相角度,即零点指向对应点构成向量的角度</li>\n<li><p>用$\\phi_{i}$表示极点对应项在复平面上任意一点对应的相角度,即极点点指向对应点构成向量的角度</p>\n<script type=\"math/tex; mode=display\">\\sum \\psi_{i}-\\sum \\phi_{i}=180^{\\circ}+360^{\\circ}(l-1)</script><p>为保证相位不难理解实轴上根轨迹需要在奇数点左边<br><img src=\"/2020/03/28/根轨迹/measureing phase.png\" alt=\"example\"></p>\n</li>\n</ul>\n</li>\n<li><p>对于很大的s和K,n-m条根轨迹的渐近线为从实轴上中心点 $s=\\alpha$出发的射线,射线角度 $\\phi_{l}$ </p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n \\phi_{l} &=\\frac{180^{\\circ}+360^{\\circ}(l-1)}{n-m}, \\quad l=1,2, \\ldots, n-m \\\\\n \\alpha &=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n \\end{aligned}</script><p> 当K很大时变换根轨迹方程</p>\n<script type=\"math/tex; mode=display\">1+K \\frac{\\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}{(s-\\alpha)^{n-m} \\Pi_{i=1}^{m}\\left(s-z_{i}\\right)}=0</script><p> 从而得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n &(n-m) \\alpha+\\sum z_{i}=\\sum p_{i}\\\\\n &\\alpha=\\frac{\\sum p_{i}-\\sum z_{i}}{n-m}\n \\end{aligned}</script></li>\n<li><p>一或多个极点从一个点离开的方向</p>\n<script type=\"math/tex; mode=display\">q \\phi_{l, d e p}=\\sum \\psi_{i}-\\sum \\phi_{i}-180^{\\circ}-360^{\\circ}(l-1)</script><p> 可以用一个很靠近极点的点来推导角度,到达零点的方向也可类似推导</p>\n<script type=\"math/tex; mode=display\">q \\psi_{l, a r r}=\\sum \\phi_{i}-\\sum \\psi_{i}+180^{\\circ}+360^{\\circ}(l-1)</script><p> 可用于靠近虚轴方向的判断,看是否忘复平面左边走</p>\n</li>\n<li><p>同一个点可以有q个根,从点离开的方向</p>\n<script type=\"math/tex; mode=display\">\\frac{180^{\\circ}+360^{\\circ}(l-1)}{q}</script></li>\n</ol>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><script type=\"math/tex; mode=display\">H(s)=\\frac{s-z}{s-p}</script><ul>\n<li>超前补偿器:|z|&lt;|p|</li>\n<li>滞后补偿器:|p|&lt;|z|<br>可以看补偿器的伯德图来理解</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li>Feedback Control of Dynamic Systems by Gene F. Franklin</li>\n<li><a href=\"https://www.bilibili.com/video/BV1JJ411i7ph?t=498\" target=\"_blank\" rel=\"noopener\">DR_CAN自动控制原理</a>         </li>\n</ol>\n"},{"title":"理解补码","date":"2020-03-12T23:31:28.000Z","mathjax":true,"_content":"这里取8位有符号数来说明\n\n# 原码,反码,补码\n这里针对有符号数\n- 原码:最高位表示符号,整数为0,负数为1,其余部分为数绝对值的二进制表示.如-3 表示为1000 0011\n- 反码:正数反码为本身,负数,保留符号位,其余位取反\n- 补码:整数补码为本身,负数,保留符号位,其余为取反加1\n- 形式值:将符号位作为实际含义,1000 0001 原码表示-1 ,形式值表示2^7+2^0 (考虑符号位) \n\n计算机的加减乘除是最基本的运算,需要设计得尽可能简单,设计的初衷就是想用一种编码实现加减 **a-b = a+(-b)**\n \n1. 原码,人脑最容易理解的方式,但是计算机不同,需要额外处理符号位是很麻烦,\n    1-1=0000 0001(原)+1000 0001(原)=1000 0010(原)=-2 这是不符号运算的\n\n2. 反码,原码1000 0110 的补码是1111 1001.可以看出负数的补码(形式值)与自身的绝对值之和为1111 1111 (255)\n这里只看数值运算,结合整数的补码就是本身,反码的实质就是取余运算 %1111 1111 (mod 255),理解可结合下面[这张图](https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81)\n    ![反码](fanma.png)\n    还有一种理解:不看符号位,对于数值部分取反之后和之前和恒为0111 1111,可以看出是对数值部分取余即%0111 1111(%127).\n\n    反码存在的问题,\n    \n    1. 0 的表示有两种,浪费了一个二进制数 0000 0000(原) 1000 0000(原) 反码分别是0000 0000 和 1111 1111\n    2. 无法保证减法运算,如 2-1 = 0000 0010(反) + 1111 1110(反) = 0000 0000(原)\n        1-1 之类是对的1111 1111(反) = 1000 0000(原) \n    \n3. 补码,同反码一样,不过多了+1,相当于%256 (1000 0000)\n    1. 引入加1之后巧妙解决了0的表示问题,0000 0000(原) 和1000 0000(原)对应的补码都是0000 0000(补)\n        那现在用1000 0000表示什么数呢? 1000 0000(补) + 0000 0001(补)=1000 0001(补)=1111 1111(原)=-127\n        所以用1000 0000表示-128,没有对应的原码和反码 所以8为有符号二进制为\\[-128,127\\]\n    2. 保证了减法运算,这里用了[同余的性质](https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98)  \n    $$\n    \\left.\\begin{array}{l}\n    a \\equiv b(\\bmod m) \\\\\n    c \\equiv d(\\bmod m)\n    \\end{array}\\right\\} \\Rightarrow\\left\\{\\begin{array}{c}\n    a \\pm c \\equiv b \\pm d(\\bmod m) \\\\\n    a c \\equiv b d(\\bmod m)\n    \\end{array}\\right.\n    $$  \n    \n        如(2-1)%256 = (2 + (-1))%256 = (2+(-1%256)) %256 = 1 最后一步%256 是通过高位溢出达到的\n    \n    3. 用补码的第二种解释%128,解释为什么负数补码的补码就是负数本身,因为保留了符号位,数值部分两次取余%128%128为本身  \n        如给定1000 0001(原),则取补码为1111 1111(补),再求补码1000 0001\n    4. 但是为什么反码不对呢?反码也是取余,主要是因为反码0的两种表示方式值相差1\n    \n        0+1 = 1000 0000(原) + 0000 0001(原)=1111 1111(反)+0000 0001(反)=0000 0000=0\n        即0+1=0;这才是问题所在,0的两种表达方式导致了溢出处理有问题\n\n# 补码性质\n写这里是因为一道剑指offer的题解,很精妙:[输入一个整数,输出该数二进制表示中1的个数.其中负数用补码表示.](https://www.nowcoder.com/profile/9536154/codeBookDetail?submissionId=17465787)\n\n首先需要说明的是数在计算机中存储是用补码的形式\n\n针对a-1的问题\n1. 首先看正数,a-1 就是a的二进制从右至左第一位1借位,对应位变0,右边的都变成1 如0000 1100 - 1 = 0000 1011\n2. 负数,还是要用到同余 (a-1)%256 = ((a%256)-1)%256 如(-5-1)%256 等式左边=250=右边=1111 1010-1=1111 1001 同正数一样\n**总的来说补码表示的数可以直接按照正数的加减法来运算(包括-1),这也是补码设计的初衷:统一加减法**即计算机运算直接用补码的形式值来计算,输出转换为原码就可以了\n\n注意:负数右移或者/2左边补1,最小的数是-1(即1111 1111),所以在求一个数有多少位1时不要动这个数,而是移动取的位,比如a & b,是把b左移,而不是把原数右移\n    \n## 引用\n1. [原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）](https://blog.csdn.net/zl10086111/article/details/80907428)\n2. [维基百科:补码](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)\n3. [同余](https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98)","source":"_posts/理解补码.md","raw":"---\ntitle: 理解补码\ndate: 2020-03-13 07:31:28\ncategories:\n- program\ntags:\n- 补码\nmathjax: true\n---\n这里取8位有符号数来说明\n\n# 原码,反码,补码\n这里针对有符号数\n- 原码:最高位表示符号,整数为0,负数为1,其余部分为数绝对值的二进制表示.如-3 表示为1000 0011\n- 反码:正数反码为本身,负数,保留符号位,其余位取反\n- 补码:整数补码为本身,负数,保留符号位,其余为取反加1\n- 形式值:将符号位作为实际含义,1000 0001 原码表示-1 ,形式值表示2^7+2^0 (考虑符号位) \n\n计算机的加减乘除是最基本的运算,需要设计得尽可能简单,设计的初衷就是想用一种编码实现加减 **a-b = a+(-b)**\n \n1. 原码,人脑最容易理解的方式,但是计算机不同,需要额外处理符号位是很麻烦,\n    1-1=0000 0001(原)+1000 0001(原)=1000 0010(原)=-2 这是不符号运算的\n\n2. 反码,原码1000 0110 的补码是1111 1001.可以看出负数的补码(形式值)与自身的绝对值之和为1111 1111 (255)\n这里只看数值运算,结合整数的补码就是本身,反码的实质就是取余运算 %1111 1111 (mod 255),理解可结合下面[这张图](https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81)\n    ![反码](fanma.png)\n    还有一种理解:不看符号位,对于数值部分取反之后和之前和恒为0111 1111,可以看出是对数值部分取余即%0111 1111(%127).\n\n    反码存在的问题,\n    \n    1. 0 的表示有两种,浪费了一个二进制数 0000 0000(原) 1000 0000(原) 反码分别是0000 0000 和 1111 1111\n    2. 无法保证减法运算,如 2-1 = 0000 0010(反) + 1111 1110(反) = 0000 0000(原)\n        1-1 之类是对的1111 1111(反) = 1000 0000(原) \n    \n3. 补码,同反码一样,不过多了+1,相当于%256 (1000 0000)\n    1. 引入加1之后巧妙解决了0的表示问题,0000 0000(原) 和1000 0000(原)对应的补码都是0000 0000(补)\n        那现在用1000 0000表示什么数呢? 1000 0000(补) + 0000 0001(补)=1000 0001(补)=1111 1111(原)=-127\n        所以用1000 0000表示-128,没有对应的原码和反码 所以8为有符号二进制为\\[-128,127\\]\n    2. 保证了减法运算,这里用了[同余的性质](https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98)  \n    $$\n    \\left.\\begin{array}{l}\n    a \\equiv b(\\bmod m) \\\\\n    c \\equiv d(\\bmod m)\n    \\end{array}\\right\\} \\Rightarrow\\left\\{\\begin{array}{c}\n    a \\pm c \\equiv b \\pm d(\\bmod m) \\\\\n    a c \\equiv b d(\\bmod m)\n    \\end{array}\\right.\n    $$  \n    \n        如(2-1)%256 = (2 + (-1))%256 = (2+(-1%256)) %256 = 1 最后一步%256 是通过高位溢出达到的\n    \n    3. 用补码的第二种解释%128,解释为什么负数补码的补码就是负数本身,因为保留了符号位,数值部分两次取余%128%128为本身  \n        如给定1000 0001(原),则取补码为1111 1111(补),再求补码1000 0001\n    4. 但是为什么反码不对呢?反码也是取余,主要是因为反码0的两种表示方式值相差1\n    \n        0+1 = 1000 0000(原) + 0000 0001(原)=1111 1111(反)+0000 0001(反)=0000 0000=0\n        即0+1=0;这才是问题所在,0的两种表达方式导致了溢出处理有问题\n\n# 补码性质\n写这里是因为一道剑指offer的题解,很精妙:[输入一个整数,输出该数二进制表示中1的个数.其中负数用补码表示.](https://www.nowcoder.com/profile/9536154/codeBookDetail?submissionId=17465787)\n\n首先需要说明的是数在计算机中存储是用补码的形式\n\n针对a-1的问题\n1. 首先看正数,a-1 就是a的二进制从右至左第一位1借位,对应位变0,右边的都变成1 如0000 1100 - 1 = 0000 1011\n2. 负数,还是要用到同余 (a-1)%256 = ((a%256)-1)%256 如(-5-1)%256 等式左边=250=右边=1111 1010-1=1111 1001 同正数一样\n**总的来说补码表示的数可以直接按照正数的加减法来运算(包括-1),这也是补码设计的初衷:统一加减法**即计算机运算直接用补码的形式值来计算,输出转换为原码就可以了\n\n注意:负数右移或者/2左边补1,最小的数是-1(即1111 1111),所以在求一个数有多少位1时不要动这个数,而是移动取的位,比如a & b,是把b左移,而不是把原数右移\n    \n## 引用\n1. [原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）](https://blog.csdn.net/zl10086111/article/details/80907428)\n2. [维基百科:补码](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)\n3. [同余](https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98)","slug":"理解补码","published":1,"updated":"2020-09-23T14:42:00.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cih0042mxkawbhb9iat","content":"<p>这里取8位有符号数来说明</p>\n<h1 id=\"原码-反码-补码\"><a href=\"#原码-反码-补码\" class=\"headerlink\" title=\"原码,反码,补码\"></a>原码,反码,补码</h1><p>这里针对有符号数</p>\n<ul>\n<li>原码:最高位表示符号,整数为0,负数为1,其余部分为数绝对值的二进制表示.如-3 表示为1000 0011</li>\n<li>反码:正数反码为本身,负数,保留符号位,其余位取反</li>\n<li>补码:整数补码为本身,负数,保留符号位,其余为取反加1</li>\n<li>形式值:将符号位作为实际含义,1000 0001 原码表示-1 ,形式值表示2^7+2^0 (考虑符号位) </li>\n</ul>\n<p>计算机的加减乘除是最基本的运算,需要设计得尽可能简单,设计的初衷就是想用一种编码实现加减 <strong>a-b = a+(-b)</strong></p>\n<ol>\n<li><p>原码,人脑最容易理解的方式,但是计算机不同,需要额外处理符号位是很麻烦,<br> 1-1=0000 0001(原)+1000 0001(原)=1000 0010(原)=-2 这是不符号运算的</p>\n</li>\n<li><p>反码,原码1000 0110 的补码是1111 1001.可以看出负数的补码(形式值)与自身的绝对值之和为1111 1111 (255)<br>这里只看数值运算,结合整数的补码就是本身,反码的实质就是取余运算 %1111 1111 (mod 255),理解可结合下面<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81\" target=\"_blank\" rel=\"noopener\">这张图</a><br> <img src=\"/2020/03/13/理解补码/fanma.png\" alt=\"反码\"><br> 还有一种理解:不看符号位,对于数值部分取反之后和之前和恒为0111 1111,可以看出是对数值部分取余即%0111 1111(%127).</p>\n<p> 反码存在的问题,</p>\n<ol>\n<li>0 的表示有两种,浪费了一个二进制数 0000 0000(原) 1000 0000(原) 反码分别是0000 0000 和 1111 1111</li>\n<li>无法保证减法运算,如 2-1 = 0000 0010(反) + 1111 1110(反) = 0000 0000(原)<br> 1-1 之类是对的1111 1111(反) = 1000 0000(原) </li>\n</ol>\n</li>\n<li><p>补码,同反码一样,不过多了+1,相当于%256 (1000 0000)</p>\n<ol>\n<li>引入加1之后巧妙解决了0的表示问题,0000 0000(原) 和1000 0000(原)对应的补码都是0000 0000(补)<br> 那现在用1000 0000表示什么数呢? 1000 0000(补) + 0000 0001(补)=1000 0001(补)=1111 1111(原)=-127<br> 所以用1000 0000表示-128,没有对应的原码和反码 所以8为有符号二进制为[-128,127]</li>\n<li><p>保证了减法运算,这里用了<a href=\"https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98\" target=\"_blank\" rel=\"noopener\">同余的性质</a>  </p>\n<script type=\"math/tex; mode=display\">\n\\left.\\begin{array}{l}\na \\equiv b(\\bmod m) \\\\\nc \\equiv d(\\bmod m)\n\\end{array}\\right\\} \\Rightarrow\\left\\{\\begin{array}{c}\na \\pm c \\equiv b \\pm d(\\bmod m) \\\\\na c \\equiv b d(\\bmod m)\n\\end{array}\\right.</script><p> 如(2-1)%256 = (2 + (-1))%256 = (2+(-1%256)) %256 = 1 最后一步%256 是通过高位溢出达到的</p>\n</li>\n<li><p>用补码的第二种解释%128,解释为什么负数补码的补码就是负数本身,因为保留了符号位,数值部分两次取余%128%128为本身<br> 如给定1000 0001(原),则取补码为1111 1111(补),再求补码1000 0001</p>\n</li>\n<li><p>但是为什么反码不对呢?反码也是取余,主要是因为反码0的两种表示方式值相差1</p>\n<p> 0+1 = 1000 0000(原) + 0000 0001(原)=1111 1111(反)+0000 0001(反)=0000 0000=0<br> 即0+1=0;这才是问题所在,0的两种表达方式导致了溢出处理有问题</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"补码性质\"><a href=\"#补码性质\" class=\"headerlink\" title=\"补码性质\"></a>补码性质</h1><p>写这里是因为一道剑指offer的题解,很精妙:<a href=\"https://www.nowcoder.com/profile/9536154/codeBookDetail?submissionId=17465787\" target=\"_blank\" rel=\"noopener\">输入一个整数,输出该数二进制表示中1的个数.其中负数用补码表示.</a></p>\n<p>首先需要说明的是数在计算机中存储是用补码的形式</p>\n<p>针对a-1的问题</p>\n<ol>\n<li>首先看正数,a-1 就是a的二进制从右至左第一位1借位,对应位变0,右边的都变成1 如0000 1100 - 1 = 0000 1011</li>\n<li>负数,还是要用到同余 (a-1)%256 = ((a%256)-1)%256 如(-5-1)%256 等式左边=250=右边=1111 1010-1=1111 1001 同正数一样<br><strong>总的来说补码表示的数可以直接按照正数的加减法来运算(包括-1),这也是补码设计的初衷:统一加减法</strong>即计算机运算直接用补码的形式值来计算,输出转换为原码就可以了</li>\n</ol>\n<p>注意:负数右移或者/2左边补1,最小的数是-1(即1111 1111),所以在求一个数有多少位1时不要动这个数,而是移动取的位,比如a &amp; b,是把b左移,而不是把原数右移</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/zl10086111/article/details/80907428\" target=\"_blank\" rel=\"noopener\">原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8\" target=\"_blank\" rel=\"noopener\">维基百科:补码</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98\" target=\"_blank\" rel=\"noopener\">同余</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这里取8位有符号数来说明</p>\n<h1 id=\"原码-反码-补码\"><a href=\"#原码-反码-补码\" class=\"headerlink\" title=\"原码,反码,补码\"></a>原码,反码,补码</h1><p>这里针对有符号数</p>\n<ul>\n<li>原码:最高位表示符号,整数为0,负数为1,其余部分为数绝对值的二进制表示.如-3 表示为1000 0011</li>\n<li>反码:正数反码为本身,负数,保留符号位,其余位取反</li>\n<li>补码:整数补码为本身,负数,保留符号位,其余为取反加1</li>\n<li>形式值:将符号位作为实际含义,1000 0001 原码表示-1 ,形式值表示2^7+2^0 (考虑符号位) </li>\n</ul>\n<p>计算机的加减乘除是最基本的运算,需要设计得尽可能简单,设计的初衷就是想用一种编码实现加减 <strong>a-b = a+(-b)</strong></p>\n<ol>\n<li><p>原码,人脑最容易理解的方式,但是计算机不同,需要额外处理符号位是很麻烦,<br> 1-1=0000 0001(原)+1000 0001(原)=1000 0010(原)=-2 这是不符号运算的</p>\n</li>\n<li><p>反码,原码1000 0110 的补码是1111 1001.可以看出负数的补码(形式值)与自身的绝对值之和为1111 1111 (255)<br>这里只看数值运算,结合整数的补码就是本身,反码的实质就是取余运算 %1111 1111 (mod 255),理解可结合下面<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81\" target=\"_blank\" rel=\"noopener\">这张图</a><br> <img src=\"/2020/03/13/理解补码/fanma.png\" alt=\"反码\"><br> 还有一种理解:不看符号位,对于数值部分取反之后和之前和恒为0111 1111,可以看出是对数值部分取余即%0111 1111(%127).</p>\n<p> 反码存在的问题,</p>\n<ol>\n<li>0 的表示有两种,浪费了一个二进制数 0000 0000(原) 1000 0000(原) 反码分别是0000 0000 和 1111 1111</li>\n<li>无法保证减法运算,如 2-1 = 0000 0010(反) + 1111 1110(反) = 0000 0000(原)<br> 1-1 之类是对的1111 1111(反) = 1000 0000(原) </li>\n</ol>\n</li>\n<li><p>补码,同反码一样,不过多了+1,相当于%256 (1000 0000)</p>\n<ol>\n<li>引入加1之后巧妙解决了0的表示问题,0000 0000(原) 和1000 0000(原)对应的补码都是0000 0000(补)<br> 那现在用1000 0000表示什么数呢? 1000 0000(补) + 0000 0001(补)=1000 0001(补)=1111 1111(原)=-127<br> 所以用1000 0000表示-128,没有对应的原码和反码 所以8为有符号二进制为[-128,127]</li>\n<li><p>保证了减法运算,这里用了<a href=\"https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98\" target=\"_blank\" rel=\"noopener\">同余的性质</a>  </p>\n<script type=\"math/tex; mode=display\">\n\\left.\\begin{array}{l}\na \\equiv b(\\bmod m) \\\\\nc \\equiv d(\\bmod m)\n\\end{array}\\right\\} \\Rightarrow\\left\\{\\begin{array}{c}\na \\pm c \\equiv b \\pm d(\\bmod m) \\\\\na c \\equiv b d(\\bmod m)\n\\end{array}\\right.</script><p> 如(2-1)%256 = (2 + (-1))%256 = (2+(-1%256)) %256 = 1 最后一步%256 是通过高位溢出达到的</p>\n</li>\n<li><p>用补码的第二种解释%128,解释为什么负数补码的补码就是负数本身,因为保留了符号位,数值部分两次取余%128%128为本身<br> 如给定1000 0001(原),则取补码为1111 1111(补),再求补码1000 0001</p>\n</li>\n<li><p>但是为什么反码不对呢?反码也是取余,主要是因为反码0的两种表示方式值相差1</p>\n<p> 0+1 = 1000 0000(原) + 0000 0001(原)=1111 1111(反)+0000 0001(反)=0000 0000=0<br> 即0+1=0;这才是问题所在,0的两种表达方式导致了溢出处理有问题</p>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"补码性质\"><a href=\"#补码性质\" class=\"headerlink\" title=\"补码性质\"></a>补码性质</h1><p>写这里是因为一道剑指offer的题解,很精妙:<a href=\"https://www.nowcoder.com/profile/9536154/codeBookDetail?submissionId=17465787\" target=\"_blank\" rel=\"noopener\">输入一个整数,输出该数二进制表示中1的个数.其中负数用补码表示.</a></p>\n<p>首先需要说明的是数在计算机中存储是用补码的形式</p>\n<p>针对a-1的问题</p>\n<ol>\n<li>首先看正数,a-1 就是a的二进制从右至左第一位1借位,对应位变0,右边的都变成1 如0000 1100 - 1 = 0000 1011</li>\n<li>负数,还是要用到同余 (a-1)%256 = ((a%256)-1)%256 如(-5-1)%256 等式左边=250=右边=1111 1010-1=1111 1001 同正数一样<br><strong>总的来说补码表示的数可以直接按照正数的加减法来运算(包括-1),这也是补码设计的初衷:统一加减法</strong>即计算机运算直接用补码的形式值来计算,输出转换为原码就可以了</li>\n</ol>\n<p>注意:负数右移或者/2左边补1,最小的数是-1(即1111 1111),所以在求一个数有多少位1时不要动这个数,而是移动取的位,比如a &amp; b,是把b左移,而不是把原数右移</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/zl10086111/article/details/80907428\" target=\"_blank\" rel=\"noopener\">原码、反码、补码知识详细讲解（此作者是我找到的讲的最细最明白的一个）</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8\" target=\"_blank\" rel=\"noopener\">维基百科:补码</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98\" target=\"_blank\" rel=\"noopener\">同余</a></li>\n</ol>\n"},{"title":"正交函数","date":"2019-07-18T12:17:03.000Z","mathjax":true,"_content":"\n定义\n---\n若对于函数系S中任意两个函数内积为0即\n\n$$\n\\forall i \\neq j, \\int_{a}^{b} f_{i}(x) \\cdot f_{j}(x) d x=0\n$$\n\n则称S为[a,b]上的正交函数系\n\n如傅里叶变换的三角函数系\n变换的系数就是函数在基函数上的投影，即函数与相应基函数内积\n自相关函数同\n功率信号自相关\n\n$$\nR_{x}(\\tau)=\\lim _{T \\rightarrow \\infty} \\frac{1}{T} \\int_{0}^{T} x(t) x(t+\\tau) \\mathrm{d} t\n$$\n\n能量信号自相关\n\n\n\n当信号中有周期成分时，其自相关函数在 t 很大时都不衰减\n互相关函数同，有同频率周期成分，则相关函数不收敛，且出现该频率的周期成分\n\n引用\n---\n1. [正交函数集合](https://blog.csdn.net/Einstellung/article/details/77478203)","source":"_posts/正交函数.md","raw":"---\ntitle: 正交函数\ndate: 2019-07-18 20:17:03\ncategories:\n- math\ntags:\n- 信号分析\nmathjax: true\n\n---\n\n定义\n---\n若对于函数系S中任意两个函数内积为0即\n\n$$\n\\forall i \\neq j, \\int_{a}^{b} f_{i}(x) \\cdot f_{j}(x) d x=0\n$$\n\n则称S为[a,b]上的正交函数系\n\n如傅里叶变换的三角函数系\n变换的系数就是函数在基函数上的投影，即函数与相应基函数内积\n自相关函数同\n功率信号自相关\n\n$$\nR_{x}(\\tau)=\\lim _{T \\rightarrow \\infty} \\frac{1}{T} \\int_{0}^{T} x(t) x(t+\\tau) \\mathrm{d} t\n$$\n\n能量信号自相关\n\n\n\n当信号中有周期成分时，其自相关函数在 t 很大时都不衰减\n互相关函数同，有同频率周期成分，则相关函数不收敛，且出现该频率的周期成分\n\n引用\n---\n1. [正交函数集合](https://blog.csdn.net/Einstellung/article/details/77478203)","slug":"正交函数","published":1,"updated":"2020-09-23T14:42:00.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cii0045mxka3wqy8yxi","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>若对于函数系S中任意两个函数内积为0即</p>\n<script type=\"math/tex; mode=display\">\n\\forall i \\neq j, \\int_{a}^{b} f_{i}(x) \\cdot f_{j}(x) d x=0</script><p>则称S为[a,b]上的正交函数系</p>\n<p>如傅里叶变换的三角函数系<br>变换的系数就是函数在基函数上的投影，即函数与相应基函数内积<br>自相关函数同<br>功率信号自相关</p>\n<script type=\"math/tex; mode=display\">\nR_{x}(\\tau)=\\lim _{T \\rightarrow \\infty} \\frac{1}{T} \\int_{0}^{T} x(t) x(t+\\tau) \\mathrm{d} t</script><p>能量信号自相关</p>\n<p>当信号中有周期成分时，其自相关函数在 t 很大时都不衰减<br>互相关函数同，有同频率周期成分，则相关函数不收敛，且出现该频率的周期成分</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/Einstellung/article/details/77478203\" target=\"_blank\" rel=\"noopener\">正交函数集合</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>若对于函数系S中任意两个函数内积为0即</p>\n<script type=\"math/tex; mode=display\">\n\\forall i \\neq j, \\int_{a}^{b} f_{i}(x) \\cdot f_{j}(x) d x=0</script><p>则称S为[a,b]上的正交函数系</p>\n<p>如傅里叶变换的三角函数系<br>变换的系数就是函数在基函数上的投影，即函数与相应基函数内积<br>自相关函数同<br>功率信号自相关</p>\n<script type=\"math/tex; mode=display\">\nR_{x}(\\tau)=\\lim _{T \\rightarrow \\infty} \\frac{1}{T} \\int_{0}^{T} x(t) x(t+\\tau) \\mathrm{d} t</script><p>能量信号自相关</p>\n<p>当信号中有周期成分时，其自相关函数在 t 很大时都不衰减<br>互相关函数同，有同频率周期成分，则相关函数不收敛，且出现该频率的周期成分</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/Einstellung/article/details/77478203\" target=\"_blank\" rel=\"noopener\">正交函数集合</a></li>\n</ol>\n"},{"title":"用户权限管理","date":"2019-09-30T15:22:20.000Z","_content":"# 用户管理命令\n## 用户\n    adduser     # 交互形式   \n    useradd\n    \n    finger -l yang     # 显示用户相关信息\n    chfn        # 修改用户个人信息\n    passwd      # 更改密码\n    id          # 显示用户UID GID\n    usemod      # 修改用户登录信息 用户组g\n    sudo usermod -aG sudo yang      #普通用户添加sudo\n    \n    deluser --remove-all-files yang  # 交互\n    deluser  yang  sudo     # 从sudo组删除用户yang\n    userdel\n    \n    su yang     #切换用户\n    cat /etc/passwd #查看所有用户 与管道结合更方便grep\n    \n## 用户组\n    addgroup    #系统用户组\n    groupadd\n    groups      #显示用户对应的组\n    groupmod    #更改用户组名称 ID\n    \n    delgroup\n    groupdel   \n    \n    cat /etc/group  #查看所用用户组 \n    \n## 权限管理\n    chmod\n    chown   #修改文件、目录归属用户或组\n    chgrp   #修改文件或目录的归属组   \n    \n# 文件预设权限 umask\n文件: -rw-rw-rw-  666\n\n目录: drwxrwxrwx  777      \n默认权限-umask权限就是创建文件的默认权限\n       \n       umask\n       umask -S #查看文件预设权限\n       umask 022    #设定umask权限\n## 隐藏属性\nchattr 指令只能在Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效   \n其他的文件系统可能就无法完整的支持这个\n指令了,例如 xfs 仅支持部份参数而已  \n    \n    chattr +i filename  #文件不可更改\n    chattr +a filename  #只能增加内容 不能删除和修改\n    lsattr  filename    #查看文件隐藏属性\n## 特殊权限 SUID, SGID, SBIT\nSUID不是用在目录上,而 SBIT 不是用在文件上\n1. Set UID\n\n    s在user位置\n    \n    /usr/bin/passwd 的-rwsr-xr-x 中的s\n    1. SUID 权限仅对二进制程序(binary program)有效;\n    2. 执行者对于该程序需要具有 x 的可执行权限;\n    3. 本权限仅在执行该程序的过程中有效 (run-time);\n    4. **执行者将具有该程序拥有者 (owner) 的权限**。如果拥有者都没有执行权限 则执行者这个权限为S 空的意思\n    \n    例如普通用户更改密码 调用passwd时就会暂时具有root权限,而使用cat查看密码不属于执行,所以不具有执行权限\n    \n    文件具有 SUID 的特殊权限时,代表当用户执行此一 binary 程序时,在执行过程中用户会暂时具有程序拥有\n    者的权限\n       \n2. Set GID       \n    \n    s在group的位置\n    \n    1. SGID 对二进制程序有用;\n    2. 程序执行者对于该程序来说,需具备 x 的权限;\n    3. 执行者在执行的过程中将会获得该程序群组的支持!\n    \n    目录具有 SGID 的特殊权限时,代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。    \n3. Sticky Bit\n\n    只针对目录有效\n    \n    1. 当用户对于此目录具有 w, x 权限,亦即具有写入的权限时;\n    2. 当用户在该目录下建立文件或目录时,仅有自己与 root 才有权力删除该文件\n    \n    例如/tmp 的权限是 drwxrwxrwt\n    \n    目录具有 SBIT 的特殊权限时,代表在该目录下用户建立的文件只有自己与 root 能够删除!\n\n### 特殊权限的修改\n- 4 为 SUID\n- 2 为 SGID\n- 1 为 SBIT  \n    \n      chmod 4755 filename   # 增加SUID         \n\n    \n# 参考\n","source":"_posts/用户权限管理.md","raw":"---\ntitle: 用户权限管理\ndate: 2019-09-30 23:22:20\ncategories:\n- Linux\ntags:\n- 权限\n\n---\n# 用户管理命令\n## 用户\n    adduser     # 交互形式   \n    useradd\n    \n    finger -l yang     # 显示用户相关信息\n    chfn        # 修改用户个人信息\n    passwd      # 更改密码\n    id          # 显示用户UID GID\n    usemod      # 修改用户登录信息 用户组g\n    sudo usermod -aG sudo yang      #普通用户添加sudo\n    \n    deluser --remove-all-files yang  # 交互\n    deluser  yang  sudo     # 从sudo组删除用户yang\n    userdel\n    \n    su yang     #切换用户\n    cat /etc/passwd #查看所有用户 与管道结合更方便grep\n    \n## 用户组\n    addgroup    #系统用户组\n    groupadd\n    groups      #显示用户对应的组\n    groupmod    #更改用户组名称 ID\n    \n    delgroup\n    groupdel   \n    \n    cat /etc/group  #查看所用用户组 \n    \n## 权限管理\n    chmod\n    chown   #修改文件、目录归属用户或组\n    chgrp   #修改文件或目录的归属组   \n    \n# 文件预设权限 umask\n文件: -rw-rw-rw-  666\n\n目录: drwxrwxrwx  777      \n默认权限-umask权限就是创建文件的默认权限\n       \n       umask\n       umask -S #查看文件预设权限\n       umask 022    #设定umask权限\n## 隐藏属性\nchattr 指令只能在Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效   \n其他的文件系统可能就无法完整的支持这个\n指令了,例如 xfs 仅支持部份参数而已  \n    \n    chattr +i filename  #文件不可更改\n    chattr +a filename  #只能增加内容 不能删除和修改\n    lsattr  filename    #查看文件隐藏属性\n## 特殊权限 SUID, SGID, SBIT\nSUID不是用在目录上,而 SBIT 不是用在文件上\n1. Set UID\n\n    s在user位置\n    \n    /usr/bin/passwd 的-rwsr-xr-x 中的s\n    1. SUID 权限仅对二进制程序(binary program)有效;\n    2. 执行者对于该程序需要具有 x 的可执行权限;\n    3. 本权限仅在执行该程序的过程中有效 (run-time);\n    4. **执行者将具有该程序拥有者 (owner) 的权限**。如果拥有者都没有执行权限 则执行者这个权限为S 空的意思\n    \n    例如普通用户更改密码 调用passwd时就会暂时具有root权限,而使用cat查看密码不属于执行,所以不具有执行权限\n    \n    文件具有 SUID 的特殊权限时,代表当用户执行此一 binary 程序时,在执行过程中用户会暂时具有程序拥有\n    者的权限\n       \n2. Set GID       \n    \n    s在group的位置\n    \n    1. SGID 对二进制程序有用;\n    2. 程序执行者对于该程序来说,需具备 x 的权限;\n    3. 执行者在执行的过程中将会获得该程序群组的支持!\n    \n    目录具有 SGID 的特殊权限时,代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。    \n3. Sticky Bit\n\n    只针对目录有效\n    \n    1. 当用户对于此目录具有 w, x 权限,亦即具有写入的权限时;\n    2. 当用户在该目录下建立文件或目录时,仅有自己与 root 才有权力删除该文件\n    \n    例如/tmp 的权限是 drwxrwxrwt\n    \n    目录具有 SBIT 的特殊权限时,代表在该目录下用户建立的文件只有自己与 root 能够删除!\n\n### 特殊权限的修改\n- 4 为 SUID\n- 2 为 SGID\n- 1 为 SBIT  \n    \n      chmod 4755 filename   # 增加SUID         \n\n    \n# 参考\n","slug":"用户权限管理","published":1,"updated":"2020-09-23T14:42:00.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cij0049mxkakp7mtyv2","content":"<h1 id=\"用户管理命令\"><a href=\"#用户管理命令\" class=\"headerlink\" title=\"用户管理命令\"></a>用户管理命令</h1><h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><pre><code>adduser     # 交互形式   \nuseradd\n\nfinger -l yang     # 显示用户相关信息\nchfn        # 修改用户个人信息\npasswd      # 更改密码\nid          # 显示用户UID GID\nusemod      # 修改用户登录信息 用户组g\nsudo usermod -aG sudo yang      #普通用户添加sudo\n\ndeluser --remove-all-files yang  # 交互\ndeluser  yang  sudo     # 从sudo组删除用户yang\nuserdel\n\nsu yang     #切换用户\ncat /etc/passwd #查看所有用户 与管道结合更方便grep\n</code></pre><h2 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h2><pre><code>addgroup    #系统用户组\ngroupadd\ngroups      #显示用户对应的组\ngroupmod    #更改用户组名称 ID\n\ndelgroup\ngroupdel   \n\ncat /etc/group  #查看所用用户组 \n</code></pre><h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><pre><code>chmod\nchown   #修改文件、目录归属用户或组\nchgrp   #修改文件或目录的归属组   \n</code></pre><h1 id=\"文件预设权限-umask\"><a href=\"#文件预设权限-umask\" class=\"headerlink\" title=\"文件预设权限 umask\"></a>文件预设权限 umask</h1><p>文件: -rw-rw-rw-  666</p>\n<p>目录: drwxrwxrwx  777<br>默认权限-umask权限就是创建文件的默认权限</p>\n<pre><code>   umask\n   umask -S #查看文件预设权限\n   umask 022    #设定umask权限\n</code></pre><h2 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h2><p>chattr 指令只能在Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效<br>其他的文件系统可能就无法完整的支持这个<br>指令了,例如 xfs 仅支持部份参数而已  </p>\n<pre><code>chattr +i filename  #文件不可更改\nchattr +a filename  #只能增加内容 不能删除和修改\nlsattr  filename    #查看文件隐藏属性\n</code></pre><h2 id=\"特殊权限-SUID-SGID-SBIT\"><a href=\"#特殊权限-SUID-SGID-SBIT\" class=\"headerlink\" title=\"特殊权限 SUID, SGID, SBIT\"></a>特殊权限 SUID, SGID, SBIT</h2><p>SUID不是用在目录上,而 SBIT 不是用在文件上</p>\n<ol>\n<li><p>Set UID</p>\n<p> s在user位置</p>\n<p> /usr/bin/passwd 的-rwsr-xr-x 中的s</p>\n<ol>\n<li>SUID 权限仅对二进制程序(binary program)有效;</li>\n<li>执行者对于该程序需要具有 x 的可执行权限;</li>\n<li>本权限仅在执行该程序的过程中有效 (run-time);</li>\n<li><p><strong>执行者将具有该程序拥有者 (owner) 的权限</strong>。如果拥有者都没有执行权限 则执行者这个权限为S 空的意思</p>\n<p>例如普通用户更改密码 调用passwd时就会暂时具有root权限,而使用cat查看密码不属于执行,所以不具有执行权限</p>\n<p>文件具有 SUID 的特殊权限时,代表当用户执行此一 binary 程序时,在执行过程中用户会暂时具有程序拥有<br>者的权限</p>\n</li>\n</ol>\n</li>\n<li><p>Set GID       </p>\n<p> s在group的位置</p>\n<ol>\n<li>SGID 对二进制程序有用;</li>\n<li>程序执行者对于该程序来说,需具备 x 的权限;</li>\n<li><p>执行者在执行的过程中将会获得该程序群组的支持!</p>\n<p>目录具有 SGID 的特殊权限时,代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。    </p>\n</li>\n</ol>\n</li>\n<li><p>Sticky Bit</p>\n<p> 只针对目录有效</p>\n<ol>\n<li>当用户对于此目录具有 w, x 权限,亦即具有写入的权限时;</li>\n<li><p>当用户在该目录下建立文件或目录时,仅有自己与 root 才有权力删除该文件</p>\n<p>例如/tmp 的权限是 drwxrwxrwt</p>\n<p>目录具有 SBIT 的特殊权限时,代表在该目录下用户建立的文件只有自己与 root 能够删除!</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"特殊权限的修改\"><a href=\"#特殊权限的修改\" class=\"headerlink\" title=\"特殊权限的修改\"></a>特殊权限的修改</h3><ul>\n<li>4 为 SUID</li>\n<li>2 为 SGID</li>\n<li><p>1 为 SBIT  </p>\n<pre><code>chmod 4755 filename   # 增加SUID         \n</code></pre></li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用户管理命令\"><a href=\"#用户管理命令\" class=\"headerlink\" title=\"用户管理命令\"></a>用户管理命令</h1><h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><pre><code>adduser     # 交互形式   \nuseradd\n\nfinger -l yang     # 显示用户相关信息\nchfn        # 修改用户个人信息\npasswd      # 更改密码\nid          # 显示用户UID GID\nusemod      # 修改用户登录信息 用户组g\nsudo usermod -aG sudo yang      #普通用户添加sudo\n\ndeluser --remove-all-files yang  # 交互\ndeluser  yang  sudo     # 从sudo组删除用户yang\nuserdel\n\nsu yang     #切换用户\ncat /etc/passwd #查看所有用户 与管道结合更方便grep\n</code></pre><h2 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h2><pre><code>addgroup    #系统用户组\ngroupadd\ngroups      #显示用户对应的组\ngroupmod    #更改用户组名称 ID\n\ndelgroup\ngroupdel   \n\ncat /etc/group  #查看所用用户组 \n</code></pre><h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><pre><code>chmod\nchown   #修改文件、目录归属用户或组\nchgrp   #修改文件或目录的归属组   \n</code></pre><h1 id=\"文件预设权限-umask\"><a href=\"#文件预设权限-umask\" class=\"headerlink\" title=\"文件预设权限 umask\"></a>文件预设权限 umask</h1><p>文件: -rw-rw-rw-  666</p>\n<p>目录: drwxrwxrwx  777<br>默认权限-umask权限就是创建文件的默认权限</p>\n<pre><code>   umask\n   umask -S #查看文件预设权限\n   umask 022    #设定umask权限\n</code></pre><h2 id=\"隐藏属性\"><a href=\"#隐藏属性\" class=\"headerlink\" title=\"隐藏属性\"></a>隐藏属性</h2><p>chattr 指令只能在Ext2/Ext3/Ext4 的 Linux 传统文件系统上面完整生效<br>其他的文件系统可能就无法完整的支持这个<br>指令了,例如 xfs 仅支持部份参数而已  </p>\n<pre><code>chattr +i filename  #文件不可更改\nchattr +a filename  #只能增加内容 不能删除和修改\nlsattr  filename    #查看文件隐藏属性\n</code></pre><h2 id=\"特殊权限-SUID-SGID-SBIT\"><a href=\"#特殊权限-SUID-SGID-SBIT\" class=\"headerlink\" title=\"特殊权限 SUID, SGID, SBIT\"></a>特殊权限 SUID, SGID, SBIT</h2><p>SUID不是用在目录上,而 SBIT 不是用在文件上</p>\n<ol>\n<li><p>Set UID</p>\n<p> s在user位置</p>\n<p> /usr/bin/passwd 的-rwsr-xr-x 中的s</p>\n<ol>\n<li>SUID 权限仅对二进制程序(binary program)有效;</li>\n<li>执行者对于该程序需要具有 x 的可执行权限;</li>\n<li>本权限仅在执行该程序的过程中有效 (run-time);</li>\n<li><p><strong>执行者将具有该程序拥有者 (owner) 的权限</strong>。如果拥有者都没有执行权限 则执行者这个权限为S 空的意思</p>\n<p>例如普通用户更改密码 调用passwd时就会暂时具有root权限,而使用cat查看密码不属于执行,所以不具有执行权限</p>\n<p>文件具有 SUID 的特殊权限时,代表当用户执行此一 binary 程序时,在执行过程中用户会暂时具有程序拥有<br>者的权限</p>\n</li>\n</ol>\n</li>\n<li><p>Set GID       </p>\n<p> s在group的位置</p>\n<ol>\n<li>SGID 对二进制程序有用;</li>\n<li>程序执行者对于该程序来说,需具备 x 的权限;</li>\n<li><p>执行者在执行的过程中将会获得该程序群组的支持!</p>\n<p>目录具有 SGID 的特殊权限时,代表用户在这个目录底下新建的文件之群组都会与该目录的组名相同。    </p>\n</li>\n</ol>\n</li>\n<li><p>Sticky Bit</p>\n<p> 只针对目录有效</p>\n<ol>\n<li>当用户对于此目录具有 w, x 权限,亦即具有写入的权限时;</li>\n<li><p>当用户在该目录下建立文件或目录时,仅有自己与 root 才有权力删除该文件</p>\n<p>例如/tmp 的权限是 drwxrwxrwt</p>\n<p>目录具有 SBIT 的特殊权限时,代表在该目录下用户建立的文件只有自己与 root 能够删除!</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"特殊权限的修改\"><a href=\"#特殊权限的修改\" class=\"headerlink\" title=\"特殊权限的修改\"></a>特殊权限的修改</h3><ul>\n<li>4 为 SUID</li>\n<li>2 为 SGID</li>\n<li><p>1 为 SBIT  </p>\n<pre><code>chmod 4755 filename   # 增加SUID         \n</code></pre></li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1>"},{"title":"电脑小问题记录","date":"2020-11-12T00:43:35.000Z","_content":"\n电脑的问题有时候是硬件问题,需要细心排查\n\n## 电脑无法正常启动\n1. 电脑上电之后马上自己断电,如此反复 \n    把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板\n2. 双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入\n    电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    ","source":"_posts/电脑小问题记录.md","raw":"---\ntitle: 电脑小问题记录\ndate: 2020-11-12 08:43:35\ncategories:\n- Linux\ntags:\n- 软硬件\n---\n\n电脑的问题有时候是硬件问题,需要细心排查\n\n## 电脑无法正常启动\n1. 电脑上电之后马上自己断电,如此反复 \n    把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板\n2. 双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入\n    电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    ","slug":"电脑小问题记录","published":1,"updated":"2020-11-12T00:49:32.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cik004bmxkab9oplzb9","content":"<p>电脑的问题有时候是硬件问题,需要细心排查</p>\n<h2 id=\"电脑无法正常启动\"><a href=\"#电脑无法正常启动\" class=\"headerlink\" title=\"电脑无法正常启动\"></a>电脑无法正常启动</h2><ol>\n<li>电脑上电之后马上自己断电,如此反复<br> 把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板</li>\n<li>双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入<br> 电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>电脑的问题有时候是硬件问题,需要细心排查</p>\n<h2 id=\"电脑无法正常启动\"><a href=\"#电脑无法正常启动\" class=\"headerlink\" title=\"电脑无法正常启动\"></a>电脑无法正常启动</h2><ol>\n<li>电脑上电之后马上自己断电,如此反复<br> 把线头紧一下,内存条拿下来擦一下就可以了,可能是线头送了或者之前打扫的时候灰尘太大影响的主板</li>\n<li>双系统电脑开机之后没有ubuntu grub启动项选项,直接进入ubuntu,进系统前显示屏一直没有信号输入<br> 电脑显示器插头松了.另一种可能是需要把内存条拿下来擦一下    </li>\n</ol>\n"},{"title":"矩生成函数","date":"2019-09-01T07:01:28.000Z","mathjax":true,"_content":"\n# 定义\n参考维基百科 [Moment Generating Functions](https://zh.wikipedia.org/wiki/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B8)\n\n# 性质\n1. \nLetX bearandomvariableswhosem.g.f.ψ(t)isfiniteforallvaluesoft insomeopen\ninterval around the point t = 0. Then, for each integer n > 0, the nth moment of X,\nE(Xn), is finite and equals the nth derivative ψ(n)(t) at t = 0. That is, E(Xn) = ψ(n)(0)\nfor n = 1, 2, . . . .\n$$\n\\begin{aligned} \\psi^{(n)}(0) &=\\left[\\frac{d^{n}}{d t^{n}} E\\left(e^{t X}\\right)\\right]_{t=0}=E\\left[\\left(\\frac{d^{n}}{d t^{n}} e^{t X}\\right)_{t=0}\\right] \\\\ &=E\\left[\\left(X^{n} e^{t X}\\right)_{t=0}\\right]=E\\left(X^{n}\\right) \\end{aligned}\n$$\n或者通过维基百科上的式子求导更容易理解\n$$\n\\begin{aligned} M_{X}(t) &=\\int_{-\\infty}^{\\infty} e^{t x} f(x) \\mathrm{d} x \\\\ &=\\int_{-\\infty}^{\\infty}\\left(1+t x+\\frac{t^{2} x^{2}}{2 !}+\\cdots\\right) f(x) \\mathrm{d} x \\\\ &=1+t m_{1}+\\frac{t^{2} m_{2}}{2 !}+\\cdots \\end{aligned}\n$$\n\n2. \nLet **X** be a random variable for which the m.g.f. is ψ 1 ; let**Y = aX + b**, where a and b\nare given constants; and let ψ 2 denote the m.g.f. of Y. Then for every value of t such\nthat ψ 1 (at) is finite,\n$$\n\\psi_{2}(t)=e^{b t} \\psi_{1}(a t)\n$$\n\n3. \nSuppose that X1 , . . . , Xn are n independent random variables; and for i = 1, . . . , n,\nletψi denote the m.g.f.of X .Let**Y =X1 + . . . +Xn**,and let the m.g.f.of Y be denoted\nby ψ. Then for every value of t such that ψi(t) is finite for i = 1, . . . , n,\n$$\n\\psi(t)=\\prod_{i=1}^{n} \\psi_{i}(t)\n$$\n\n4. \nIf the m.g.f.’s of two random variables X1 and X2 are finite and identical for all values\nof t in an open interval around the point t = 0, then the probability distributions of\nX1 and X2 must be identical.\n两个随机变量t=0领域内矩生成函数一样，那么他们的概率分布也是一样的。\n\n# 高斯分布相关\n高斯分布的矩生成函数可以结合上面定理4证明高斯分布很多其他性质\n\n$$\n\\psi(t)=\\exp \\left(\\mu t+\\frac{1}{2} \\sigma^{2} t^{2}\\right) \\quad \\text { for }-\\infty<t<\\infty\n$$\n\n# 参考\n1. 书籍： [Probability and Statistics 第四版 by Morris H. DeGroot](https://book.douban.com/subject/4130410/)\n \n\n\n\n ","source":"_posts/矩生成函数.md","raw":"---\ntitle: 矩生成函数\ndate: 2019-09-01 15:01:28\ncategories:\n- math\ntags:\n- 概率论\nmathjax: true\n---\n\n# 定义\n参考维基百科 [Moment Generating Functions](https://zh.wikipedia.org/wiki/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B8)\n\n# 性质\n1. \nLetX bearandomvariableswhosem.g.f.ψ(t)isfiniteforallvaluesoft insomeopen\ninterval around the point t = 0. Then, for each integer n > 0, the nth moment of X,\nE(Xn), is finite and equals the nth derivative ψ(n)(t) at t = 0. That is, E(Xn) = ψ(n)(0)\nfor n = 1, 2, . . . .\n$$\n\\begin{aligned} \\psi^{(n)}(0) &=\\left[\\frac{d^{n}}{d t^{n}} E\\left(e^{t X}\\right)\\right]_{t=0}=E\\left[\\left(\\frac{d^{n}}{d t^{n}} e^{t X}\\right)_{t=0}\\right] \\\\ &=E\\left[\\left(X^{n} e^{t X}\\right)_{t=0}\\right]=E\\left(X^{n}\\right) \\end{aligned}\n$$\n或者通过维基百科上的式子求导更容易理解\n$$\n\\begin{aligned} M_{X}(t) &=\\int_{-\\infty}^{\\infty} e^{t x} f(x) \\mathrm{d} x \\\\ &=\\int_{-\\infty}^{\\infty}\\left(1+t x+\\frac{t^{2} x^{2}}{2 !}+\\cdots\\right) f(x) \\mathrm{d} x \\\\ &=1+t m_{1}+\\frac{t^{2} m_{2}}{2 !}+\\cdots \\end{aligned}\n$$\n\n2. \nLet **X** be a random variable for which the m.g.f. is ψ 1 ; let**Y = aX + b**, where a and b\nare given constants; and let ψ 2 denote the m.g.f. of Y. Then for every value of t such\nthat ψ 1 (at) is finite,\n$$\n\\psi_{2}(t)=e^{b t} \\psi_{1}(a t)\n$$\n\n3. \nSuppose that X1 , . . . , Xn are n independent random variables; and for i = 1, . . . , n,\nletψi denote the m.g.f.of X .Let**Y =X1 + . . . +Xn**,and let the m.g.f.of Y be denoted\nby ψ. Then for every value of t such that ψi(t) is finite for i = 1, . . . , n,\n$$\n\\psi(t)=\\prod_{i=1}^{n} \\psi_{i}(t)\n$$\n\n4. \nIf the m.g.f.’s of two random variables X1 and X2 are finite and identical for all values\nof t in an open interval around the point t = 0, then the probability distributions of\nX1 and X2 must be identical.\n两个随机变量t=0领域内矩生成函数一样，那么他们的概率分布也是一样的。\n\n# 高斯分布相关\n高斯分布的矩生成函数可以结合上面定理4证明高斯分布很多其他性质\n\n$$\n\\psi(t)=\\exp \\left(\\mu t+\\frac{1}{2} \\sigma^{2} t^{2}\\right) \\quad \\text { for }-\\infty<t<\\infty\n$$\n\n# 参考\n1. 书籍： [Probability and Statistics 第四版 by Morris H. DeGroot](https://book.douban.com/subject/4130410/)\n \n\n\n\n ","slug":"矩生成函数","published":1,"updated":"2020-09-23T14:42:00.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cim004emxkavd2xf8yc","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>参考维基百科 <a href=\"https://zh.wikipedia.org/wiki/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B8\" target=\"_blank\" rel=\"noopener\">Moment Generating Functions</a></p>\n<h1 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h1><ol>\n<li><p>LetX bearandomvariableswhosem.g.f.ψ(t)isfiniteforallvaluesoft insomeopen<br>interval around the point t = 0. Then, for each integer n &gt; 0, the nth moment of X,<br>E(Xn), is finite and equals the nth derivative ψ(n)(t) at t = 0. That is, E(Xn) = ψ(n)(0)<br>for n = 1, 2, . . . .</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\psi^{(n)}(0) &=\\left[\\frac{d^{n}}{d t^{n}} E\\left(e^{t X}\\right)\\right]_{t=0}=E\\left[\\left(\\frac{d^{n}}{d t^{n}} e^{t X}\\right)_{t=0}\\right] \\\\ &=E\\left[\\left(X^{n} e^{t X}\\right)_{t=0}\\right]=E\\left(X^{n}\\right) \\end{aligned}</script><p>或者通过维基百科上的式子求导更容易理解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} M_{X}(t) &=\\int_{-\\infty}^{\\infty} e^{t x} f(x) \\mathrm{d} x \\\\ &=\\int_{-\\infty}^{\\infty}\\left(1+t x+\\frac{t^{2} x^{2}}{2 !}+\\cdots\\right) f(x) \\mathrm{d} x \\\\ &=1+t m_{1}+\\frac{t^{2} m_{2}}{2 !}+\\cdots \\end{aligned}</script></li>\n<li><p>Let <strong>X</strong> be a random variable for which the m.g.f. is ψ 1 ; let<strong>Y = aX + b</strong>, where a and b<br>are given constants; and let ψ 2 denote the m.g.f. of Y. Then for every value of t such<br>that ψ 1 (at) is finite,</p>\n<script type=\"math/tex; mode=display\">\n\\psi_{2}(t)=e^{b t} \\psi_{1}(a t)</script></li>\n<li><p>Suppose that X1 , . . . , Xn are n independent random variables; and for i = 1, . . . , n,<br>letψi denote the m.g.f.of X .Let<strong>Y =X1 + . . . +Xn</strong>,and let the m.g.f.of Y be denoted<br>by ψ. Then for every value of t such that ψi(t) is finite for i = 1, . . . , n,</p>\n<script type=\"math/tex; mode=display\">\n\\psi(t)=\\prod_{i=1}^{n} \\psi_{i}(t)</script></li>\n<li><p>If the m.g.f.’s of two random variables X1 and X2 are finite and identical for all values<br>of t in an open interval around the point t = 0, then the probability distributions of<br>X1 and X2 must be identical.<br>两个随机变量t=0领域内矩生成函数一样，那么他们的概率分布也是一样的。</p>\n</li>\n</ol>\n<h1 id=\"高斯分布相关\"><a href=\"#高斯分布相关\" class=\"headerlink\" title=\"高斯分布相关\"></a>高斯分布相关</h1><p>高斯分布的矩生成函数可以结合上面定理4证明高斯分布很多其他性质</p>\n<script type=\"math/tex; mode=display\">\n\\psi(t)=\\exp \\left(\\mu t+\\frac{1}{2} \\sigma^{2} t^{2}\\right) \\quad \\text { for }-\\infty<t<\\infty</script><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>书籍： <a href=\"https://book.douban.com/subject/4130410/\" target=\"_blank\" rel=\"noopener\">Probability and Statistics 第四版 by Morris H. DeGroot</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>参考维基百科 <a href=\"https://zh.wikipedia.org/wiki/%E7%9F%A9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B8\" target=\"_blank\" rel=\"noopener\">Moment Generating Functions</a></p>\n<h1 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h1><ol>\n<li><p>LetX bearandomvariableswhosem.g.f.ψ(t)isfiniteforallvaluesoft insomeopen<br>interval around the point t = 0. Then, for each integer n &gt; 0, the nth moment of X,<br>E(Xn), is finite and equals the nth derivative ψ(n)(t) at t = 0. That is, E(Xn) = ψ(n)(0)<br>for n = 1, 2, . . . .</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\psi^{(n)}(0) &=\\left[\\frac{d^{n}}{d t^{n}} E\\left(e^{t X}\\right)\\right]_{t=0}=E\\left[\\left(\\frac{d^{n}}{d t^{n}} e^{t X}\\right)_{t=0}\\right] \\\\ &=E\\left[\\left(X^{n} e^{t X}\\right)_{t=0}\\right]=E\\left(X^{n}\\right) \\end{aligned}</script><p>或者通过维基百科上的式子求导更容易理解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} M_{X}(t) &=\\int_{-\\infty}^{\\infty} e^{t x} f(x) \\mathrm{d} x \\\\ &=\\int_{-\\infty}^{\\infty}\\left(1+t x+\\frac{t^{2} x^{2}}{2 !}+\\cdots\\right) f(x) \\mathrm{d} x \\\\ &=1+t m_{1}+\\frac{t^{2} m_{2}}{2 !}+\\cdots \\end{aligned}</script></li>\n<li><p>Let <strong>X</strong> be a random variable for which the m.g.f. is ψ 1 ; let<strong>Y = aX + b</strong>, where a and b<br>are given constants; and let ψ 2 denote the m.g.f. of Y. Then for every value of t such<br>that ψ 1 (at) is finite,</p>\n<script type=\"math/tex; mode=display\">\n\\psi_{2}(t)=e^{b t} \\psi_{1}(a t)</script></li>\n<li><p>Suppose that X1 , . . . , Xn are n independent random variables; and for i = 1, . . . , n,<br>letψi denote the m.g.f.of X .Let<strong>Y =X1 + . . . +Xn</strong>,and let the m.g.f.of Y be denoted<br>by ψ. Then for every value of t such that ψi(t) is finite for i = 1, . . . , n,</p>\n<script type=\"math/tex; mode=display\">\n\\psi(t)=\\prod_{i=1}^{n} \\psi_{i}(t)</script></li>\n<li><p>If the m.g.f.’s of two random variables X1 and X2 are finite and identical for all values<br>of t in an open interval around the point t = 0, then the probability distributions of<br>X1 and X2 must be identical.<br>两个随机变量t=0领域内矩生成函数一样，那么他们的概率分布也是一样的。</p>\n</li>\n</ol>\n<h1 id=\"高斯分布相关\"><a href=\"#高斯分布相关\" class=\"headerlink\" title=\"高斯分布相关\"></a>高斯分布相关</h1><p>高斯分布的矩生成函数可以结合上面定理4证明高斯分布很多其他性质</p>\n<script type=\"math/tex; mode=display\">\n\\psi(t)=\\exp \\left(\\mu t+\\frac{1}{2} \\sigma^{2} t^{2}\\right) \\quad \\text { for }-\\infty<t<\\infty</script><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>书籍： <a href=\"https://book.douban.com/subject/4130410/\" target=\"_blank\" rel=\"noopener\">Probability and Statistics 第四版 by Morris H. DeGroot</a></li>\n</ol>\n"},{"title":"科式加速度","date":"2020-01-13T02:28:27.000Z","mathjax":true,"_content":"\n# 科里奥利力\n科里奥利力（英语：Coriolis Force；简称科氏力）是一种惯性力,\n是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述.\n\n绝对加速度计算公式=相对加速度+牵连加速度+科式加速度\n\n- 相对加速度:动点相对于动坐标系的加速度\n- 牵连加速度:动坐标系上与动点重合的点在全局坐标系下的加速度\n- 科式加速度:动点相对于动坐标系运动产生的加速度\n\n$$\n\\begin{aligned}\n\\mathbf{a}_{n} &=\\mathbf{a}_{r}+\\mathbf{a}_{e}+\\mathbf{a}_{c} \\\\\n&=\\mathbf{a}_{r}+\\boldsymbol{a} \\times \\mathbf{r}^{\\prime}+\\mathbf{\\omega} \\times\\left(\\mathbf{\\omega} \\times \\mathbf{r}^{\\prime}\\right)+2 \\mathbf{\\omega} \\times \\mathbf{v}_{r}\n\\end{aligned}\n$$\n\n## 例子\n如图,动点沿着直杆运动,直杆本身旋转运动\n\n$$\n\\begin{array}{ll}\n{a_{e}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{M 1}-v_{e}}{\\Delta t},} & {\\frac{d v_{e}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{e}^{\\prime}-v_{e}}{\\Delta t}} \\\\\n{a_{r}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r 2}-v_{r}}{\\Delta t},} & {\\frac{d v_{r}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r}^{\\prime}-v_{r}}{\\Delta t}}\n\\end{array}\n$$\n\n科式加速度产生\n\n$$\n\\frac{d v_{r}}{d t}=a_{r}+\\omega_{e} \\times v_{r}, \\quad \\frac{d v_{e}}{d t}=a_{e}+\\omega_{e} \\times v_{r}\n$$\n\n\n![科式加速度](科式加速度.png)\n\n## 坐标轴微分计算\n\n$$\n\\frac{d i^{\\prime}}{d t}=\\omega \\times i^{\\prime}, \\quad \\frac{d j^{\\prime}}{d t}=\\omega \\times j^{\\prime}, \\quad \\frac{d k^{\\prime}}{d t}=\\omega \\times k^{\\prime}\n$$\n\n直接物理含义推导,把向量平移到起点和旋转轴重合,相当于就是位置的微分,为速度\n\n# 引用\n1. [科里奥利力](https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E5%8A%9B)\n2. 理论力学第8版 哈尔滨工业大学理论力学教研室编","source":"_posts/科式加速度.md","raw":"---\ntitle: 科式加速度\ndate: 2020-01-13 10:28:27\ncategories:\n- math\ntags:\n- 加速度\nmathjax: true\n---\n\n# 科里奥利力\n科里奥利力（英语：Coriolis Force；简称科氏力）是一种惯性力,\n是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述.\n\n绝对加速度计算公式=相对加速度+牵连加速度+科式加速度\n\n- 相对加速度:动点相对于动坐标系的加速度\n- 牵连加速度:动坐标系上与动点重合的点在全局坐标系下的加速度\n- 科式加速度:动点相对于动坐标系运动产生的加速度\n\n$$\n\\begin{aligned}\n\\mathbf{a}_{n} &=\\mathbf{a}_{r}+\\mathbf{a}_{e}+\\mathbf{a}_{c} \\\\\n&=\\mathbf{a}_{r}+\\boldsymbol{a} \\times \\mathbf{r}^{\\prime}+\\mathbf{\\omega} \\times\\left(\\mathbf{\\omega} \\times \\mathbf{r}^{\\prime}\\right)+2 \\mathbf{\\omega} \\times \\mathbf{v}_{r}\n\\end{aligned}\n$$\n\n## 例子\n如图,动点沿着直杆运动,直杆本身旋转运动\n\n$$\n\\begin{array}{ll}\n{a_{e}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{M 1}-v_{e}}{\\Delta t},} & {\\frac{d v_{e}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{e}^{\\prime}-v_{e}}{\\Delta t}} \\\\\n{a_{r}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r 2}-v_{r}}{\\Delta t},} & {\\frac{d v_{r}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r}^{\\prime}-v_{r}}{\\Delta t}}\n\\end{array}\n$$\n\n科式加速度产生\n\n$$\n\\frac{d v_{r}}{d t}=a_{r}+\\omega_{e} \\times v_{r}, \\quad \\frac{d v_{e}}{d t}=a_{e}+\\omega_{e} \\times v_{r}\n$$\n\n\n![科式加速度](科式加速度.png)\n\n## 坐标轴微分计算\n\n$$\n\\frac{d i^{\\prime}}{d t}=\\omega \\times i^{\\prime}, \\quad \\frac{d j^{\\prime}}{d t}=\\omega \\times j^{\\prime}, \\quad \\frac{d k^{\\prime}}{d t}=\\omega \\times k^{\\prime}\n$$\n\n直接物理含义推导,把向量平移到起点和旋转轴重合,相当于就是位置的微分,为速度\n\n# 引用\n1. [科里奥利力](https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E5%8A%9B)\n2. 理论力学第8版 哈尔滨工业大学理论力学教研室编","slug":"科式加速度","published":1,"updated":"2020-09-23T14:42:00.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cin004hmxkaokeeztjd","content":"<h1 id=\"科里奥利力\"><a href=\"#科里奥利力\" class=\"headerlink\" title=\"科里奥利力\"></a>科里奥利力</h1><p>科里奥利力（英语：Coriolis Force；简称科氏力）是一种惯性力,<br>是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述.</p>\n<p>绝对加速度计算公式=相对加速度+牵连加速度+科式加速度</p>\n<ul>\n<li>相对加速度:动点相对于动坐标系的加速度</li>\n<li>牵连加速度:动坐标系上与动点重合的点在全局坐标系下的加速度</li>\n<li>科式加速度:动点相对于动坐标系运动产生的加速度</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\mathbf{a}_{n} &=\\mathbf{a}_{r}+\\mathbf{a}_{e}+\\mathbf{a}_{c} \\\\\n&=\\mathbf{a}_{r}+\\boldsymbol{a} \\times \\mathbf{r}^{\\prime}+\\mathbf{\\omega} \\times\\left(\\mathbf{\\omega} \\times \\mathbf{r}^{\\prime}\\right)+2 \\mathbf{\\omega} \\times \\mathbf{v}_{r}\n\\end{aligned}</script><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>如图,动点沿着直杆运动,直杆本身旋转运动</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{ll}\n{a_{e}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{M 1}-v_{e}}{\\Delta t},} & {\\frac{d v_{e}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{e}^{\\prime}-v_{e}}{\\Delta t}} \\\\\n{a_{r}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r 2}-v_{r}}{\\Delta t},} & {\\frac{d v_{r}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r}^{\\prime}-v_{r}}{\\Delta t}}\n\\end{array}</script><p>科式加速度产生</p>\n<script type=\"math/tex; mode=display\">\n\\frac{d v_{r}}{d t}=a_{r}+\\omega_{e} \\times v_{r}, \\quad \\frac{d v_{e}}{d t}=a_{e}+\\omega_{e} \\times v_{r}</script><p><img src=\"/2020/01/13/科式加速度/科式加速度.png\" alt=\"科式加速度\"></p>\n<h2 id=\"坐标轴微分计算\"><a href=\"#坐标轴微分计算\" class=\"headerlink\" title=\"坐标轴微分计算\"></a>坐标轴微分计算</h2><script type=\"math/tex; mode=display\">\n\\frac{d i^{\\prime}}{d t}=\\omega \\times i^{\\prime}, \\quad \\frac{d j^{\\prime}}{d t}=\\omega \\times j^{\\prime}, \\quad \\frac{d k^{\\prime}}{d t}=\\omega \\times k^{\\prime}</script><p>直接物理含义推导,把向量平移到起点和旋转轴重合,相当于就是位置的微分,为速度</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E5%8A%9B\" target=\"_blank\" rel=\"noopener\">科里奥利力</a></li>\n<li>理论力学第8版 哈尔滨工业大学理论力学教研室编</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"科里奥利力\"><a href=\"#科里奥利力\" class=\"headerlink\" title=\"科里奥利力\"></a>科里奥利力</h1><p>科里奥利力（英语：Coriolis Force；简称科氏力）是一种惯性力,<br>是对旋转体系中进行直线运动的质点由于惯性相对于旋转体系产生的直线运动的偏移的一种描述.</p>\n<p>绝对加速度计算公式=相对加速度+牵连加速度+科式加速度</p>\n<ul>\n<li>相对加速度:动点相对于动坐标系的加速度</li>\n<li>牵连加速度:动坐标系上与动点重合的点在全局坐标系下的加速度</li>\n<li>科式加速度:动点相对于动坐标系运动产生的加速度</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\mathbf{a}_{n} &=\\mathbf{a}_{r}+\\mathbf{a}_{e}+\\mathbf{a}_{c} \\\\\n&=\\mathbf{a}_{r}+\\boldsymbol{a} \\times \\mathbf{r}^{\\prime}+\\mathbf{\\omega} \\times\\left(\\mathbf{\\omega} \\times \\mathbf{r}^{\\prime}\\right)+2 \\mathbf{\\omega} \\times \\mathbf{v}_{r}\n\\end{aligned}</script><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>如图,动点沿着直杆运动,直杆本身旋转运动</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{ll}\n{a_{e}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{M 1}-v_{e}}{\\Delta t},} & {\\frac{d v_{e}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{e}^{\\prime}-v_{e}}{\\Delta t}} \\\\\n{a_{r}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r 2}-v_{r}}{\\Delta t},} & {\\frac{d v_{r}}{d t}=\\lim _{\\Delta t \\rightarrow 0} \\frac{v_{r}^{\\prime}-v_{r}}{\\Delta t}}\n\\end{array}</script><p>科式加速度产生</p>\n<script type=\"math/tex; mode=display\">\n\\frac{d v_{r}}{d t}=a_{r}+\\omega_{e} \\times v_{r}, \\quad \\frac{d v_{e}}{d t}=a_{e}+\\omega_{e} \\times v_{r}</script><p><img src=\"/2020/01/13/科式加速度/科式加速度.png\" alt=\"科式加速度\"></p>\n<h2 id=\"坐标轴微分计算\"><a href=\"#坐标轴微分计算\" class=\"headerlink\" title=\"坐标轴微分计算\"></a>坐标轴微分计算</h2><script type=\"math/tex; mode=display\">\n\\frac{d i^{\\prime}}{d t}=\\omega \\times i^{\\prime}, \\quad \\frac{d j^{\\prime}}{d t}=\\omega \\times j^{\\prime}, \\quad \\frac{d k^{\\prime}}{d t}=\\omega \\times k^{\\prime}</script><p>直接物理含义推导,把向量平移到起点和旋转轴重合,相当于就是位置的微分,为速度</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%A7%91%E9%87%8C%E5%A5%A5%E5%88%A9%E5%8A%9B\" target=\"_blank\" rel=\"noopener\">科里奥利力</a></li>\n<li>理论力学第8版 哈尔滨工业大学理论力学教研室编</li>\n</ol>\n"},{"title":"解决conda和ros库不兼容问题,libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用","date":"2020-11-10T03:05:40.000Z","_content":"\n## 主要是因为conda和ros兼容的问题\n1. 问题关键词： **libapr-1.so.0**和**uuid**\n2. locate第一个关键词: \n        \n        $ locate libapr-1.so.0 \n        /usr/lib/x86_64-linux-gnu/libapr-1.so.0\n        /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2\n3. 查看该库对第二个关键字的依赖包位置\n        \n        $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid\n        libuuid.so.1 => /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)\n    这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同\n4. locate第二个关键词\n        \n       $ locate libuuid.so.1  \n       /home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n       /home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0\n       /home/yang/anaconda3/lib/libuuid.so.1\n       /home/yang/anaconda3/lib/libuuid.so.1.0.0\n       /home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1\n       /home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0\n       /lib/i386-linux-gnu/libuuid.so.1\n       /lib/i386-linux-gnu/libuuid.so.1.3.0\n       /lib/x86_64-linux-gnu/libuuid.so.1\n       /lib/x86_64-linux-gnu/libuuid.so.1.3.0\n       /snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1\n       /snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n       /snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1\n       /snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n   可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n   对比两个版本\n   \n       $ ll /lib/x86_64-linux-gnu/ |grep uuid   \n       lrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -> libuuid.so.1.3.0\n       -rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0\n        \n       $ ll ~/anaconda3/envs/franka/lib |grep uuid\n       -rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a\n       -rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*\n       lrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -> libuuid.so.1.0.0*\n       lrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -> libuuid.so.1.0.0*\n       -rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*\n       \n       可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本\n5. 把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)\n        \n        mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back       \n        sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1\n\n## 引用\n1. [解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用](https://blog.csdn.net/qq_36013249/article/details/103311001)","source":"_posts/解决libapr-1-so-0：对‘uuid-generate-UUID-1-0’未定义的引用.md","raw":"---\ntitle: 解决conda和ros库不兼容问题,libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用\ndate: 2020-11-10 11:05:40\ncategories:\n- Linux\ntags:\n- anaconda\n---\n\n## 主要是因为conda和ros兼容的问题\n1. 问题关键词： **libapr-1.so.0**和**uuid**\n2. locate第一个关键词: \n        \n        $ locate libapr-1.so.0 \n        /usr/lib/x86_64-linux-gnu/libapr-1.so.0\n        /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2\n3. 查看该库对第二个关键字的依赖包位置\n        \n        $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid\n        libuuid.so.1 => /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)\n    这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同\n4. locate第二个关键词\n        \n       $ locate libuuid.so.1  \n       /home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n       /home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0\n       /home/yang/anaconda3/lib/libuuid.so.1\n       /home/yang/anaconda3/lib/libuuid.so.1.0.0\n       /home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1\n       /home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0\n       /lib/i386-linux-gnu/libuuid.so.1\n       /lib/i386-linux-gnu/libuuid.so.1.3.0\n       /lib/x86_64-linux-gnu/libuuid.so.1\n       /lib/x86_64-linux-gnu/libuuid.so.1.3.0\n       /snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1\n       /snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n       /snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1\n       /snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n   可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n   对比两个版本\n   \n       $ ll /lib/x86_64-linux-gnu/ |grep uuid   \n       lrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -> libuuid.so.1.3.0\n       -rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0\n        \n       $ ll ~/anaconda3/envs/franka/lib |grep uuid\n       -rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a\n       -rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*\n       lrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -> libuuid.so.1.0.0*\n       lrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -> libuuid.so.1.0.0*\n       -rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*\n       \n       可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本\n5. 把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)\n        \n        mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back       \n        sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1\n\n## 引用\n1. [解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用](https://blog.csdn.net/qq_36013249/article/details/103311001)","slug":"解决libapr-1-so-0：对‘uuid-generate-UUID-1-0’未定义的引用","published":1,"updated":"2020-11-10T03:35:05.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cip004kmxka3d1sdzak","content":"<h2 id=\"主要是因为conda和ros兼容的问题\"><a href=\"#主要是因为conda和ros兼容的问题\" class=\"headerlink\" title=\"主要是因为conda和ros兼容的问题\"></a>主要是因为conda和ros兼容的问题</h2><ol>\n<li>问题关键词： <strong>libapr-1.so.0</strong>和<strong>uuid</strong></li>\n<li><p>locate第一个关键词: </p>\n<pre><code> $ locate libapr-1.so.0 \n /usr/lib/x86_64-linux-gnu/libapr-1.so.0\n /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2\n</code></pre></li>\n<li><p>查看该库对第二个关键字的依赖包位置</p>\n<pre><code> $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid\n libuuid.so.1 =&gt; /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)\n</code></pre><p> 这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同</p>\n</li>\n<li><p>locate第二个关键词</p>\n<pre><code>$ locate libuuid.so.1  \n/home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n/home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0\n/home/yang/anaconda3/lib/libuuid.so.1\n/home/yang/anaconda3/lib/libuuid.so.1.0.0\n/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1\n/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0\n/lib/i386-linux-gnu/libuuid.so.1\n/lib/i386-linux-gnu/libuuid.so.1.3.0\n/lib/x86_64-linux-gnu/libuuid.so.1\n/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1\n/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1\n/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n</code></pre><p>可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1<br>对比两个版本</p>\n<pre><code>$ ll /lib/x86_64-linux-gnu/ |grep uuid   \nlrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -&gt; libuuid.so.1.3.0\n-rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0\n\n$ ll ~/anaconda3/envs/franka/lib |grep uuid\n-rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a\n-rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*\nlrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -&gt; libuuid.so.1.0.0*\nlrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -&gt; libuuid.so.1.0.0*\n-rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*\n\n可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本\n</code></pre></li>\n<li><p>把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)</p>\n<pre><code> mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back       \n sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1\n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/qq_36013249/article/details/103311001\" target=\"_blank\" rel=\"noopener\">解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"主要是因为conda和ros兼容的问题\"><a href=\"#主要是因为conda和ros兼容的问题\" class=\"headerlink\" title=\"主要是因为conda和ros兼容的问题\"></a>主要是因为conda和ros兼容的问题</h2><ol>\n<li>问题关键词： <strong>libapr-1.so.0</strong>和<strong>uuid</strong></li>\n<li><p>locate第一个关键词: </p>\n<pre><code> $ locate libapr-1.so.0 \n /usr/lib/x86_64-linux-gnu/libapr-1.so.0\n /usr/lib/x86_64-linux-gnu/libapr-1.so.0.5.2\n</code></pre></li>\n<li><p>查看该库对第二个关键字的依赖包位置</p>\n<pre><code> $ ldd /usr/lib/x86_64-linux-gnu/libapr-1.so.0 |grep uuid\n libuuid.so.1 =&gt; /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007f3588aab000)\n</code></pre><p> 这是ros系统所使用的库依赖，报错是因为anaconda中也有libuuid.so.1,但是版本不同</p>\n</li>\n<li><p>locate第二个关键词</p>\n<pre><code>$ locate libuuid.so.1  \n/home/yang/anaconda3/envs/franka/lib/libuuid.so.1\n/home/yang/anaconda3/envs/franka/lib/libuuid.so.1.0.0\n/home/yang/anaconda3/lib/libuuid.so.1\n/home/yang/anaconda3/lib/libuuid.so.1.0.0\n/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1\n/home/yang/anaconda3/pkgs/libuuid-1.0.3-h1bed415_2/lib/libuuid.so.1.0.0\n/lib/i386-linux-gnu/libuuid.so.1\n/lib/i386-linux-gnu/libuuid.so.1.3.0\n/lib/x86_64-linux-gnu/libuuid.so.1\n/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1\n/snap/core/10126/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1\n/snap/core/10185/lib/x86_64-linux-gnu/libuuid.so.1.3.0\n</code></pre><p>可以看出,ros使用的是/lib/x86_64-linux-gnu/libuuid.so.1,由于anaconda的存在,我使用的库是/home/yang/anaconda3/envs/franka/lib/libuuid.so.1<br>对比两个版本</p>\n<pre><code>$ ll /lib/x86_64-linux-gnu/ |grep uuid   \nlrwxrwxrwx  1 root root      16 Jan 27  2020 libuuid.so.1 -&gt; libuuid.so.1.3.0\n-rw-r--r--  1 root root   18976 Jan 27  2020 libuuid.so.1.3.0\n\n$ ll ~/anaconda3/envs/franka/lib |grep uuid\n-rw-rw-r--  3 yang yang    26398 Jan 12  2018 libuuid.a\n-rwxrwxr-x  1 yang yang      978 Nov  9 16:05 libuuid.la*\nlrwxrwxrwx  1 yang yang       16 Nov  9 16:05 libuuid.so -&gt; libuuid.so.1.0.0*\nlrwxrwxrwx  1 root root       34 Nov 10 09:35 libuuid.so.1 -&gt; libuuid.so.1.0.0*\n-rwxrwxr-x  3 yang yang    18472 Jan 12  2018 libuuid.so.1.0.0*\n\n可以看出系统库是1.3.0版本,anaconda使用的是1.0.0版本\n</code></pre></li>\n<li><p>把anaconda库链接到系统的库(比较简单,可以先把anaconda对应库备份一下,也可以考虑升级anaconda对应库,但是我没找到)</p>\n<pre><code> mv ~/anaconda3/envs/franka/lib/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1.back       \n sudo ln -s /lib/x86_64-linux-gnu/libuuid.so.1 ~/anaconda3/envs/franka/lib/libuuid.so.1\n</code></pre></li>\n</ol>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><ol>\n<li><a href=\"https://blog.csdn.net/qq_36013249/article/details/103311001\" target=\"_blank\" rel=\"noopener\">解决libapr-1.so.0：对‘uuid_generate@UUID_1.0’未定义的引用</a></li>\n</ol>\n"},{"title":"ROS中CMakeLists.txt","date":"2019-10-05T11:25:10.000Z","_content":"# 概述\nCMake构建系统通过ROS包中的CMakeList.txt来构建软件包。\n在catkin 项目中，CMakeList.txt 符合标准的vanilla CMakeList.txt 格式，但稍微有点不同。\n\n# 整体结构\n\n1. 所需CMake版本(cmake_minimum_required)\n2. 软件包名称(project())\n3. 查找构建所需的其他CMake / Catkin软件包(find_package())\n4. 启用Python模块支持(catkin_python_setup())\n5. 消息/服务/动作生成器(add_message_files()，add_service_files()，add_action_files())\n6. 生成消息/服务/动作等自定义消息(generate_messages())\n7. 指定包的构建信息输出(catkin_package())\n8. 要建立的库/可执行文件(add_library()/ add_executable()/ target_link_libraries())\n9. 测试(catkin_add_gtest())\n10. 安装规则(install())\n\n# 软件版本\n    cmake_minimum_required(VERSION 2.8.3)\n    \n# 软件包名称\n可通过变量${PROJECT_NAME}来引用项目名称\n    \n    project(robot_brain)    \n# 查找相关CMake包\n指明构建package需要的包，使用catkin_make，所以catkin是必备依赖,在此基础上可能需要其他的包\n\n    find_package(catkin REQUIRED)   \n    \n    find_package(catkin REQUIRED COMPONENTS nodelet)  #第一种方式 合并写\n     \n    find_package(catkin REQUIRED)   # 第二种方式 分开写\n    find_package(nodelet REQUIRED)\n## find-package作用\n     \n 如果CMake通过find_package找到一个包，则会自动生成有关包所在路径的CMake环境变量，\n 环境变量描述了包中头文件的位置，源文件的位置，包所依赖的库文件位置。\n 这些变量名称以< PACKAGE NAME >_< PROPERTY >的形式出现：\n \n - < NAME >_FOUND - 如果找到库，则设置为true，否则为false\n - < NAME > _INCLUDE_DIRS或 _INCLUDES - 这个包输出的头文件目录\n - < NAME > _LIBRARIES或 _LIBS - 由包导出的库\n - < NAME > _DEFINITIONS - ?\n - …\n### cmake 中的find_package\n- 模块模式.属于精简格式,搜索所有名为Find<package>.cmake的文件，这些文件的路径由变量由安装CMake时指定的CMAKE_MODULE_PATH变量指定。如果查找到了该文件，它会被CMake读取并被处理。\n- 配置模式.没有找到任何模块就会进入配置模式.试图查找一个由待查找的包提供的配置文件的位置。查找<package>Config.cmake或者<package全小写>-config.cmake\n搜索路径包括,比如ros内部定义了CMAKE_PREFIX_PATH=/opt/ros/kinetic/share\n\n       <package>_DIR\n       CMAKE_PREFIX_PATH\n       CMAKE_FRAMEWORK_PATH\n       CMAKE_APPBUNDLE_PATH\n\n编译第三方库如软件时需要知道头文件路径(gcc的-I参数),库文件路径(gcc的-L参数),库文件名字(gcc的-l参数)\n\n比如在CMakeList.txt中\n\n    include_directiories(/usr/include/curl)\n    target_link_libraries(myprogram path/curl.so)\n借助cmake提供的finder,使用cmake的Modules目录下的FindCURL.cmake，相应的CMakeList.txt 文件：\n    \n    find_package(CURL REQUIRED)\n    include_directories(${CURL_INCLUDE_DIR})\n    target_link_libraries(curltest ${CURL_LIBRARY})\n#### find_package原理\nfind_package会在模块路径中查找Find.cmake,路径:变量${CMAKE_MODULE_PATH}中的所有目录。\n如果没有，然后再查看它自己的模块目录/usr/share/cmake-3.5/Modules/(具体值通过在CMakeLists.txt中写message(${CMAKE_ROOT})输出).这称为模块模式.\n\n查看包\n    \n        cmake --help-module-list # 双击Tab会有提示   \n        cmake --help-module Find FindBZip2     #查看Bzip2的帮助\n        \n        # 输出如下,可知道对应头文件和源文件变量名\n        FindBZip2\n        ---------\n        \n        Try to find BZip2\n        \n        Once done this will define\n        \n        ::\n        \n         BZIP2_FOUND - system has BZip2\n         BZIP2_INCLUDE_DIR - the BZip2 include directory\n         BZIP2_LIBRARIES - Link these to use BZip2\n         BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_\n         BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)\n\n             \n     \n## 为什么Catkin包是组件形式\nCatkin的包并不是catkin的真正组成部分。而catkin采用CMake的组件功能，主要是为了节省打字时间。\n\n    #这种方式 会把组件中的包对应的include路径、库导出到catkin前缀的变量中，\n    #例如catkin_INCLUDE_DIRS包含多个包的路径\n    find_package（catkin REQUIRED COMPONENTS nodelet）\n\n    find_package(nodelet REQUIRED)  # 而这种方式 路径和库不会导入catkin变量，而是nodelet_INCLUDE_DIRS之类的\n##　Boost库\n如果使用C ++和Boost，则需要用find_package()来找Boost库，并指定Boost中的组件。如果想使用Boost线程，就可以写成：\n    \n    find_package（Boost REQUIRED COMPONENTS thread）\n#　catkin_package()\n将catkin特定的信息输出到构建系统上，用于生成pkg配置文件以及CMake文件        \n- INCLUDE_DIRS - 导出包的include路径\n- LIBRARIES - 导出项目中的库\n- CATKIN_DEPENDS - 该项目依赖的其他catkin项目\n- DEPENDS - 该项目所依赖的非catkin CMake项目。\n- CFG_EXTRAS - 其他配置选项\n\n        catkin_package(\n           INCLUDE_DIRS include\n           LIBRARIES ${PROJECT_NAME}　　　\n           CATKIN_DEPENDS roscpp nodelet\n           DEPENDS eigen opencv)\n这表示包文件夹中的文件夹“include”是导出头文件的地方。  \n${PROJECT_NAME}根据project中的内容生成，此处是robot_brain\n“roscpp”+“nodelet”是用来构建/运行此程序包的catkin包，\n而“eigen”+“opencv”是用于构建/运行此程序包的非catkin包。   \n# 指定构建目标\n## 包含路径和库\n1. include_directories()\n\n参数应该是调用find_package调用时生成的* _INCLUDE_DIRS变量。\n如果使用catkin和Boost，那么include_directories()调用应该如下所示：\n        \n    include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})\n第一个参数“include”表示包中的include /目录也是路径的一部分。\n2. link_directories()\n\n用于添加额外的库路径，但通常不推荐这样做，因为 所有catkin和CMake软件包在find_packaged时都会自动添加链接信息。 \n只需写target_link_libraries()中就可以了。但真要写，就按照下面那样来写：\n\n    link_directories(~/my_libs)\n## 可执行目标\n生成可执行程序对应的源文件\n\n    add_executable(myProgram src/main.cpp src/some_file.cpp)\n## 库目标\n默认的catkin编译产生的共享库\n\n    add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})　　#指定要构建的库\n## target_link_libraries\n指定可执行目标链接的库。 通常在add_executable()调用之后完成。 \n如果找不到ros，则添加$ {catkin_LIBRARIES}。\n\n    target_link_libraries(<executableTargetName>, <lib1>, <lib2>, ... <libN>)\n大多数情况中不需要使用link_directories()，因为find_package()自动拉入。   \n# 消息、服务和响应\n## 使用条件\n    \n    # CMakeLists.txt\n    find_package(catkin REQUIRED COMPONENTS message_generation ...)\n    add_message_files(...)\n    add_service_files(...)\n    add_action_files(...)\n    generate_messages(...)\n    catkin_package(\n     ...\n     CATKIN_DEPENDS message_runtime ...\n     ...)\n    \n    # package.xml文件中加上 \n    <build_depend>message_generation</build_depend>\n    <run_depend>message_runtime</run_depend>\n1. 如果构建的对象依赖于其他包提供的消息/服务/动作的头文件,\n则需要向目标catkin_EXPORTED_TARGETS添加明确的依赖关系,以便它们以正确的顺序构建。     \n    \n        add_dependencies(some_target ${catkin_EXPORTED_TARGETS})  # 通常是find_package中找到的包导出的对象\n2. 如果构建的对象依赖自己包定义的消息或服务\n\n        add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})\n    具体的变量包含的内容可以通过`message ${${PROJECT_NAME}_EXPORTED_TARGETS}`查看             \n\n## 例子\n现在有两个依赖于std_msgs和sensor_msgs的消息MyMessage1.msg和MyMessage2.msg，\n还有一个自定义服务MyService.srv， message_program是使用这些消息和服务的指令，\n以及生成不使用自定义消息、服务的程序 do_not_use_local_messages_program 不使用，\n那么CMakeLists.txt应该写成：\n\n    # 构建时依赖项\n    find_package(catkin REQUIRED COMPONENTS          \n                 message_generation \n                 std_msgs \n    \n    # 声明要构建哪些消息\n    add_message_files(FILES\n                      MyMessage1.msg\n                      MyMessage2.msg)\n    \n    # 声明构建哪些服务\n    add_service_files(FILES\n                      MyService.srv)\n    \n    # 声明生成上述消息、服务需要依赖的消息以及服务\n    generate_messages(DEPENDENCIES \n                        std_msgs \n                        sensor_msgs)\n    \n    # 声明运行时依赖项\n    catkin_package(CATKIN_DEPENDS \n                    message_runtime \n                    std_msgs sensor_msgs)\n    \n    # 声明构建生成的可执行文件名称以及依赖项\n    add_executable(message_program src/main.cpp)\n    add_dependencies(message_program ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})\n    \n    # 声明构建不需要使用自定义消息、服务的可执行文件\n    add_executable(does_not_use_local_messages_program src/main.cpp)\n    add_dependencies(does_not_use_local_messages_program ${catkin_EXPORTED_TARGETS})\n# 问题\n1. 之前用矩阵运算c++库:Armadillo 直接作为catkin组件时找不到库\n\n解决方案：find_package() 把Armadillo单独拿出来 后面需要的地方链接到库 \n    \n    find_package(Armadillo 5.4 REQUIRED)\n    target_link_libraries(tp_gmr_node ${catkin_LIBRARIES} ${ARMADILLO_LIBRARIES})\n\n# CMake\n下面主要讲CMake对应CMakelists.txt中对应内容,和ROS无光\n\n## 安装与测试\n安装MathFuncitons到${CMAKE_INSTALL_PREFIX}/bin,安装MathFunctions.h到${CMAKE_INSTALL_PREFIX}/include.其实就是拷贝文件\n${CMAKE_INSTALL_PREFIX}在ubuntu系统上默认是/usr/local\n\n    install (TARGETS MathFunctions DESTINATION bin)\n    install (FILES MathFunctions.h DESTINATION include)\n\n下面部分ROS和cmake规则是一样的,只是安装到的位置不一样,比如cmake指定相对于${CMAKE_INSTALL_PREFIX}下的bin,只需要替换变量即可\n1. 安装工程中的目标(targets,即库和可执行文件).对于动态库不是DLL的平台对应的含义如下代码.DLL平台(给予Windows的系统),动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标.\n\n        install(TARGETS your_library your_other_library\n                ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 静态库\n                LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 动态库\n                RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})   # 可执行文件\n2. 安装库使用的头文件(函数调用接口)\n    \n        install(DIRECTORY include/${PROJECT_NAME}/\n                DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})\n3. 如果文件夹内有不需要安装的如这里是svn仓库,可以排除.svn\n    \n        install(DIRECTORY include/${PROJECT_NAME}/\n                DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}\n                PATTERN \".svn\" EXCLUDE)\n                \n终端运行`make install` 安装文件,如果没有权限则需要切换为管理员\n    \n测试可以在CMakeLists.txt中编写\n    \n    include(CTest)\n    \n    # does the application run \n    # 第一个参数是测试的提示 第二个参数的可执行程序 第三个参数是程序带的参数 \n    add_test (TutorialRuns Tutorial 25)\n    \n    # does it sqrt of 25\n    add_test (TutorialComp25 Tutorial 25)\n    set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION \"25 is 5\")\n    \n    # does it handle negative numbers\n    add_test (TutorialNegative Tutorial -25)\n    set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION \"-25 is 0\")\n    \n    # does it handle small numbers\n    add_test (TutorialSmall Tutorial 0.0001)\n    set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION \"0.0001 is 0.01\")\n    \n    # does the usage message work?\n    add_test (TutorialUsage Tutorial)\n    set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\")\n\n然后终端运行`make test`即可测试程序\n\n## 为顶层目标增加一个依赖\n让一个顶层目标依赖于其他的顶层目标。一个顶层目标是由命令ADD_EXECUTABLE，ADD_LIBRARY，或者ADD_CUSTOM_TARGET产生的目标。\n为这些命令的输出引入依赖性可以保证某个目标在其他的目标之前被构建。\n\n如下是在构建目标时使用了ROS中自定义的消息和服务的文件,增加依赖可以确保构建目标之前先生成对应的头文件\n    \n    add_dependencies(your_program ${catkin_EXPORTED_TARGETS})\n    add_dependencies(your_library ${catkin_EXPORTED_TARGETS})\n\n## 补充 待整理\n    add_compile_options(-Wall -Wextra)  # -Wall 打开编译输出警告 -Wextra打印一些额外的警告 是gcc的编译参数\n\n# 引用\n1. [ROS中的CMakeLists.txt](https://blog.csdn.net/u013243710/article/details/35795841)\n2. [catkin CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt#Finding_Dependent_CMake_Packages)\n3. [ROS下的CMakeList.txt编写](https://blog.csdn.net/turboian/article/details/74604052)\n4. [cmake教程4(find_package使用)](https://blog.csdn.net/haluoluo211/article/details/80559341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf)\n5. [GCC 警告选项 -Werror](https://blog.csdn.net/cui918/article/details/53187643)\n \n    \n  \n    \n              ","source":"_posts/ROS中CMakeLists-txt.md","raw":"---\ntitle: ROS中CMakeLists.txt\ndate: 2019-10-05 19:25:10\ncategories:\n- Linux\ntags:\n- ROS\n\n---\n# 概述\nCMake构建系统通过ROS包中的CMakeList.txt来构建软件包。\n在catkin 项目中，CMakeList.txt 符合标准的vanilla CMakeList.txt 格式，但稍微有点不同。\n\n# 整体结构\n\n1. 所需CMake版本(cmake_minimum_required)\n2. 软件包名称(project())\n3. 查找构建所需的其他CMake / Catkin软件包(find_package())\n4. 启用Python模块支持(catkin_python_setup())\n5. 消息/服务/动作生成器(add_message_files()，add_service_files()，add_action_files())\n6. 生成消息/服务/动作等自定义消息(generate_messages())\n7. 指定包的构建信息输出(catkin_package())\n8. 要建立的库/可执行文件(add_library()/ add_executable()/ target_link_libraries())\n9. 测试(catkin_add_gtest())\n10. 安装规则(install())\n\n# 软件版本\n    cmake_minimum_required(VERSION 2.8.3)\n    \n# 软件包名称\n可通过变量${PROJECT_NAME}来引用项目名称\n    \n    project(robot_brain)    \n# 查找相关CMake包\n指明构建package需要的包，使用catkin_make，所以catkin是必备依赖,在此基础上可能需要其他的包\n\n    find_package(catkin REQUIRED)   \n    \n    find_package(catkin REQUIRED COMPONENTS nodelet)  #第一种方式 合并写\n     \n    find_package(catkin REQUIRED)   # 第二种方式 分开写\n    find_package(nodelet REQUIRED)\n## find-package作用\n     \n 如果CMake通过find_package找到一个包，则会自动生成有关包所在路径的CMake环境变量，\n 环境变量描述了包中头文件的位置，源文件的位置，包所依赖的库文件位置。\n 这些变量名称以< PACKAGE NAME >_< PROPERTY >的形式出现：\n \n - < NAME >_FOUND - 如果找到库，则设置为true，否则为false\n - < NAME > _INCLUDE_DIRS或 _INCLUDES - 这个包输出的头文件目录\n - < NAME > _LIBRARIES或 _LIBS - 由包导出的库\n - < NAME > _DEFINITIONS - ?\n - …\n### cmake 中的find_package\n- 模块模式.属于精简格式,搜索所有名为Find<package>.cmake的文件，这些文件的路径由变量由安装CMake时指定的CMAKE_MODULE_PATH变量指定。如果查找到了该文件，它会被CMake读取并被处理。\n- 配置模式.没有找到任何模块就会进入配置模式.试图查找一个由待查找的包提供的配置文件的位置。查找<package>Config.cmake或者<package全小写>-config.cmake\n搜索路径包括,比如ros内部定义了CMAKE_PREFIX_PATH=/opt/ros/kinetic/share\n\n       <package>_DIR\n       CMAKE_PREFIX_PATH\n       CMAKE_FRAMEWORK_PATH\n       CMAKE_APPBUNDLE_PATH\n\n编译第三方库如软件时需要知道头文件路径(gcc的-I参数),库文件路径(gcc的-L参数),库文件名字(gcc的-l参数)\n\n比如在CMakeList.txt中\n\n    include_directiories(/usr/include/curl)\n    target_link_libraries(myprogram path/curl.so)\n借助cmake提供的finder,使用cmake的Modules目录下的FindCURL.cmake，相应的CMakeList.txt 文件：\n    \n    find_package(CURL REQUIRED)\n    include_directories(${CURL_INCLUDE_DIR})\n    target_link_libraries(curltest ${CURL_LIBRARY})\n#### find_package原理\nfind_package会在模块路径中查找Find.cmake,路径:变量${CMAKE_MODULE_PATH}中的所有目录。\n如果没有，然后再查看它自己的模块目录/usr/share/cmake-3.5/Modules/(具体值通过在CMakeLists.txt中写message(${CMAKE_ROOT})输出).这称为模块模式.\n\n查看包\n    \n        cmake --help-module-list # 双击Tab会有提示   \n        cmake --help-module Find FindBZip2     #查看Bzip2的帮助\n        \n        # 输出如下,可知道对应头文件和源文件变量名\n        FindBZip2\n        ---------\n        \n        Try to find BZip2\n        \n        Once done this will define\n        \n        ::\n        \n         BZIP2_FOUND - system has BZip2\n         BZIP2_INCLUDE_DIR - the BZip2 include directory\n         BZIP2_LIBRARIES - Link these to use BZip2\n         BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_\n         BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)\n\n             \n     \n## 为什么Catkin包是组件形式\nCatkin的包并不是catkin的真正组成部分。而catkin采用CMake的组件功能，主要是为了节省打字时间。\n\n    #这种方式 会把组件中的包对应的include路径、库导出到catkin前缀的变量中，\n    #例如catkin_INCLUDE_DIRS包含多个包的路径\n    find_package（catkin REQUIRED COMPONENTS nodelet）\n\n    find_package(nodelet REQUIRED)  # 而这种方式 路径和库不会导入catkin变量，而是nodelet_INCLUDE_DIRS之类的\n##　Boost库\n如果使用C ++和Boost，则需要用find_package()来找Boost库，并指定Boost中的组件。如果想使用Boost线程，就可以写成：\n    \n    find_package（Boost REQUIRED COMPONENTS thread）\n#　catkin_package()\n将catkin特定的信息输出到构建系统上，用于生成pkg配置文件以及CMake文件        \n- INCLUDE_DIRS - 导出包的include路径\n- LIBRARIES - 导出项目中的库\n- CATKIN_DEPENDS - 该项目依赖的其他catkin项目\n- DEPENDS - 该项目所依赖的非catkin CMake项目。\n- CFG_EXTRAS - 其他配置选项\n\n        catkin_package(\n           INCLUDE_DIRS include\n           LIBRARIES ${PROJECT_NAME}　　　\n           CATKIN_DEPENDS roscpp nodelet\n           DEPENDS eigen opencv)\n这表示包文件夹中的文件夹“include”是导出头文件的地方。  \n${PROJECT_NAME}根据project中的内容生成，此处是robot_brain\n“roscpp”+“nodelet”是用来构建/运行此程序包的catkin包，\n而“eigen”+“opencv”是用于构建/运行此程序包的非catkin包。   \n# 指定构建目标\n## 包含路径和库\n1. include_directories()\n\n参数应该是调用find_package调用时生成的* _INCLUDE_DIRS变量。\n如果使用catkin和Boost，那么include_directories()调用应该如下所示：\n        \n    include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})\n第一个参数“include”表示包中的include /目录也是路径的一部分。\n2. link_directories()\n\n用于添加额外的库路径，但通常不推荐这样做，因为 所有catkin和CMake软件包在find_packaged时都会自动添加链接信息。 \n只需写target_link_libraries()中就可以了。但真要写，就按照下面那样来写：\n\n    link_directories(~/my_libs)\n## 可执行目标\n生成可执行程序对应的源文件\n\n    add_executable(myProgram src/main.cpp src/some_file.cpp)\n## 库目标\n默认的catkin编译产生的共享库\n\n    add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})　　#指定要构建的库\n## target_link_libraries\n指定可执行目标链接的库。 通常在add_executable()调用之后完成。 \n如果找不到ros，则添加$ {catkin_LIBRARIES}。\n\n    target_link_libraries(<executableTargetName>, <lib1>, <lib2>, ... <libN>)\n大多数情况中不需要使用link_directories()，因为find_package()自动拉入。   \n# 消息、服务和响应\n## 使用条件\n    \n    # CMakeLists.txt\n    find_package(catkin REQUIRED COMPONENTS message_generation ...)\n    add_message_files(...)\n    add_service_files(...)\n    add_action_files(...)\n    generate_messages(...)\n    catkin_package(\n     ...\n     CATKIN_DEPENDS message_runtime ...\n     ...)\n    \n    # package.xml文件中加上 \n    <build_depend>message_generation</build_depend>\n    <run_depend>message_runtime</run_depend>\n1. 如果构建的对象依赖于其他包提供的消息/服务/动作的头文件,\n则需要向目标catkin_EXPORTED_TARGETS添加明确的依赖关系,以便它们以正确的顺序构建。     \n    \n        add_dependencies(some_target ${catkin_EXPORTED_TARGETS})  # 通常是find_package中找到的包导出的对象\n2. 如果构建的对象依赖自己包定义的消息或服务\n\n        add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})\n    具体的变量包含的内容可以通过`message ${${PROJECT_NAME}_EXPORTED_TARGETS}`查看             \n\n## 例子\n现在有两个依赖于std_msgs和sensor_msgs的消息MyMessage1.msg和MyMessage2.msg，\n还有一个自定义服务MyService.srv， message_program是使用这些消息和服务的指令，\n以及生成不使用自定义消息、服务的程序 do_not_use_local_messages_program 不使用，\n那么CMakeLists.txt应该写成：\n\n    # 构建时依赖项\n    find_package(catkin REQUIRED COMPONENTS          \n                 message_generation \n                 std_msgs \n    \n    # 声明要构建哪些消息\n    add_message_files(FILES\n                      MyMessage1.msg\n                      MyMessage2.msg)\n    \n    # 声明构建哪些服务\n    add_service_files(FILES\n                      MyService.srv)\n    \n    # 声明生成上述消息、服务需要依赖的消息以及服务\n    generate_messages(DEPENDENCIES \n                        std_msgs \n                        sensor_msgs)\n    \n    # 声明运行时依赖项\n    catkin_package(CATKIN_DEPENDS \n                    message_runtime \n                    std_msgs sensor_msgs)\n    \n    # 声明构建生成的可执行文件名称以及依赖项\n    add_executable(message_program src/main.cpp)\n    add_dependencies(message_program ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})\n    \n    # 声明构建不需要使用自定义消息、服务的可执行文件\n    add_executable(does_not_use_local_messages_program src/main.cpp)\n    add_dependencies(does_not_use_local_messages_program ${catkin_EXPORTED_TARGETS})\n# 问题\n1. 之前用矩阵运算c++库:Armadillo 直接作为catkin组件时找不到库\n\n解决方案：find_package() 把Armadillo单独拿出来 后面需要的地方链接到库 \n    \n    find_package(Armadillo 5.4 REQUIRED)\n    target_link_libraries(tp_gmr_node ${catkin_LIBRARIES} ${ARMADILLO_LIBRARIES})\n\n# CMake\n下面主要讲CMake对应CMakelists.txt中对应内容,和ROS无光\n\n## 安装与测试\n安装MathFuncitons到${CMAKE_INSTALL_PREFIX}/bin,安装MathFunctions.h到${CMAKE_INSTALL_PREFIX}/include.其实就是拷贝文件\n${CMAKE_INSTALL_PREFIX}在ubuntu系统上默认是/usr/local\n\n    install (TARGETS MathFunctions DESTINATION bin)\n    install (FILES MathFunctions.h DESTINATION include)\n\n下面部分ROS和cmake规则是一样的,只是安装到的位置不一样,比如cmake指定相对于${CMAKE_INSTALL_PREFIX}下的bin,只需要替换变量即可\n1. 安装工程中的目标(targets,即库和可执行文件).对于动态库不是DLL的平台对应的含义如下代码.DLL平台(给予Windows的系统),动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标.\n\n        install(TARGETS your_library your_other_library\n                ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 静态库\n                LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 动态库\n                RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})   # 可执行文件\n2. 安装库使用的头文件(函数调用接口)\n    \n        install(DIRECTORY include/${PROJECT_NAME}/\n                DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})\n3. 如果文件夹内有不需要安装的如这里是svn仓库,可以排除.svn\n    \n        install(DIRECTORY include/${PROJECT_NAME}/\n                DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}\n                PATTERN \".svn\" EXCLUDE)\n                \n终端运行`make install` 安装文件,如果没有权限则需要切换为管理员\n    \n测试可以在CMakeLists.txt中编写\n    \n    include(CTest)\n    \n    # does the application run \n    # 第一个参数是测试的提示 第二个参数的可执行程序 第三个参数是程序带的参数 \n    add_test (TutorialRuns Tutorial 25)\n    \n    # does it sqrt of 25\n    add_test (TutorialComp25 Tutorial 25)\n    set_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION \"25 is 5\")\n    \n    # does it handle negative numbers\n    add_test (TutorialNegative Tutorial -25)\n    set_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION \"-25 is 0\")\n    \n    # does it handle small numbers\n    add_test (TutorialSmall Tutorial 0.0001)\n    set_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION \"0.0001 is 0.01\")\n    \n    # does the usage message work?\n    add_test (TutorialUsage Tutorial)\n    set_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage:.*number\")\n\n然后终端运行`make test`即可测试程序\n\n## 为顶层目标增加一个依赖\n让一个顶层目标依赖于其他的顶层目标。一个顶层目标是由命令ADD_EXECUTABLE，ADD_LIBRARY，或者ADD_CUSTOM_TARGET产生的目标。\n为这些命令的输出引入依赖性可以保证某个目标在其他的目标之前被构建。\n\n如下是在构建目标时使用了ROS中自定义的消息和服务的文件,增加依赖可以确保构建目标之前先生成对应的头文件\n    \n    add_dependencies(your_program ${catkin_EXPORTED_TARGETS})\n    add_dependencies(your_library ${catkin_EXPORTED_TARGETS})\n\n## 补充 待整理\n    add_compile_options(-Wall -Wextra)  # -Wall 打开编译输出警告 -Wextra打印一些额外的警告 是gcc的编译参数\n\n# 引用\n1. [ROS中的CMakeLists.txt](https://blog.csdn.net/u013243710/article/details/35795841)\n2. [catkin CMakeLists.txt](http://wiki.ros.org/catkin/CMakeLists.txt#Finding_Dependent_CMake_Packages)\n3. [ROS下的CMakeList.txt编写](https://blog.csdn.net/turboian/article/details/74604052)\n4. [cmake教程4(find_package使用)](https://blog.csdn.net/haluoluo211/article/details/80559341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf)\n5. [GCC 警告选项 -Werror](https://blog.csdn.net/cui918/article/details/53187643)\n \n    \n  \n    \n              ","slug":"ROS中CMakeLists-txt","published":1,"updated":"2020-11-19T11:34:36.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjf006vmxka4erdw0bm","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>CMake构建系统通过ROS包中的CMakeList.txt来构建软件包。<br>在catkin 项目中，CMakeList.txt 符合标准的vanilla CMakeList.txt 格式，但稍微有点不同。</p>\n<h1 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h1><ol>\n<li>所需CMake版本(cmake_minimum_required)</li>\n<li>软件包名称(project())</li>\n<li>查找构建所需的其他CMake / Catkin软件包(find_package())</li>\n<li>启用Python模块支持(catkin_python_setup())</li>\n<li>消息/服务/动作生成器(add_message_files()，add_service_files()，add_action_files())</li>\n<li>生成消息/服务/动作等自定义消息(generate_messages())</li>\n<li>指定包的构建信息输出(catkin_package())</li>\n<li>要建立的库/可执行文件(add_library()/ add_executable()/ target_link_libraries())</li>\n<li>测试(catkin_add_gtest())</li>\n<li>安装规则(install())</li>\n</ol>\n<h1 id=\"软件版本\"><a href=\"#软件版本\" class=\"headerlink\" title=\"软件版本\"></a>软件版本</h1><pre><code>cmake_minimum_required(VERSION 2.8.3)\n</code></pre><h1 id=\"软件包名称\"><a href=\"#软件包名称\" class=\"headerlink\" title=\"软件包名称\"></a>软件包名称</h1><p>可通过变量${PROJECT_NAME}来引用项目名称</p>\n<pre><code>project(robot_brain)    \n</code></pre><h1 id=\"查找相关CMake包\"><a href=\"#查找相关CMake包\" class=\"headerlink\" title=\"查找相关CMake包\"></a>查找相关CMake包</h1><p>指明构建package需要的包，使用catkin_make，所以catkin是必备依赖,在此基础上可能需要其他的包</p>\n<pre><code>find_package(catkin REQUIRED)   \n\nfind_package(catkin REQUIRED COMPONENTS nodelet)  #第一种方式 合并写\n\nfind_package(catkin REQUIRED)   # 第二种方式 分开写\nfind_package(nodelet REQUIRED)\n</code></pre><h2 id=\"find-package作用\"><a href=\"#find-package作用\" class=\"headerlink\" title=\"find-package作用\"></a>find-package作用</h2><p> 如果CMake通过find_package找到一个包，则会自动生成有关包所在路径的CMake环境变量，<br> 环境变量描述了包中头文件的位置，源文件的位置，包所依赖的库文件位置。<br> 这些变量名称以&lt; PACKAGE NAME &gt;_&lt; PROPERTY &gt;的形式出现：</p>\n<ul>\n<li>&lt; NAME &gt;_FOUND - 如果找到库，则设置为true，否则为false</li>\n<li>&lt; NAME &gt; _INCLUDE_DIRS或 _INCLUDES - 这个包输出的头文件目录</li>\n<li>&lt; NAME &gt; _LIBRARIES或 _LIBS - 由包导出的库</li>\n<li>&lt; NAME &gt; _DEFINITIONS - ?</li>\n<li><p>…</p>\n<h3 id=\"cmake-中的find-package\"><a href=\"#cmake-中的find-package\" class=\"headerlink\" title=\"cmake 中的find_package\"></a>cmake 中的find_package</h3><ul>\n<li>模块模式.属于精简格式,搜索所有名为Find<package>.cmake的文件，这些文件的路径由变量由安装CMake时指定的CMAKE_MODULE_PATH变量指定。如果查找到了该文件，它会被CMake读取并被处理。</package></li>\n<li><p>配置模式.没有找到任何模块就会进入配置模式.试图查找一个由待查找的包提供的配置文件的位置。查找<package>Config.cmake或者<package全小写>-config.cmake<br>搜索路径包括,比如ros内部定义了CMAKE_PREFIX_PATH=/opt/ros/kinetic/share</package全小写></package></p>\n<p>  <package>_DIR<br>  CMAKE_PREFIX_PATH<br>  CMAKE_FRAMEWORK_PATH<br>  CMAKE_APPBUNDLE_PATH</package></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>编译第三方库如软件时需要知道头文件路径(gcc的-I参数),库文件路径(gcc的-L参数),库文件名字(gcc的-l参数)</p>\n<p>比如在CMakeList.txt中</p>\n<pre><code>include_directiories(/usr/include/curl)\ntarget_link_libraries(myprogram path/curl.so)\n</code></pre><p>借助cmake提供的finder,使用cmake的Modules目录下的FindCURL.cmake，相应的CMakeList.txt 文件：</p>\n<pre><code>find_package(CURL REQUIRED)\ninclude_directories(${CURL_INCLUDE_DIR})\ntarget_link_libraries(curltest ${CURL_LIBRARY})\n</code></pre><h4 id=\"find-package原理\"><a href=\"#find-package原理\" class=\"headerlink\" title=\"find_package原理\"></a>find_package原理</h4><p>find_package会在模块路径中查找Find.cmake,路径:变量${CMAKE_MODULE_PATH}中的所有目录。<br>如果没有，然后再查看它自己的模块目录/usr/share/cmake-3.5/Modules/(具体值通过在CMakeLists.txt中写message(${CMAKE_ROOT})输出).这称为模块模式.</p>\n<p>查看包</p>\n<pre><code>    cmake --help-module-list # 双击Tab会有提示   \n    cmake --help-module Find FindBZip2     #查看Bzip2的帮助\n\n    # 输出如下,可知道对应头文件和源文件变量名\n    FindBZip2\n    ---------\n\n    Try to find BZip2\n\n    Once done this will define\n\n    ::\n\n     BZIP2_FOUND - system has BZip2\n     BZIP2_INCLUDE_DIR - the BZip2 include directory\n     BZIP2_LIBRARIES - Link these to use BZip2\n     BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_\n     BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)\n</code></pre><h2 id=\"为什么Catkin包是组件形式\"><a href=\"#为什么Catkin包是组件形式\" class=\"headerlink\" title=\"为什么Catkin包是组件形式\"></a>为什么Catkin包是组件形式</h2><p>Catkin的包并不是catkin的真正组成部分。而catkin采用CMake的组件功能，主要是为了节省打字时间。</p>\n<pre><code>#这种方式 会把组件中的包对应的include路径、库导出到catkin前缀的变量中，\n#例如catkin_INCLUDE_DIRS包含多个包的路径\nfind_package（catkin REQUIRED COMPONENTS nodelet）\n\nfind_package(nodelet REQUIRED)  # 而这种方式 路径和库不会导入catkin变量，而是nodelet_INCLUDE_DIRS之类的\n</code></pre><h2 id=\"Boost库\"><a href=\"#Boost库\" class=\"headerlink\" title=\"　Boost库\"></a>　Boost库</h2><p>如果使用C ++和Boost，则需要用find_package()来找Boost库，并指定Boost中的组件。如果想使用Boost线程，就可以写成：</p>\n<pre><code>find_package（Boost REQUIRED COMPONENTS thread）\n</code></pre><h1 id=\"catkin-package\"><a href=\"#catkin-package\" class=\"headerlink\" title=\"　catkin_package()\"></a>　catkin_package()</h1><p>将catkin特定的信息输出到构建系统上，用于生成pkg配置文件以及CMake文件        </p>\n<ul>\n<li>INCLUDE_DIRS - 导出包的include路径</li>\n<li>LIBRARIES - 导出项目中的库</li>\n<li>CATKIN_DEPENDS - 该项目依赖的其他catkin项目</li>\n<li>DEPENDS - 该项目所依赖的非catkin CMake项目。</li>\n<li><p>CFG_EXTRAS - 其他配置选项</p>\n<pre><code>  catkin_package(\n     INCLUDE_DIRS include\n     LIBRARIES ${PROJECT_NAME}　　　\n     CATKIN_DEPENDS roscpp nodelet\n     DEPENDS eigen opencv)\n</code></pre><p>这表示包文件夹中的文件夹“include”是导出头文件的地方。<br>${PROJECT_NAME}根据project中的内容生成，此处是robot_brain<br>“roscpp”+“nodelet”是用来构建/运行此程序包的catkin包，<br>而“eigen”+“opencv”是用于构建/运行此程序包的非catkin包。   </p>\n<h1 id=\"指定构建目标\"><a href=\"#指定构建目标\" class=\"headerlink\" title=\"指定构建目标\"></a>指定构建目标</h1><h2 id=\"包含路径和库\"><a href=\"#包含路径和库\" class=\"headerlink\" title=\"包含路径和库\"></a>包含路径和库</h2></li>\n</ul>\n<ol>\n<li>include_directories()</li>\n</ol>\n<p>参数应该是调用find_package调用时生成的* _INCLUDE_DIRS变量。<br>如果使用catkin和Boost，那么include_directories()调用应该如下所示：</p>\n<pre><code>include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})\n</code></pre><p>第一个参数“include”表示包中的include /目录也是路径的一部分。</p>\n<ol>\n<li>link_directories()</li>\n</ol>\n<p>用于添加额外的库路径，但通常不推荐这样做，因为 所有catkin和CMake软件包在find_packaged时都会自动添加链接信息。<br>只需写target_link_libraries()中就可以了。但真要写，就按照下面那样来写：</p>\n<pre><code>link_directories(~/my_libs)\n</code></pre><h2 id=\"可执行目标\"><a href=\"#可执行目标\" class=\"headerlink\" title=\"可执行目标\"></a>可执行目标</h2><p>生成可执行程序对应的源文件</p>\n<pre><code>add_executable(myProgram src/main.cpp src/some_file.cpp)\n</code></pre><h2 id=\"库目标\"><a href=\"#库目标\" class=\"headerlink\" title=\"库目标\"></a>库目标</h2><p>默认的catkin编译产生的共享库</p>\n<pre><code>add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})　　#指定要构建的库\n</code></pre><h2 id=\"target-link-libraries\"><a href=\"#target-link-libraries\" class=\"headerlink\" title=\"target_link_libraries\"></a>target_link_libraries</h2><p>指定可执行目标链接的库。 通常在add_executable()调用之后完成。<br>如果找不到ros，则添加$ {catkin_LIBRARIES}。</p>\n<pre><code>target_link_libraries(&lt;executableTargetName&gt;, &lt;lib1&gt;, &lt;lib2&gt;, ... &lt;libN&gt;)\n</code></pre><p>大多数情况中不需要使用link_directories()，因为find_package()自动拉入。   </p>\n<h1 id=\"消息、服务和响应\"><a href=\"#消息、服务和响应\" class=\"headerlink\" title=\"消息、服务和响应\"></a>消息、服务和响应</h1><h2 id=\"使用条件\"><a href=\"#使用条件\" class=\"headerlink\" title=\"使用条件\"></a>使用条件</h2><pre><code># CMakeLists.txt\nfind_package(catkin REQUIRED COMPONENTS message_generation ...)\nadd_message_files(...)\nadd_service_files(...)\nadd_action_files(...)\ngenerate_messages(...)\ncatkin_package(\n ...\n CATKIN_DEPENDS message_runtime ...\n ...)\n\n# package.xml文件中加上 \n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;\n</code></pre><ol>\n<li><p>如果构建的对象依赖于其他包提供的消息/服务/动作的头文件,<br>则需要向目标catkin_EXPORTED_TARGETS添加明确的依赖关系,以便它们以正确的顺序构建。     </p>\n<pre><code> add_dependencies(some_target ${catkin_EXPORTED_TARGETS})  # 通常是find_package中找到的包导出的对象\n</code></pre></li>\n<li><p>如果构建的对象依赖自己包定义的消息或服务</p>\n<pre><code> add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})\n</code></pre><p> 具体的变量包含的内容可以通过<code>message ${${PROJECT_NAME}_EXPORTED_TARGETS}</code>查看             </p>\n</li>\n</ol>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>现在有两个依赖于std_msgs和sensor_msgs的消息MyMessage1.msg和MyMessage2.msg，<br>还有一个自定义服务MyService.srv， message_program是使用这些消息和服务的指令，<br>以及生成不使用自定义消息、服务的程序 do_not_use_local_messages_program 不使用，<br>那么CMakeLists.txt应该写成：</p>\n<pre><code># 构建时依赖项\nfind_package(catkin REQUIRED COMPONENTS          \n             message_generation \n             std_msgs \n\n# 声明要构建哪些消息\nadd_message_files(FILES\n                  MyMessage1.msg\n                  MyMessage2.msg)\n\n# 声明构建哪些服务\nadd_service_files(FILES\n                  MyService.srv)\n\n# 声明生成上述消息、服务需要依赖的消息以及服务\ngenerate_messages(DEPENDENCIES \n                    std_msgs \n                    sensor_msgs)\n\n# 声明运行时依赖项\ncatkin_package(CATKIN_DEPENDS \n                message_runtime \n                std_msgs sensor_msgs)\n\n# 声明构建生成的可执行文件名称以及依赖项\nadd_executable(message_program src/main.cpp)\nadd_dependencies(message_program ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})\n\n# 声明构建不需要使用自定义消息、服务的可执行文件\nadd_executable(does_not_use_local_messages_program src/main.cpp)\nadd_dependencies(does_not_use_local_messages_program ${catkin_EXPORTED_TARGETS})\n</code></pre><h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>之前用矩阵运算c++库:Armadillo 直接作为catkin组件时找不到库</li>\n</ol>\n<p>解决方案：find_package() 把Armadillo单独拿出来 后面需要的地方链接到库 </p>\n<pre><code>find_package(Armadillo 5.4 REQUIRED)\ntarget_link_libraries(tp_gmr_node ${catkin_LIBRARIES} ${ARMADILLO_LIBRARIES})\n</code></pre><h1 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h1><p>下面主要讲CMake对应CMakelists.txt中对应内容,和ROS无光</p>\n<h2 id=\"安装与测试\"><a href=\"#安装与测试\" class=\"headerlink\" title=\"安装与测试\"></a>安装与测试</h2><p>安装MathFuncitons到${CMAKE_INSTALL_PREFIX}/bin,安装MathFunctions.h到${CMAKE_INSTALL_PREFIX}/include.其实就是拷贝文件<br>${CMAKE_INSTALL_PREFIX}在ubuntu系统上默认是/usr/local</p>\n<pre><code>install (TARGETS MathFunctions DESTINATION bin)\ninstall (FILES MathFunctions.h DESTINATION include)\n</code></pre><p>下面部分ROS和cmake规则是一样的,只是安装到的位置不一样,比如cmake指定相对于${CMAKE_INSTALL_PREFIX}下的bin,只需要替换变量即可</p>\n<ol>\n<li><p>安装工程中的目标(targets,即库和可执行文件).对于动态库不是DLL的平台对应的含义如下代码.DLL平台(给予Windows的系统),动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标.</p>\n<pre><code> install(TARGETS your_library your_other_library\n         ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 静态库\n         LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 动态库\n         RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})   # 可执行文件\n</code></pre></li>\n<li><p>安装库使用的头文件(函数调用接口)</p>\n<pre><code> install(DIRECTORY include/${PROJECT_NAME}/\n         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})\n</code></pre></li>\n<li><p>如果文件夹内有不需要安装的如这里是svn仓库,可以排除.svn</p>\n<pre><code> install(DIRECTORY include/${PROJECT_NAME}/\n         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}\n         PATTERN &quot;.svn&quot; EXCLUDE)\n</code></pre></li>\n</ol>\n<p>终端运行<code>make install</code> 安装文件,如果没有权限则需要切换为管理员</p>\n<p>测试可以在CMakeLists.txt中编写</p>\n<pre><code>include(CTest)\n\n# does the application run \n# 第一个参数是测试的提示 第二个参数的可执行程序 第三个参数是程序带的参数 \nadd_test (TutorialRuns Tutorial 25)\n\n# does it sqrt of 25\nadd_test (TutorialComp25 Tutorial 25)\nset_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;)\n\n# does it handle negative numbers\nadd_test (TutorialNegative Tutorial -25)\nset_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;)\n\n# does it handle small numbers\nadd_test (TutorialSmall Tutorial 0.0001)\nset_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;)\n\n# does the usage message work?\nadd_test (TutorialUsage Tutorial)\nset_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;)\n</code></pre><p>然后终端运行<code>make test</code>即可测试程序</p>\n<h2 id=\"为顶层目标增加一个依赖\"><a href=\"#为顶层目标增加一个依赖\" class=\"headerlink\" title=\"为顶层目标增加一个依赖\"></a>为顶层目标增加一个依赖</h2><p>让一个顶层目标依赖于其他的顶层目标。一个顶层目标是由命令ADD_EXECUTABLE，ADD_LIBRARY，或者ADD_CUSTOM_TARGET产生的目标。<br>为这些命令的输出引入依赖性可以保证某个目标在其他的目标之前被构建。</p>\n<p>如下是在构建目标时使用了ROS中自定义的消息和服务的文件,增加依赖可以确保构建目标之前先生成对应的头文件</p>\n<pre><code>add_dependencies(your_program ${catkin_EXPORTED_TARGETS})\nadd_dependencies(your_library ${catkin_EXPORTED_TARGETS})\n</code></pre><h2 id=\"补充-待整理\"><a href=\"#补充-待整理\" class=\"headerlink\" title=\"补充 待整理\"></a>补充 待整理</h2><pre><code>add_compile_options(-Wall -Wextra)  # -Wall 打开编译输出警告 -Wextra打印一些额外的警告 是gcc的编译参数\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/u013243710/article/details/35795841\" target=\"_blank\" rel=\"noopener\">ROS中的CMakeLists.txt</a></li>\n<li><a href=\"http://wiki.ros.org/catkin/CMakeLists.txt#Finding_Dependent_CMake_Packages\" target=\"_blank\" rel=\"noopener\">catkin CMakeLists.txt</a></li>\n<li><a href=\"https://blog.csdn.net/turboian/article/details/74604052\" target=\"_blank\" rel=\"noopener\">ROS下的CMakeList.txt编写</a></li>\n<li><a href=\"https://blog.csdn.net/haluoluo211/article/details/80559341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf\" target=\"_blank\" rel=\"noopener\">cmake教程4(find_package使用)</a></li>\n<li><a href=\"https://blog.csdn.net/cui918/article/details/53187643\" target=\"_blank\" rel=\"noopener\">GCC 警告选项 -Werror</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>CMake构建系统通过ROS包中的CMakeList.txt来构建软件包。<br>在catkin 项目中，CMakeList.txt 符合标准的vanilla CMakeList.txt 格式，但稍微有点不同。</p>\n<h1 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h1><ol>\n<li>所需CMake版本(cmake_minimum_required)</li>\n<li>软件包名称(project())</li>\n<li>查找构建所需的其他CMake / Catkin软件包(find_package())</li>\n<li>启用Python模块支持(catkin_python_setup())</li>\n<li>消息/服务/动作生成器(add_message_files()，add_service_files()，add_action_files())</li>\n<li>生成消息/服务/动作等自定义消息(generate_messages())</li>\n<li>指定包的构建信息输出(catkin_package())</li>\n<li>要建立的库/可执行文件(add_library()/ add_executable()/ target_link_libraries())</li>\n<li>测试(catkin_add_gtest())</li>\n<li>安装规则(install())</li>\n</ol>\n<h1 id=\"软件版本\"><a href=\"#软件版本\" class=\"headerlink\" title=\"软件版本\"></a>软件版本</h1><pre><code>cmake_minimum_required(VERSION 2.8.3)\n</code></pre><h1 id=\"软件包名称\"><a href=\"#软件包名称\" class=\"headerlink\" title=\"软件包名称\"></a>软件包名称</h1><p>可通过变量${PROJECT_NAME}来引用项目名称</p>\n<pre><code>project(robot_brain)    \n</code></pre><h1 id=\"查找相关CMake包\"><a href=\"#查找相关CMake包\" class=\"headerlink\" title=\"查找相关CMake包\"></a>查找相关CMake包</h1><p>指明构建package需要的包，使用catkin_make，所以catkin是必备依赖,在此基础上可能需要其他的包</p>\n<pre><code>find_package(catkin REQUIRED)   \n\nfind_package(catkin REQUIRED COMPONENTS nodelet)  #第一种方式 合并写\n\nfind_package(catkin REQUIRED)   # 第二种方式 分开写\nfind_package(nodelet REQUIRED)\n</code></pre><h2 id=\"find-package作用\"><a href=\"#find-package作用\" class=\"headerlink\" title=\"find-package作用\"></a>find-package作用</h2><p> 如果CMake通过find_package找到一个包，则会自动生成有关包所在路径的CMake环境变量，<br> 环境变量描述了包中头文件的位置，源文件的位置，包所依赖的库文件位置。<br> 这些变量名称以&lt; PACKAGE NAME &gt;_&lt; PROPERTY &gt;的形式出现：</p>\n<ul>\n<li>&lt; NAME &gt;_FOUND - 如果找到库，则设置为true，否则为false</li>\n<li>&lt; NAME &gt; _INCLUDE_DIRS或 _INCLUDES - 这个包输出的头文件目录</li>\n<li>&lt; NAME &gt; _LIBRARIES或 _LIBS - 由包导出的库</li>\n<li>&lt; NAME &gt; _DEFINITIONS - ?</li>\n<li><p>…</p>\n<h3 id=\"cmake-中的find-package\"><a href=\"#cmake-中的find-package\" class=\"headerlink\" title=\"cmake 中的find_package\"></a>cmake 中的find_package</h3><ul>\n<li>模块模式.属于精简格式,搜索所有名为Find<package>.cmake的文件，这些文件的路径由变量由安装CMake时指定的CMAKE_MODULE_PATH变量指定。如果查找到了该文件，它会被CMake读取并被处理。</package></li>\n<li><p>配置模式.没有找到任何模块就会进入配置模式.试图查找一个由待查找的包提供的配置文件的位置。查找<package>Config.cmake或者<package全小写>-config.cmake<br>搜索路径包括,比如ros内部定义了CMAKE_PREFIX_PATH=/opt/ros/kinetic/share</package全小写></package></p>\n<p>  <package>_DIR<br>  CMAKE_PREFIX_PATH<br>  CMAKE_FRAMEWORK_PATH<br>  CMAKE_APPBUNDLE_PATH</package></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>编译第三方库如软件时需要知道头文件路径(gcc的-I参数),库文件路径(gcc的-L参数),库文件名字(gcc的-l参数)</p>\n<p>比如在CMakeList.txt中</p>\n<pre><code>include_directiories(/usr/include/curl)\ntarget_link_libraries(myprogram path/curl.so)\n</code></pre><p>借助cmake提供的finder,使用cmake的Modules目录下的FindCURL.cmake，相应的CMakeList.txt 文件：</p>\n<pre><code>find_package(CURL REQUIRED)\ninclude_directories(${CURL_INCLUDE_DIR})\ntarget_link_libraries(curltest ${CURL_LIBRARY})\n</code></pre><h4 id=\"find-package原理\"><a href=\"#find-package原理\" class=\"headerlink\" title=\"find_package原理\"></a>find_package原理</h4><p>find_package会在模块路径中查找Find.cmake,路径:变量${CMAKE_MODULE_PATH}中的所有目录。<br>如果没有，然后再查看它自己的模块目录/usr/share/cmake-3.5/Modules/(具体值通过在CMakeLists.txt中写message(${CMAKE_ROOT})输出).这称为模块模式.</p>\n<p>查看包</p>\n<pre><code>    cmake --help-module-list # 双击Tab会有提示   \n    cmake --help-module Find FindBZip2     #查看Bzip2的帮助\n\n    # 输出如下,可知道对应头文件和源文件变量名\n    FindBZip2\n    ---------\n\n    Try to find BZip2\n\n    Once done this will define\n\n    ::\n\n     BZIP2_FOUND - system has BZip2\n     BZIP2_INCLUDE_DIR - the BZip2 include directory\n     BZIP2_LIBRARIES - Link these to use BZip2\n     BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_\n     BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)\n</code></pre><h2 id=\"为什么Catkin包是组件形式\"><a href=\"#为什么Catkin包是组件形式\" class=\"headerlink\" title=\"为什么Catkin包是组件形式\"></a>为什么Catkin包是组件形式</h2><p>Catkin的包并不是catkin的真正组成部分。而catkin采用CMake的组件功能，主要是为了节省打字时间。</p>\n<pre><code>#这种方式 会把组件中的包对应的include路径、库导出到catkin前缀的变量中，\n#例如catkin_INCLUDE_DIRS包含多个包的路径\nfind_package（catkin REQUIRED COMPONENTS nodelet）\n\nfind_package(nodelet REQUIRED)  # 而这种方式 路径和库不会导入catkin变量，而是nodelet_INCLUDE_DIRS之类的\n</code></pre><h2 id=\"Boost库\"><a href=\"#Boost库\" class=\"headerlink\" title=\"　Boost库\"></a>　Boost库</h2><p>如果使用C ++和Boost，则需要用find_package()来找Boost库，并指定Boost中的组件。如果想使用Boost线程，就可以写成：</p>\n<pre><code>find_package（Boost REQUIRED COMPONENTS thread）\n</code></pre><h1 id=\"catkin-package\"><a href=\"#catkin-package\" class=\"headerlink\" title=\"　catkin_package()\"></a>　catkin_package()</h1><p>将catkin特定的信息输出到构建系统上，用于生成pkg配置文件以及CMake文件        </p>\n<ul>\n<li>INCLUDE_DIRS - 导出包的include路径</li>\n<li>LIBRARIES - 导出项目中的库</li>\n<li>CATKIN_DEPENDS - 该项目依赖的其他catkin项目</li>\n<li>DEPENDS - 该项目所依赖的非catkin CMake项目。</li>\n<li><p>CFG_EXTRAS - 其他配置选项</p>\n<pre><code>  catkin_package(\n     INCLUDE_DIRS include\n     LIBRARIES ${PROJECT_NAME}　　　\n     CATKIN_DEPENDS roscpp nodelet\n     DEPENDS eigen opencv)\n</code></pre><p>这表示包文件夹中的文件夹“include”是导出头文件的地方。<br>${PROJECT_NAME}根据project中的内容生成，此处是robot_brain<br>“roscpp”+“nodelet”是用来构建/运行此程序包的catkin包，<br>而“eigen”+“opencv”是用于构建/运行此程序包的非catkin包。   </p>\n<h1 id=\"指定构建目标\"><a href=\"#指定构建目标\" class=\"headerlink\" title=\"指定构建目标\"></a>指定构建目标</h1><h2 id=\"包含路径和库\"><a href=\"#包含路径和库\" class=\"headerlink\" title=\"包含路径和库\"></a>包含路径和库</h2></li>\n</ul>\n<ol>\n<li>include_directories()</li>\n</ol>\n<p>参数应该是调用find_package调用时生成的* _INCLUDE_DIRS变量。<br>如果使用catkin和Boost，那么include_directories()调用应该如下所示：</p>\n<pre><code>include_directories(include ${Boost_INCLUDE_DIRS} ${catkin_INCLUDE_DIRS})\n</code></pre><p>第一个参数“include”表示包中的include /目录也是路径的一部分。</p>\n<ol>\n<li>link_directories()</li>\n</ol>\n<p>用于添加额外的库路径，但通常不推荐这样做，因为 所有catkin和CMake软件包在find_packaged时都会自动添加链接信息。<br>只需写target_link_libraries()中就可以了。但真要写，就按照下面那样来写：</p>\n<pre><code>link_directories(~/my_libs)\n</code></pre><h2 id=\"可执行目标\"><a href=\"#可执行目标\" class=\"headerlink\" title=\"可执行目标\"></a>可执行目标</h2><p>生成可执行程序对应的源文件</p>\n<pre><code>add_executable(myProgram src/main.cpp src/some_file.cpp)\n</code></pre><h2 id=\"库目标\"><a href=\"#库目标\" class=\"headerlink\" title=\"库目标\"></a>库目标</h2><p>默认的catkin编译产生的共享库</p>\n<pre><code>add_library(${PROJECT_NAME} ${${PROJECT_NAME}_SRCS})　　#指定要构建的库\n</code></pre><h2 id=\"target-link-libraries\"><a href=\"#target-link-libraries\" class=\"headerlink\" title=\"target_link_libraries\"></a>target_link_libraries</h2><p>指定可执行目标链接的库。 通常在add_executable()调用之后完成。<br>如果找不到ros，则添加$ {catkin_LIBRARIES}。</p>\n<pre><code>target_link_libraries(&lt;executableTargetName&gt;, &lt;lib1&gt;, &lt;lib2&gt;, ... &lt;libN&gt;)\n</code></pre><p>大多数情况中不需要使用link_directories()，因为find_package()自动拉入。   </p>\n<h1 id=\"消息、服务和响应\"><a href=\"#消息、服务和响应\" class=\"headerlink\" title=\"消息、服务和响应\"></a>消息、服务和响应</h1><h2 id=\"使用条件\"><a href=\"#使用条件\" class=\"headerlink\" title=\"使用条件\"></a>使用条件</h2><pre><code># CMakeLists.txt\nfind_package(catkin REQUIRED COMPONENTS message_generation ...)\nadd_message_files(...)\nadd_service_files(...)\nadd_action_files(...)\ngenerate_messages(...)\ncatkin_package(\n ...\n CATKIN_DEPENDS message_runtime ...\n ...)\n\n# package.xml文件中加上 \n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n&lt;run_depend&gt;message_runtime&lt;/run_depend&gt;\n</code></pre><ol>\n<li><p>如果构建的对象依赖于其他包提供的消息/服务/动作的头文件,<br>则需要向目标catkin_EXPORTED_TARGETS添加明确的依赖关系,以便它们以正确的顺序构建。     </p>\n<pre><code> add_dependencies(some_target ${catkin_EXPORTED_TARGETS})  # 通常是find_package中找到的包导出的对象\n</code></pre></li>\n<li><p>如果构建的对象依赖自己包定义的消息或服务</p>\n<pre><code> add_dependencies(some_target ${${PROJECT_NAME}_EXPORTED_TARGETS})\n</code></pre><p> 具体的变量包含的内容可以通过<code>message ${${PROJECT_NAME}_EXPORTED_TARGETS}</code>查看             </p>\n</li>\n</ol>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>现在有两个依赖于std_msgs和sensor_msgs的消息MyMessage1.msg和MyMessage2.msg，<br>还有一个自定义服务MyService.srv， message_program是使用这些消息和服务的指令，<br>以及生成不使用自定义消息、服务的程序 do_not_use_local_messages_program 不使用，<br>那么CMakeLists.txt应该写成：</p>\n<pre><code># 构建时依赖项\nfind_package(catkin REQUIRED COMPONENTS          \n             message_generation \n             std_msgs \n\n# 声明要构建哪些消息\nadd_message_files(FILES\n                  MyMessage1.msg\n                  MyMessage2.msg)\n\n# 声明构建哪些服务\nadd_service_files(FILES\n                  MyService.srv)\n\n# 声明生成上述消息、服务需要依赖的消息以及服务\ngenerate_messages(DEPENDENCIES \n                    std_msgs \n                    sensor_msgs)\n\n# 声明运行时依赖项\ncatkin_package(CATKIN_DEPENDS \n                message_runtime \n                std_msgs sensor_msgs)\n\n# 声明构建生成的可执行文件名称以及依赖项\nadd_executable(message_program src/main.cpp)\nadd_dependencies(message_program ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})\n\n# 声明构建不需要使用自定义消息、服务的可执行文件\nadd_executable(does_not_use_local_messages_program src/main.cpp)\nadd_dependencies(does_not_use_local_messages_program ${catkin_EXPORTED_TARGETS})\n</code></pre><h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>之前用矩阵运算c++库:Armadillo 直接作为catkin组件时找不到库</li>\n</ol>\n<p>解决方案：find_package() 把Armadillo单独拿出来 后面需要的地方链接到库 </p>\n<pre><code>find_package(Armadillo 5.4 REQUIRED)\ntarget_link_libraries(tp_gmr_node ${catkin_LIBRARIES} ${ARMADILLO_LIBRARIES})\n</code></pre><h1 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h1><p>下面主要讲CMake对应CMakelists.txt中对应内容,和ROS无光</p>\n<h2 id=\"安装与测试\"><a href=\"#安装与测试\" class=\"headerlink\" title=\"安装与测试\"></a>安装与测试</h2><p>安装MathFuncitons到${CMAKE_INSTALL_PREFIX}/bin,安装MathFunctions.h到${CMAKE_INSTALL_PREFIX}/include.其实就是拷贝文件<br>${CMAKE_INSTALL_PREFIX}在ubuntu系统上默认是/usr/local</p>\n<pre><code>install (TARGETS MathFunctions DESTINATION bin)\ninstall (FILES MathFunctions.h DESTINATION include)\n</code></pre><p>下面部分ROS和cmake规则是一样的,只是安装到的位置不一样,比如cmake指定相对于${CMAKE_INSTALL_PREFIX}下的bin,只需要替换变量即可</p>\n<ol>\n<li><p>安装工程中的目标(targets,即库和可执行文件).对于动态库不是DLL的平台对应的含义如下代码.DLL平台(给予Windows的系统),动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标.</p>\n<pre><code> install(TARGETS your_library your_other_library\n         ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 静态库\n         LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}   # 动态库\n         RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION})   # 可执行文件\n</code></pre></li>\n<li><p>安装库使用的头文件(函数调用接口)</p>\n<pre><code> install(DIRECTORY include/${PROJECT_NAME}/\n         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})\n</code></pre></li>\n<li><p>如果文件夹内有不需要安装的如这里是svn仓库,可以排除.svn</p>\n<pre><code> install(DIRECTORY include/${PROJECT_NAME}/\n         DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}\n         PATTERN &quot;.svn&quot; EXCLUDE)\n</code></pre></li>\n</ol>\n<p>终端运行<code>make install</code> 安装文件,如果没有权限则需要切换为管理员</p>\n<p>测试可以在CMakeLists.txt中编写</p>\n<pre><code>include(CTest)\n\n# does the application run \n# 第一个参数是测试的提示 第二个参数的可执行程序 第三个参数是程序带的参数 \nadd_test (TutorialRuns Tutorial 25)\n\n# does it sqrt of 25\nadd_test (TutorialComp25 Tutorial 25)\nset_tests_properties (TutorialComp25 PROPERTIES PASS_REGULAR_EXPRESSION &quot;25 is 5&quot;)\n\n# does it handle negative numbers\nadd_test (TutorialNegative Tutorial -25)\nset_tests_properties (TutorialNegative PROPERTIES PASS_REGULAR_EXPRESSION &quot;-25 is 0&quot;)\n\n# does it handle small numbers\nadd_test (TutorialSmall Tutorial 0.0001)\nset_tests_properties (TutorialSmall PROPERTIES PASS_REGULAR_EXPRESSION &quot;0.0001 is 0.01&quot;)\n\n# does the usage message work?\nadd_test (TutorialUsage Tutorial)\nset_tests_properties (TutorialUsage PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage:.*number&quot;)\n</code></pre><p>然后终端运行<code>make test</code>即可测试程序</p>\n<h2 id=\"为顶层目标增加一个依赖\"><a href=\"#为顶层目标增加一个依赖\" class=\"headerlink\" title=\"为顶层目标增加一个依赖\"></a>为顶层目标增加一个依赖</h2><p>让一个顶层目标依赖于其他的顶层目标。一个顶层目标是由命令ADD_EXECUTABLE，ADD_LIBRARY，或者ADD_CUSTOM_TARGET产生的目标。<br>为这些命令的输出引入依赖性可以保证某个目标在其他的目标之前被构建。</p>\n<p>如下是在构建目标时使用了ROS中自定义的消息和服务的文件,增加依赖可以确保构建目标之前先生成对应的头文件</p>\n<pre><code>add_dependencies(your_program ${catkin_EXPORTED_TARGETS})\nadd_dependencies(your_library ${catkin_EXPORTED_TARGETS})\n</code></pre><h2 id=\"补充-待整理\"><a href=\"#补充-待整理\" class=\"headerlink\" title=\"补充 待整理\"></a>补充 待整理</h2><pre><code>add_compile_options(-Wall -Wextra)  # -Wall 打开编译输出警告 -Wextra打印一些额外的警告 是gcc的编译参数\n</code></pre><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/u013243710/article/details/35795841\" target=\"_blank\" rel=\"noopener\">ROS中的CMakeLists.txt</a></li>\n<li><a href=\"http://wiki.ros.org/catkin/CMakeLists.txt#Finding_Dependent_CMake_Packages\" target=\"_blank\" rel=\"noopener\">catkin CMakeLists.txt</a></li>\n<li><a href=\"https://blog.csdn.net/turboian/article/details/74604052\" target=\"_blank\" rel=\"noopener\">ROS下的CMakeList.txt编写</a></li>\n<li><a href=\"https://blog.csdn.net/haluoluo211/article/details/80559341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf\" target=\"_blank\" rel=\"noopener\">cmake教程4(find_package使用)</a></li>\n<li><a href=\"https://blog.csdn.net/cui918/article/details/53187643\" target=\"_blank\" rel=\"noopener\">GCC 警告选项 -Werror</a></li>\n</ol>\n"},{"title":"shell和下载工具","date":"2019-09-29T04:27:00.000Z","_content":"# SHELL\nshell 是一个命令解释器 而不是一门编程语言\n**空格**用来分隔命令和传递给它的参数(或用来分隔命令的两个参数)\n\n~/.bash_history 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂\n存在内存中,当你成功的注销系统后,该指令记忆才会记录到 .bash_history 当中,如果开启多个bash,则最后登出的bash会把前面的覆盖\n可以使用[job control](http://linux.vbird.org/linux_basic/0440processcontrol.php#background) \n在一个bash完成工作,主要是前景和背景\n\n    history #列出近期使用的历史命令\n    !66  #执行第 66 笔指令\n    !!   #执行上一个指令，本例中亦即 !66\n    !al  #执行最近以 al 为开头的指令(上头列出的第 67 个)\n\n# SHELL常用符号\n\techo $SHELL      \n\tenv |grep SHELL\n\tsh  #可进入shell \n\techo $?  #上个指令回传值 上条指令成功为0\n\t   \n    1. * 通用符号，可以表示任意一个字符（包括空字符）或多个字符组成的字符串  ls -l /bin/e*\n    2. ? 类似*，但是只能表示单个字符\n    3. [] 制定被显示内容的范围 ls [a-c] 显示a 、b 、c文件夹\n    4. ！排除符号 用来指定被屏蔽的部分，需要与[]一起使用  ls [!a-c]  不显示a、b、c文件夹\n    5. ; 分隔符号，多个命令分隔  ls;ls -l\n    6. ` 命令替代符，成对出现，包含的内容在shell中表示一条命令，并且会被执行，这不是单引号 echo `ls -l`  将命令的结果显示出来 \n    7. # 注释符号\n\n# 进阶\n1. 别名\n\t\t# 事实上 .bashrc 是一个shell脚本文件，在用户登录到系统自动运行，可以把想让系统启动时运行的任务写进去\n\t\talias hs='hexo clean && hexo g && hexo s'  # 注意等号前后无空格  别名相当与快捷键\n\t\talias   #查看所有命令的别名\n\t\tunalias command #取消\n\t终端上快捷键stty -a 查看,set 设置,有bash一般不用设置\n\t- Ctrl + C\t终止目前的命令\n    - Ctrl + D\t输入结束 (EOF)，例如邮件结束的时候；\n    - Ctrl + M\t就是 Enter 啦！\n    - Ctrl + S\t暂停萤幕的输出\n    - Ctrl + Q\t恢復萤幕的输出\n    - Ctrl + U\t在提示字元下，將整列命令刪除\n    - Ctrl + Z\t『暂停』目前的命令\n    使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结\n\t\t\n2. 重定向 > 输入（覆盖）  >> 输入追加  < 输出  << 立即文档(here document)\n\n\t\tls -l > test.txt  # 把ls 的结果写入test.txt中\n\t\tcat << EOF      #告诉Shell从键盘接受输入 EOF作为结束，然后查看输入内容\n\n3. 管道  \"|\"\n    管线命令仅会处理 standard output，对於 standard error output 会予以忽略\n\n\t\tls -l |grep test\n4. 网络\n    \n        nmap -sn 10.1.1.1-255   #扫描局域网\t\t\n\n# shell编程\n    \n## 运行shell脚本\n1. ./test.sh\n    \n        #! /bin/bash   # 告诉系统解释此脚本文件的shell程序\n2. /bin/bash test.sh   #这种方式不需要在第一行指定解释器　写了也没用\n\n## 变量\n- 局部变量\n- 环境变量\n- shell变量 由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量\n\n等号两边不能有空格\n\n    your_name=\"runoob.com\"   \n    echo $your_name\n    echo ${your_name}　　　# 最好加上括号\n    echo $$         # $本身也是变量 代表当前程序的pid\n    \n    myUrl=\"http://www.google.com\"\n    readonly myUrl      # 只读变量\n    \n    unset myUrl         #　删除变量\n环境变量RANDOM,产生随机数0~32767,(15位),想产生0~9的数值用declare宣告数值类型\n    \n    declare -i number=$RANDOM*10/32768 ; \n\n    \n## 字符串\n### 引号规则\n1. \"\" 阻止shell对大多数特殊字符(例如#)进行解释　但是$ ` \"　仍然保持其特殊含义\n2. '' 阻止shell对所有字符进行解释 所有字符都会原样输出\n\n      单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n3. `` 倒引号括起来一个shell　命令时，这个命令将会执行　结果作为这个表达式的值\n\n很多时候建议使用$(uname -r) 的形式获取变量或表达式的值,比``清晰,如\n    \n    cd /lib/modules/$(uname -r)/kernel       \n\n字符串变量最好加上\"\" 清晰度\n### 常用命令 \n1. 字符串拼接\n    \n        your_name=\"runoob\"\n        # 使用双引号拼接\n        greeting=\"hello, \"$your_name\" !\"\n        greeting_1=\"hello, ${your_name} !\"\n        echo $greeting  $greeting_1\n        # 使用单引号拼接\n        greeting_2='hello, '$your_name' !'      #　注意　单引号拼接　\n        greeting_3='hello, ${your_name} !'\n        echo $greeting_2  $greeting_3    \n\n2. 获取字符串长度\n\n        string=\"abcd\"\n        echo $(#string)  # 输出４\n3. 提取子字符串\n    \n        string=\"runoob is a great site\"\n        echo ${string:1:4} # 输出 unoo\n4. 查找子字符串\n\n        string=\"runoob is a great site\"\n        echo `expr index \"$string\" io`  # 输出 4  查找字符　i || o 位置\n5. 删除和替换\n    ![删除和替换](delete_replace.png)\n    ![测试和替换](var_test.png)    \n6. 其他常用命令\n\n    - 字元转换命令： tr, col, join, paste, expand\n    - 分割命令： split\n    - 参数代换： xargs        \n        \n## 数组\n    array_name=(value0 value1 value2 value3)   \n    echo ${array_name[@]}   # 获取数组中所有元素　@  \n    \n    length=$(#arrar_name[@])    # 数组元素个数\n    length=$(#arrar_name[*])    # 数组元素个数\n    length=$(#arrar_name[n])    #　单个元素长度\n    \n## 注释\n    \n    # 单行注释　　可以把一块代码定义成函数　达到多行注释\n    \n    # 多行注释\n    :<<EOF\n    注释内容...\n    注释内容...\n    注释内容...\n    EOF \n    \n    # EOF 可以使用其他符号\n    :<<!\n    注释内容...\n    注释内容...\n    注释内容...\n    !  \n## 参数传递\n     \n     $0　脚本自己的名字\n     $1　第一个参数\n     $2　第二个参数\n     ...\n     ${13} 第13个参数\n     \n     $# 参数的个数\n     $* 以一个单字符串显示所有向脚本传递的参数。\n        如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。\n     $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n        如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。\n$* 和 $@区别:\n- 相同点：都是引用所有参数。\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n        \n## 基本运算\n计算表达式的值\n\n    num=$[ $num + 1 ]\n    expr 1 + 2\n    let num=$num+1  # 用于计算整数表达式的值\n\n    val=`expr $a \\* $b`   #等号两边没有空格 乘法\n    [ $a == $b ]  # 注意有空格\n字符串运算符\n    \n    a=\"abc\"\n    [ -z $a ]   #检测字符串长度是否为0 是 true\n    [ -n \"$a\" ] #字符串长度是否为0 不为0 true\n    [ $a ]      #检测字符串是否非空 不为孔 true  \n注意:**判断非空是用了双引号**    \n**字符串比较时 == 可以用 = 替代**    \n文件测试运算符\n![文件测试](文件测试.png)   \n\n\n### test命令和[\nif语句不执行任何判断 实际接收一个程序名作为参数,依据程序返回值判断执行相应的语句\n    \n    if ./testscript 0   ## 如果返回值为0\nif通常两种方式\n\n    if test \"$password\" = \"join\"      \n    if [ \"$password\" = \"join\" ]\nwhile有时可以不用test\n        \n    while test $number -le 100\n    \n    while read n    # 每条指令都有返回值 可以利用 read 读取到键盘输入返回0 ctrl+D出入文件结束符则返回非0 通常是1\nfor语句 \n\n    for i in 1 2 3\n    for i in `seq 3`    # 1 2 3 注意是反引号                 \n1. 字符串比较\n2. 文件测试\n3. 数字比较 只能比较整数\n\n## 函数\n \t\n$? 获得上一条语句返回值 \n\n- 如果函数没有明确指定返回值 则是最后一条语句运算结果 0 为true 1 为false \n\n- 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。\n \n## 重定向\n一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n\n- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n        command 2 > file    # 错误文件重定向到file \n        command > file 2>&1 # stdout和stderr合并到file 放在>后面的&，表示重定向的目标不是一个文件，而是一个文件描述符\n        tee file   # 双重导向 往下级传输的同时输出一份到屏幕  \n### 即时脚本 here document\n基本形式\n        \n        command << delimiter\n            document\n        delimiter\n        \n例子\n\n        $ wc -l << EOF\n            欢迎来到\n            菜鸟教程\n            www.runoob.com\n        EOF \n### 禁止输出\n如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：\n    \n    command > /dev/null\n    command > /dev/null 2>&1\n    \n    \n## 文件包含\n两种方式 都不需要执行权限就可以\n\n    . filename   # 注意点号(.)和文件名中间有一空格\n    \n    source filename   # 这种方式也可以\nsource命令可以让一个脚本强行影响其父shell环境\nexport命令可以让脚本影响其子shell \n    export EDITOR='gedit'      \n\n运行一个shell脚本时会启动另一个命令解释器.\n每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。.\n这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.\n\n    export | grep ROS   #查看ROS相关的bash变量\n    \n## 变量键盘读取、阵列与宣告:read, array, declare\n1. read:读取键盘输入\n    \n        read -p \"Please keyin your name: \" -t 30 named\n- read接受变量名为参数 从标准输入接收到的信息储存 如果没有提供变量 则储存在**REPLY**\n- 用作输出一段内容后暂停\n        \n        echo \"press enter to continue\"\n        read\n2. declare / typeset:宣告变量类型\n    \n        declare [-aixr] variable\n        选项与参数：\n        -a  ：將后面名为 variable 的变数定义成为阵列 (array) 类型\n        -i  ：將后面名为 variable 的变数定义成为整数数字 (integer) 类型\n        -x  ：用法与 export 一样，就是將后面的 variable 变成环境变数；\n        -r  ：將变数设定成为 readonly 类型，该变数不可被更改內容，也不能 unset\n    注意:变量类型预设为**字符串**,1+2不会计算,除非申明为integer;bash只能进行整数运算,1/3=0                \n\n## exit trap\nexit 返回信号\ntrap 捕捉信号\n    trap 'echo \"goodbye\"; exit' EXIT    # 捕捉退出        \n\n## 常用命令\n1. cut 指定的方式分割行\n2. diff 比较文件差异\n3. sort 按照字母排序(不改变源文件)\n4. uniq 对**已经排好序**的输入删除重复的行\n5. tr   按照制定方式对字符进行替换\n6. wc   (word counts) 统计文中字节 单词 行的数量\n7. substr 从字符中提取一部分 必须搭配expr进行求值\n        \n        expr substr \"hello world\" 1 5   # hello  起始位置从1开始算\n8. seq 产生一个整数序列 \n\n# bash\n1. type cd 查询是否为内建命令 \n2. 常用组合键\n\n        [ctrl]+u/[ctrl]+k 从光标处向前删除指令串  及向后删除指令串 \n        [ctrl]+a/[ctrl]+e 让光标移动到整个指令串的最前面  或最后面  home end也可以\n          \n\n# 下载工具\n- apt\n- wget\n- Transmission   #种子下载\n\n\t\twget  -r -np -nd http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录\n\t\twget  -r -np -nd --accept=cpp http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录 扩展名为cpp的文件\n\t\twget -i filename.txt      URL地址放在filename.txt文件，自动下载所有文件\n\t\twget -c  ...  断点续传\n\n\n\n# 引用\n1. [Shell 教程](https://www.runoob.com/linux/linux-shell.html)","source":"_posts/shell和下载工具.md","raw":"---\ntitle: shell和下载工具\ndate: 2019-09-29 12:27:00\ncategories:\n- Linux\ntags:\n- shell\n- 下载工具\n\n---\n# SHELL\nshell 是一个命令解释器 而不是一门编程语言\n**空格**用来分隔命令和传递给它的参数(或用来分隔命令的两个参数)\n\n~/.bash_history 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂\n存在内存中,当你成功的注销系统后,该指令记忆才会记录到 .bash_history 当中,如果开启多个bash,则最后登出的bash会把前面的覆盖\n可以使用[job control](http://linux.vbird.org/linux_basic/0440processcontrol.php#background) \n在一个bash完成工作,主要是前景和背景\n\n    history #列出近期使用的历史命令\n    !66  #执行第 66 笔指令\n    !!   #执行上一个指令，本例中亦即 !66\n    !al  #执行最近以 al 为开头的指令(上头列出的第 67 个)\n\n# SHELL常用符号\n\techo $SHELL      \n\tenv |grep SHELL\n\tsh  #可进入shell \n\techo $?  #上个指令回传值 上条指令成功为0\n\t   \n    1. * 通用符号，可以表示任意一个字符（包括空字符）或多个字符组成的字符串  ls -l /bin/e*\n    2. ? 类似*，但是只能表示单个字符\n    3. [] 制定被显示内容的范围 ls [a-c] 显示a 、b 、c文件夹\n    4. ！排除符号 用来指定被屏蔽的部分，需要与[]一起使用  ls [!a-c]  不显示a、b、c文件夹\n    5. ; 分隔符号，多个命令分隔  ls;ls -l\n    6. ` 命令替代符，成对出现，包含的内容在shell中表示一条命令，并且会被执行，这不是单引号 echo `ls -l`  将命令的结果显示出来 \n    7. # 注释符号\n\n# 进阶\n1. 别名\n\t\t# 事实上 .bashrc 是一个shell脚本文件，在用户登录到系统自动运行，可以把想让系统启动时运行的任务写进去\n\t\talias hs='hexo clean && hexo g && hexo s'  # 注意等号前后无空格  别名相当与快捷键\n\t\talias   #查看所有命令的别名\n\t\tunalias command #取消\n\t终端上快捷键stty -a 查看,set 设置,有bash一般不用设置\n\t- Ctrl + C\t终止目前的命令\n    - Ctrl + D\t输入结束 (EOF)，例如邮件结束的时候；\n    - Ctrl + M\t就是 Enter 啦！\n    - Ctrl + S\t暂停萤幕的输出\n    - Ctrl + Q\t恢復萤幕的输出\n    - Ctrl + U\t在提示字元下，將整列命令刪除\n    - Ctrl + Z\t『暂停』目前的命令\n    使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结\n\t\t\n2. 重定向 > 输入（覆盖）  >> 输入追加  < 输出  << 立即文档(here document)\n\n\t\tls -l > test.txt  # 把ls 的结果写入test.txt中\n\t\tcat << EOF      #告诉Shell从键盘接受输入 EOF作为结束，然后查看输入内容\n\n3. 管道  \"|\"\n    管线命令仅会处理 standard output，对於 standard error output 会予以忽略\n\n\t\tls -l |grep test\n4. 网络\n    \n        nmap -sn 10.1.1.1-255   #扫描局域网\t\t\n\n# shell编程\n    \n## 运行shell脚本\n1. ./test.sh\n    \n        #! /bin/bash   # 告诉系统解释此脚本文件的shell程序\n2. /bin/bash test.sh   #这种方式不需要在第一行指定解释器　写了也没用\n\n## 变量\n- 局部变量\n- 环境变量\n- shell变量 由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量\n\n等号两边不能有空格\n\n    your_name=\"runoob.com\"   \n    echo $your_name\n    echo ${your_name}　　　# 最好加上括号\n    echo $$         # $本身也是变量 代表当前程序的pid\n    \n    myUrl=\"http://www.google.com\"\n    readonly myUrl      # 只读变量\n    \n    unset myUrl         #　删除变量\n环境变量RANDOM,产生随机数0~32767,(15位),想产生0~9的数值用declare宣告数值类型\n    \n    declare -i number=$RANDOM*10/32768 ; \n\n    \n## 字符串\n### 引号规则\n1. \"\" 阻止shell对大多数特殊字符(例如#)进行解释　但是$ ` \"　仍然保持其特殊含义\n2. '' 阻止shell对所有字符进行解释 所有字符都会原样输出\n\n      单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n3. `` 倒引号括起来一个shell　命令时，这个命令将会执行　结果作为这个表达式的值\n\n很多时候建议使用$(uname -r) 的形式获取变量或表达式的值,比``清晰,如\n    \n    cd /lib/modules/$(uname -r)/kernel       \n\n字符串变量最好加上\"\" 清晰度\n### 常用命令 \n1. 字符串拼接\n    \n        your_name=\"runoob\"\n        # 使用双引号拼接\n        greeting=\"hello, \"$your_name\" !\"\n        greeting_1=\"hello, ${your_name} !\"\n        echo $greeting  $greeting_1\n        # 使用单引号拼接\n        greeting_2='hello, '$your_name' !'      #　注意　单引号拼接　\n        greeting_3='hello, ${your_name} !'\n        echo $greeting_2  $greeting_3    \n\n2. 获取字符串长度\n\n        string=\"abcd\"\n        echo $(#string)  # 输出４\n3. 提取子字符串\n    \n        string=\"runoob is a great site\"\n        echo ${string:1:4} # 输出 unoo\n4. 查找子字符串\n\n        string=\"runoob is a great site\"\n        echo `expr index \"$string\" io`  # 输出 4  查找字符　i || o 位置\n5. 删除和替换\n    ![删除和替换](delete_replace.png)\n    ![测试和替换](var_test.png)    \n6. 其他常用命令\n\n    - 字元转换命令： tr, col, join, paste, expand\n    - 分割命令： split\n    - 参数代换： xargs        \n        \n## 数组\n    array_name=(value0 value1 value2 value3)   \n    echo ${array_name[@]}   # 获取数组中所有元素　@  \n    \n    length=$(#arrar_name[@])    # 数组元素个数\n    length=$(#arrar_name[*])    # 数组元素个数\n    length=$(#arrar_name[n])    #　单个元素长度\n    \n## 注释\n    \n    # 单行注释　　可以把一块代码定义成函数　达到多行注释\n    \n    # 多行注释\n    :<<EOF\n    注释内容...\n    注释内容...\n    注释内容...\n    EOF \n    \n    # EOF 可以使用其他符号\n    :<<!\n    注释内容...\n    注释内容...\n    注释内容...\n    !  \n## 参数传递\n     \n     $0　脚本自己的名字\n     $1　第一个参数\n     $2　第二个参数\n     ...\n     ${13} 第13个参数\n     \n     $# 参数的个数\n     $* 以一个单字符串显示所有向脚本传递的参数。\n        如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。\n     $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n        如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。\n$* 和 $@区别:\n- 相同点：都是引用所有参数。\n- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n        \n## 基本运算\n计算表达式的值\n\n    num=$[ $num + 1 ]\n    expr 1 + 2\n    let num=$num+1  # 用于计算整数表达式的值\n\n    val=`expr $a \\* $b`   #等号两边没有空格 乘法\n    [ $a == $b ]  # 注意有空格\n字符串运算符\n    \n    a=\"abc\"\n    [ -z $a ]   #检测字符串长度是否为0 是 true\n    [ -n \"$a\" ] #字符串长度是否为0 不为0 true\n    [ $a ]      #检测字符串是否非空 不为孔 true  \n注意:**判断非空是用了双引号**    \n**字符串比较时 == 可以用 = 替代**    \n文件测试运算符\n![文件测试](文件测试.png)   \n\n\n### test命令和[\nif语句不执行任何判断 实际接收一个程序名作为参数,依据程序返回值判断执行相应的语句\n    \n    if ./testscript 0   ## 如果返回值为0\nif通常两种方式\n\n    if test \"$password\" = \"join\"      \n    if [ \"$password\" = \"join\" ]\nwhile有时可以不用test\n        \n    while test $number -le 100\n    \n    while read n    # 每条指令都有返回值 可以利用 read 读取到键盘输入返回0 ctrl+D出入文件结束符则返回非0 通常是1\nfor语句 \n\n    for i in 1 2 3\n    for i in `seq 3`    # 1 2 3 注意是反引号                 \n1. 字符串比较\n2. 文件测试\n3. 数字比较 只能比较整数\n\n## 函数\n \t\n$? 获得上一条语句返回值 \n\n- 如果函数没有明确指定返回值 则是最后一条语句运算结果 0 为true 1 为false \n\n- 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。\n \n## 重定向\n一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：\n\n- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。\n- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。\n- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。\n\n        command 2 > file    # 错误文件重定向到file \n        command > file 2>&1 # stdout和stderr合并到file 放在>后面的&，表示重定向的目标不是一个文件，而是一个文件描述符\n        tee file   # 双重导向 往下级传输的同时输出一份到屏幕  \n### 即时脚本 here document\n基本形式\n        \n        command << delimiter\n            document\n        delimiter\n        \n例子\n\n        $ wc -l << EOF\n            欢迎来到\n            菜鸟教程\n            www.runoob.com\n        EOF \n### 禁止输出\n如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：\n    \n    command > /dev/null\n    command > /dev/null 2>&1\n    \n    \n## 文件包含\n两种方式 都不需要执行权限就可以\n\n    . filename   # 注意点号(.)和文件名中间有一空格\n    \n    source filename   # 这种方式也可以\nsource命令可以让一个脚本强行影响其父shell环境\nexport命令可以让脚本影响其子shell \n    export EDITOR='gedit'      \n\n运行一个shell脚本时会启动另一个命令解释器.\n每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。.\n这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.\n\n    export | grep ROS   #查看ROS相关的bash变量\n    \n## 变量键盘读取、阵列与宣告:read, array, declare\n1. read:读取键盘输入\n    \n        read -p \"Please keyin your name: \" -t 30 named\n- read接受变量名为参数 从标准输入接收到的信息储存 如果没有提供变量 则储存在**REPLY**\n- 用作输出一段内容后暂停\n        \n        echo \"press enter to continue\"\n        read\n2. declare / typeset:宣告变量类型\n    \n        declare [-aixr] variable\n        选项与参数：\n        -a  ：將后面名为 variable 的变数定义成为阵列 (array) 类型\n        -i  ：將后面名为 variable 的变数定义成为整数数字 (integer) 类型\n        -x  ：用法与 export 一样，就是將后面的 variable 变成环境变数；\n        -r  ：將变数设定成为 readonly 类型，该变数不可被更改內容，也不能 unset\n    注意:变量类型预设为**字符串**,1+2不会计算,除非申明为integer;bash只能进行整数运算,1/3=0                \n\n## exit trap\nexit 返回信号\ntrap 捕捉信号\n    trap 'echo \"goodbye\"; exit' EXIT    # 捕捉退出        \n\n## 常用命令\n1. cut 指定的方式分割行\n2. diff 比较文件差异\n3. sort 按照字母排序(不改变源文件)\n4. uniq 对**已经排好序**的输入删除重复的行\n5. tr   按照制定方式对字符进行替换\n6. wc   (word counts) 统计文中字节 单词 行的数量\n7. substr 从字符中提取一部分 必须搭配expr进行求值\n        \n        expr substr \"hello world\" 1 5   # hello  起始位置从1开始算\n8. seq 产生一个整数序列 \n\n# bash\n1. type cd 查询是否为内建命令 \n2. 常用组合键\n\n        [ctrl]+u/[ctrl]+k 从光标处向前删除指令串  及向后删除指令串 \n        [ctrl]+a/[ctrl]+e 让光标移动到整个指令串的最前面  或最后面  home end也可以\n          \n\n# 下载工具\n- apt\n- wget\n- Transmission   #种子下载\n\n\t\twget  -r -np -nd http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录\n\t\twget  -r -np -nd --accept=cpp http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录 扩展名为cpp的文件\n\t\twget -i filename.txt      URL地址放在filename.txt文件，自动下载所有文件\n\t\twget -c  ...  断点续传\n\n\n\n# 引用\n1. [Shell 教程](https://www.runoob.com/linux/linux-shell.html)","slug":"shell和下载工具","published":1,"updated":"2020-09-23T14:42:00.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjh006xmxka01n2h5zb","content":"<h1 id=\"SHELL\"><a href=\"#SHELL\" class=\"headerlink\" title=\"SHELL\"></a>SHELL</h1><p>shell 是一个命令解释器 而不是一门编程语言<br><strong>空格</strong>用来分隔命令和传递给它的参数(或用来分隔命令的两个参数)</p>\n<p>~/.bash_history 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂<br>存在内存中,当你成功的注销系统后,该指令记忆才会记录到 .bash_history 当中,如果开启多个bash,则最后登出的bash会把前面的覆盖<br>可以使用<a href=\"http://linux.vbird.org/linux_basic/0440processcontrol.php#background\" target=\"_blank\" rel=\"noopener\">job control</a><br>在一个bash完成工作,主要是前景和背景</p>\n<pre><code>history #列出近期使用的历史命令\n!66  #执行第 66 笔指令\n!!   #执行上一个指令，本例中亦即 !66\n!al  #执行最近以 al 为开头的指令(上头列出的第 67 个)\n</code></pre><h1 id=\"SHELL常用符号\"><a href=\"#SHELL常用符号\" class=\"headerlink\" title=\"SHELL常用符号\"></a>SHELL常用符号</h1><pre><code>echo $SHELL      \nenv |grep SHELL\nsh  #可进入shell \necho $?  #上个指令回传值 上条指令成功为0\n\n1. * 通用符号，可以表示任意一个字符（包括空字符）或多个字符组成的字符串  ls -l /bin/e*\n2. ? 类似*，但是只能表示单个字符\n3. [] 制定被显示内容的范围 ls [a-c] 显示a 、b 、c文件夹\n4. ！排除符号 用来指定被屏蔽的部分，需要与[]一起使用  ls [!a-c]  不显示a、b、c文件夹\n5. ; 分隔符号，多个命令分隔  ls;ls -l\n6. ` 命令替代符，成对出现，包含的内容在shell中表示一条命令，并且会被执行，这不是单引号 echo `ls -l`  将命令的结果显示出来 \n7. # 注释符号\n</code></pre><h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><ol>\n<li><p>别名</p>\n<pre><code> # 事实上 .bashrc 是一个shell脚本文件，在用户登录到系统自动运行，可以把想让系统启动时运行的任务写进去\n alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  # 注意等号前后无空格  别名相当与快捷键\n alias   #查看所有命令的别名\n unalias command #取消\n</code></pre><p> 终端上快捷键stty -a 查看,set 设置,有bash一般不用设置</p>\n<ul>\n<li>Ctrl + C    终止目前的命令</li>\n<li>Ctrl + D    输入结束 (EOF)，例如邮件结束的时候；</li>\n<li>Ctrl + M    就是 Enter 啦！</li>\n<li>Ctrl + S    暂停萤幕的输出</li>\n<li>Ctrl + Q    恢復萤幕的输出</li>\n<li>Ctrl + U    在提示字元下，將整列命令刪除</li>\n<li>Ctrl + Z    『暂停』目前的命令<br>使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结</li>\n</ul>\n</li>\n<li><p>重定向 &gt; 输入（覆盖）  &gt;&gt; 输入追加  &lt; 输出  &lt;&lt; 立即文档(here document)</p>\n<pre><code> ls -l &gt; test.txt  # 把ls 的结果写入test.txt中\n cat &lt;&lt; EOF      #告诉Shell从键盘接受输入 EOF作为结束，然后查看输入内容\n</code></pre></li>\n<li><p>管道  “|”<br> 管线命令仅会处理 standard output，对於 standard error output 会予以忽略</p>\n<pre><code> ls -l |grep test\n</code></pre></li>\n<li><p>网络</p>\n<pre><code> nmap -sn 10.1.1.1-255   #扫描局域网        \n</code></pre></li>\n</ol>\n<h1 id=\"shell编程\"><a href=\"#shell编程\" class=\"headerlink\" title=\"shell编程\"></a>shell编程</h1><h2 id=\"运行shell脚本\"><a href=\"#运行shell脚本\" class=\"headerlink\" title=\"运行shell脚本\"></a>运行shell脚本</h2><ol>\n<li><p>./test.sh</p>\n<pre><code> #! /bin/bash   # 告诉系统解释此脚本文件的shell程序\n</code></pre></li>\n<li>/bin/bash test.sh   #这种方式不需要在第一行指定解释器　写了也没用</li>\n</ol>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell变量 由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量</li>\n</ul>\n<p>等号两边不能有空格</p>\n<pre><code>your_name=&quot;runoob.com&quot;   \necho $your_name\necho ${your_name}　　　# 最好加上括号\necho $$         # $本身也是变量 代表当前程序的pid\n\nmyUrl=&quot;http://www.google.com&quot;\nreadonly myUrl      # 只读变量\n\nunset myUrl         #　删除变量\n</code></pre><p>环境变量RANDOM,产生随机数0~32767,(15位),想产生0~9的数值用declare宣告数值类型</p>\n<pre><code>declare -i number=$RANDOM*10/32768 ; \n</code></pre><h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"引号规则\"><a href=\"#引号规则\" class=\"headerlink\" title=\"引号规则\"></a>引号规则</h3><ol>\n<li>“” 阻止shell对大多数特殊字符(例如#)进行解释　但是$ ` “　仍然保持其特殊含义</li>\n<li><p>‘’ 阻止shell对所有字符进行解释 所有字符都会原样输出</p>\n<p>   单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>\n</li>\n<li>`` 倒引号括起来一个shell　命令时，这个命令将会执行　结果作为这个表达式的值</li>\n</ol>\n<p>很多时候建议使用$(uname -r) 的形式获取变量或表达式的值,比``清晰,如</p>\n<pre><code>cd /lib/modules/$(uname -r)/kernel       \n</code></pre><p>字符串变量最好加上”” 清晰度</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ol>\n<li><p>字符串拼接</p>\n<pre><code> your_name=&quot;runoob&quot;\n # 使用双引号拼接\n greeting=&quot;hello, &quot;$your_name&quot; !&quot;\n greeting_1=&quot;hello, ${your_name} !&quot;\n echo $greeting  $greeting_1\n # 使用单引号拼接\n greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;      #　注意　单引号拼接　\n greeting_3=&#39;hello, ${your_name} !&#39;\n echo $greeting_2  $greeting_3    \n</code></pre></li>\n<li><p>获取字符串长度</p>\n<pre><code> string=&quot;abcd&quot;\n echo $(#string)  # 输出４\n</code></pre></li>\n<li><p>提取子字符串</p>\n<pre><code> string=&quot;runoob is a great site&quot;\n echo ${string:1:4} # 输出 unoo\n</code></pre></li>\n<li><p>查找子字符串</p>\n<pre><code> string=&quot;runoob is a great site&quot;\n echo `expr index &quot;$string&quot; io`  # 输出 4  查找字符　i || o 位置\n</code></pre></li>\n<li>删除和替换<br> <img src=\"/2019/09/29/shell和下载工具/delete_replace.png\" alt=\"删除和替换\"><br> <img src=\"/2019/09/29/shell和下载工具/var_test.png\" alt=\"测试和替换\">    </li>\n<li><p>其他常用命令</p>\n<ul>\n<li>字元转换命令： tr, col, join, paste, expand</li>\n<li>分割命令： split</li>\n<li>参数代换： xargs        </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><pre><code>array_name=(value0 value1 value2 value3)   \necho ${array_name[@]}   # 获取数组中所有元素　@  \n\nlength=$(#arrar_name[@])    # 数组元素个数\nlength=$(#arrar_name[*])    # 数组元素个数\nlength=$(#arrar_name[n])    #　单个元素长度\n</code></pre><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code># 单行注释　　可以把一块代码定义成函数　达到多行注释\n\n# 多行注释\n:&lt;&lt;EOF\n注释内容...\n注释内容...\n注释内容...\nEOF \n\n# EOF 可以使用其他符号\n:&lt;&lt;!\n注释内容...\n注释内容...\n注释内容...\n!  \n</code></pre><h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><pre><code> $0　脚本自己的名字\n $1　第一个参数\n $2　第二个参数\n ...\n ${13} 第13个参数\n\n $# 参数的个数\n $* 以一个单字符串显示所有向脚本传递的参数。\n    如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。\n $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n    如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。\n</code></pre><p>$* 和 $@区别:</p>\n<ul>\n<li>相同点：都是引用所有参数。</li>\n<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>\n</ul>\n<h2 id=\"基本运算\"><a href=\"#基本运算\" class=\"headerlink\" title=\"基本运算\"></a>基本运算</h2><p>计算表达式的值</p>\n<pre><code>num=$[ $num + 1 ]\nexpr 1 + 2\nlet num=$num+1  # 用于计算整数表达式的值\n\nval=`expr $a \\* $b`   #等号两边没有空格 乘法\n[ $a == $b ]  # 注意有空格\n</code></pre><p>字符串运算符</p>\n<pre><code>a=&quot;abc&quot;\n[ -z $a ]   #检测字符串长度是否为0 是 true\n[ -n &quot;$a&quot; ] #字符串长度是否为0 不为0 true\n[ $a ]      #检测字符串是否非空 不为孔 true  \n</code></pre><p>注意:<strong>判断非空是用了双引号</strong><br><strong>字符串比较时 == 可以用 = 替代</strong><br>文件测试运算符<br><img src=\"/2019/09/29/shell和下载工具/文件测试.png\" alt=\"文件测试\">   </p>\n<h3 id=\"test命令和\"><a href=\"#test命令和\" class=\"headerlink\" title=\"test命令和[\"></a>test命令和[</h3><p>if语句不执行任何判断 实际接收一个程序名作为参数,依据程序返回值判断执行相应的语句</p>\n<pre><code>if ./testscript 0   ## 如果返回值为0\n</code></pre><p>if通常两种方式</p>\n<pre><code>if test &quot;$password&quot; = &quot;join&quot;      \nif [ &quot;$password&quot; = &quot;join&quot; ]\n</code></pre><p>while有时可以不用test</p>\n<pre><code>while test $number -le 100\n\nwhile read n    # 每条指令都有返回值 可以利用 read 读取到键盘输入返回0 ctrl+D出入文件结束符则返回非0 通常是1\n</code></pre><p>for语句 </p>\n<pre><code>for i in 1 2 3\nfor i in `seq 3`    # 1 2 3 注意是反引号                 \n</code></pre><ol>\n<li>字符串比较</li>\n<li>文件测试</li>\n<li>数字比较 只能比较整数</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>$? 获得上一条语句返回值 </p>\n<ul>\n<li><p>如果函数没有明确指定返回值 则是最后一条语句运算结果 0 为true 1 为false </p>\n</li>\n<li><p>仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</p>\n</li>\n</ul>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>\n<ul>\n<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>\n<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>\n<li><p>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>\n<pre><code>  command 2 &gt; file    # 错误文件重定向到file \n  command &gt; file 2&gt;&amp;1 # stdout和stderr合并到file 放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符\n  tee file   # 双重导向 往下级传输的同时输出一份到屏幕  \n</code></pre><h3 id=\"即时脚本-here-document\"><a href=\"#即时脚本-here-document\" class=\"headerlink\" title=\"即时脚本 here document\"></a>即时脚本 here document</h3><p>基本形式</p>\n<pre><code>  command &lt;&lt; delimiter\n      document\n  delimiter\n</code></pre></li>\n</ul>\n<p>例子</p>\n<pre><code>    $ wc -l &lt;&lt; EOF\n        欢迎来到\n        菜鸟教程\n        www.runoob.com\n    EOF \n</code></pre><h3 id=\"禁止输出\"><a href=\"#禁止输出\" class=\"headerlink\" title=\"禁止输出\"></a>禁止输出</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>\n<pre><code>command &gt; /dev/null\ncommand &gt; /dev/null 2&gt;&amp;1\n</code></pre><h2 id=\"文件包含\"><a href=\"#文件包含\" class=\"headerlink\" title=\"文件包含\"></a>文件包含</h2><p>两种方式 都不需要执行权限就可以</p>\n<pre><code>. filename   # 注意点号(.)和文件名中间有一空格\n\nsource filename   # 这种方式也可以\n</code></pre><p>source命令可以让一个脚本强行影响其父shell环境<br>export命令可以让脚本影响其子shell<br>    export EDITOR=’gedit’      </p>\n<p>运行一个shell脚本时会启动另一个命令解释器.<br>每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。.<br>这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.</p>\n<pre><code>export | grep ROS   #查看ROS相关的bash变量\n</code></pre><h2 id=\"变量键盘读取、阵列与宣告-read-array-declare\"><a href=\"#变量键盘读取、阵列与宣告-read-array-declare\" class=\"headerlink\" title=\"变量键盘读取、阵列与宣告:read, array, declare\"></a>变量键盘读取、阵列与宣告:read, array, declare</h2><ol>\n<li><p>read:读取键盘输入</p>\n<pre><code> read -p &quot;Please keyin your name: &quot; -t 30 named\n</code></pre></li>\n</ol>\n<ul>\n<li>read接受变量名为参数 从标准输入接收到的信息储存 如果没有提供变量 则储存在<strong>REPLY</strong></li>\n<li><p>用作输出一段内容后暂停</p>\n<pre><code>  echo &quot;press enter to continue&quot;\n  read\n</code></pre></li>\n</ul>\n<ol>\n<li><p>declare / typeset:宣告变量类型</p>\n<pre><code> declare [-aixr] variable\n 选项与参数：\n -a  ：將后面名为 variable 的变数定义成为阵列 (array) 类型\n -i  ：將后面名为 variable 的变数定义成为整数数字 (integer) 类型\n -x  ：用法与 export 一样，就是將后面的 variable 变成环境变数；\n -r  ：將变数设定成为 readonly 类型，该变数不可被更改內容，也不能 unset\n</code></pre><p> 注意:变量类型预设为<strong>字符串</strong>,1+2不会计算,除非申明为integer;bash只能进行整数运算,1/3=0                </p>\n</li>\n</ol>\n<h2 id=\"exit-trap\"><a href=\"#exit-trap\" class=\"headerlink\" title=\"exit trap\"></a>exit trap</h2><p>exit 返回信号<br>trap 捕捉信号<br>    trap ‘echo “goodbye”; exit’ EXIT    # 捕捉退出        </p>\n<h2 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ol>\n<li>cut 指定的方式分割行</li>\n<li>diff 比较文件差异</li>\n<li>sort 按照字母排序(不改变源文件)</li>\n<li>uniq 对<strong>已经排好序</strong>的输入删除重复的行</li>\n<li>tr   按照制定方式对字符进行替换</li>\n<li>wc   (word counts) 统计文中字节 单词 行的数量</li>\n<li><p>substr 从字符中提取一部分 必须搭配expr进行求值</p>\n<pre><code> expr substr &quot;hello world&quot; 1 5   # hello  起始位置从1开始算\n</code></pre></li>\n<li>seq 产生一个整数序列 </li>\n</ol>\n<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><ol>\n<li>type cd 查询是否为内建命令 </li>\n<li><p>常用组合键</p>\n<pre><code> [ctrl]+u/[ctrl]+k 从光标处向前删除指令串  及向后删除指令串 \n [ctrl]+a/[ctrl]+e 让光标移动到整个指令串的最前面  或最后面  home end也可以\n</code></pre></li>\n</ol>\n<h1 id=\"下载工具\"><a href=\"#下载工具\" class=\"headerlink\" title=\"下载工具\"></a>下载工具</h1><ul>\n<li>apt</li>\n<li>wget</li>\n<li><p>Transmission   #种子下载</p>\n<pre><code>  wget  -r -np -nd http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录\n  wget  -r -np -nd --accept=cpp http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录 扩展名为cpp的文件\n  wget -i filename.txt      URL地址放在filename.txt文件，自动下载所有文件\n  wget -c  ...  断点续传\n</code></pre></li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"noopener\">Shell 教程</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SHELL\"><a href=\"#SHELL\" class=\"headerlink\" title=\"SHELL\"></a>SHELL</h1><p>shell 是一个命令解释器 而不是一门编程语言<br><strong>空格</strong>用来分隔命令和传递给它的参数(或用来分隔命令的两个参数)</p>\n<p>~/.bash_history 记录的是前一次登入以前所执行过的指令, 而至于这一次登入所执行的指令都被暂<br>存在内存中,当你成功的注销系统后,该指令记忆才会记录到 .bash_history 当中,如果开启多个bash,则最后登出的bash会把前面的覆盖<br>可以使用<a href=\"http://linux.vbird.org/linux_basic/0440processcontrol.php#background\" target=\"_blank\" rel=\"noopener\">job control</a><br>在一个bash完成工作,主要是前景和背景</p>\n<pre><code>history #列出近期使用的历史命令\n!66  #执行第 66 笔指令\n!!   #执行上一个指令，本例中亦即 !66\n!al  #执行最近以 al 为开头的指令(上头列出的第 67 个)\n</code></pre><h1 id=\"SHELL常用符号\"><a href=\"#SHELL常用符号\" class=\"headerlink\" title=\"SHELL常用符号\"></a>SHELL常用符号</h1><pre><code>echo $SHELL      \nenv |grep SHELL\nsh  #可进入shell \necho $?  #上个指令回传值 上条指令成功为0\n\n1. * 通用符号，可以表示任意一个字符（包括空字符）或多个字符组成的字符串  ls -l /bin/e*\n2. ? 类似*，但是只能表示单个字符\n3. [] 制定被显示内容的范围 ls [a-c] 显示a 、b 、c文件夹\n4. ！排除符号 用来指定被屏蔽的部分，需要与[]一起使用  ls [!a-c]  不显示a、b、c文件夹\n5. ; 分隔符号，多个命令分隔  ls;ls -l\n6. ` 命令替代符，成对出现，包含的内容在shell中表示一条命令，并且会被执行，这不是单引号 echo `ls -l`  将命令的结果显示出来 \n7. # 注释符号\n</code></pre><h1 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h1><ol>\n<li><p>别名</p>\n<pre><code> # 事实上 .bashrc 是一个shell脚本文件，在用户登录到系统自动运行，可以把想让系统启动时运行的任务写进去\n alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  # 注意等号前后无空格  别名相当与快捷键\n alias   #查看所有命令的别名\n unalias command #取消\n</code></pre><p> 终端上快捷键stty -a 查看,set 设置,有bash一般不用设置</p>\n<ul>\n<li>Ctrl + C    终止目前的命令</li>\n<li>Ctrl + D    输入结束 (EOF)，例如邮件结束的时候；</li>\n<li>Ctrl + M    就是 Enter 啦！</li>\n<li>Ctrl + S    暂停萤幕的输出</li>\n<li>Ctrl + Q    恢復萤幕的输出</li>\n<li>Ctrl + U    在提示字元下，將整列命令刪除</li>\n<li>Ctrl + Z    『暂停』目前的命令<br>使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结</li>\n</ul>\n</li>\n<li><p>重定向 &gt; 输入（覆盖）  &gt;&gt; 输入追加  &lt; 输出  &lt;&lt; 立即文档(here document)</p>\n<pre><code> ls -l &gt; test.txt  # 把ls 的结果写入test.txt中\n cat &lt;&lt; EOF      #告诉Shell从键盘接受输入 EOF作为结束，然后查看输入内容\n</code></pre></li>\n<li><p>管道  “|”<br> 管线命令仅会处理 standard output，对於 standard error output 会予以忽略</p>\n<pre><code> ls -l |grep test\n</code></pre></li>\n<li><p>网络</p>\n<pre><code> nmap -sn 10.1.1.1-255   #扫描局域网        \n</code></pre></li>\n</ol>\n<h1 id=\"shell编程\"><a href=\"#shell编程\" class=\"headerlink\" title=\"shell编程\"></a>shell编程</h1><h2 id=\"运行shell脚本\"><a href=\"#运行shell脚本\" class=\"headerlink\" title=\"运行shell脚本\"></a>运行shell脚本</h2><ol>\n<li><p>./test.sh</p>\n<pre><code> #! /bin/bash   # 告诉系统解释此脚本文件的shell程序\n</code></pre></li>\n<li>/bin/bash test.sh   #这种方式不需要在第一行指定解释器　写了也没用</li>\n</ol>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell变量 由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量</li>\n</ul>\n<p>等号两边不能有空格</p>\n<pre><code>your_name=&quot;runoob.com&quot;   \necho $your_name\necho ${your_name}　　　# 最好加上括号\necho $$         # $本身也是变量 代表当前程序的pid\n\nmyUrl=&quot;http://www.google.com&quot;\nreadonly myUrl      # 只读变量\n\nunset myUrl         #　删除变量\n</code></pre><p>环境变量RANDOM,产生随机数0~32767,(15位),想产生0~9的数值用declare宣告数值类型</p>\n<pre><code>declare -i number=$RANDOM*10/32768 ; \n</code></pre><h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"引号规则\"><a href=\"#引号规则\" class=\"headerlink\" title=\"引号规则\"></a>引号规则</h3><ol>\n<li>“” 阻止shell对大多数特殊字符(例如#)进行解释　但是$ ` “　仍然保持其特殊含义</li>\n<li><p>‘’ 阻止shell对所有字符进行解释 所有字符都会原样输出</p>\n<p>   单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>\n</li>\n<li>`` 倒引号括起来一个shell　命令时，这个命令将会执行　结果作为这个表达式的值</li>\n</ol>\n<p>很多时候建议使用$(uname -r) 的形式获取变量或表达式的值,比``清晰,如</p>\n<pre><code>cd /lib/modules/$(uname -r)/kernel       \n</code></pre><p>字符串变量最好加上”” 清晰度</p>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ol>\n<li><p>字符串拼接</p>\n<pre><code> your_name=&quot;runoob&quot;\n # 使用双引号拼接\n greeting=&quot;hello, &quot;$your_name&quot; !&quot;\n greeting_1=&quot;hello, ${your_name} !&quot;\n echo $greeting  $greeting_1\n # 使用单引号拼接\n greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;      #　注意　单引号拼接　\n greeting_3=&#39;hello, ${your_name} !&#39;\n echo $greeting_2  $greeting_3    \n</code></pre></li>\n<li><p>获取字符串长度</p>\n<pre><code> string=&quot;abcd&quot;\n echo $(#string)  # 输出４\n</code></pre></li>\n<li><p>提取子字符串</p>\n<pre><code> string=&quot;runoob is a great site&quot;\n echo ${string:1:4} # 输出 unoo\n</code></pre></li>\n<li><p>查找子字符串</p>\n<pre><code> string=&quot;runoob is a great site&quot;\n echo `expr index &quot;$string&quot; io`  # 输出 4  查找字符　i || o 位置\n</code></pre></li>\n<li>删除和替换<br> <img src=\"/2019/09/29/shell和下载工具/delete_replace.png\" alt=\"删除和替换\"><br> <img src=\"/2019/09/29/shell和下载工具/var_test.png\" alt=\"测试和替换\">    </li>\n<li><p>其他常用命令</p>\n<ul>\n<li>字元转换命令： tr, col, join, paste, expand</li>\n<li>分割命令： split</li>\n<li>参数代换： xargs        </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><pre><code>array_name=(value0 value1 value2 value3)   \necho ${array_name[@]}   # 获取数组中所有元素　@  \n\nlength=$(#arrar_name[@])    # 数组元素个数\nlength=$(#arrar_name[*])    # 数组元素个数\nlength=$(#arrar_name[n])    #　单个元素长度\n</code></pre><h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><pre><code># 单行注释　　可以把一块代码定义成函数　达到多行注释\n\n# 多行注释\n:&lt;&lt;EOF\n注释内容...\n注释内容...\n注释内容...\nEOF \n\n# EOF 可以使用其他符号\n:&lt;&lt;!\n注释内容...\n注释内容...\n注释内容...\n!  \n</code></pre><h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><pre><code> $0　脚本自己的名字\n $1　第一个参数\n $2　第二个参数\n ...\n ${13} 第13个参数\n\n $# 参数的个数\n $* 以一个单字符串显示所有向脚本传递的参数。\n    如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。\n $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n    如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。\n</code></pre><p>$* 和 $@区别:</p>\n<ul>\n<li>相同点：都是引用所有参数。</li>\n<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>\n</ul>\n<h2 id=\"基本运算\"><a href=\"#基本运算\" class=\"headerlink\" title=\"基本运算\"></a>基本运算</h2><p>计算表达式的值</p>\n<pre><code>num=$[ $num + 1 ]\nexpr 1 + 2\nlet num=$num+1  # 用于计算整数表达式的值\n\nval=`expr $a \\* $b`   #等号两边没有空格 乘法\n[ $a == $b ]  # 注意有空格\n</code></pre><p>字符串运算符</p>\n<pre><code>a=&quot;abc&quot;\n[ -z $a ]   #检测字符串长度是否为0 是 true\n[ -n &quot;$a&quot; ] #字符串长度是否为0 不为0 true\n[ $a ]      #检测字符串是否非空 不为孔 true  \n</code></pre><p>注意:<strong>判断非空是用了双引号</strong><br><strong>字符串比较时 == 可以用 = 替代</strong><br>文件测试运算符<br><img src=\"/2019/09/29/shell和下载工具/文件测试.png\" alt=\"文件测试\">   </p>\n<h3 id=\"test命令和\"><a href=\"#test命令和\" class=\"headerlink\" title=\"test命令和[\"></a>test命令和[</h3><p>if语句不执行任何判断 实际接收一个程序名作为参数,依据程序返回值判断执行相应的语句</p>\n<pre><code>if ./testscript 0   ## 如果返回值为0\n</code></pre><p>if通常两种方式</p>\n<pre><code>if test &quot;$password&quot; = &quot;join&quot;      \nif [ &quot;$password&quot; = &quot;join&quot; ]\n</code></pre><p>while有时可以不用test</p>\n<pre><code>while test $number -le 100\n\nwhile read n    # 每条指令都有返回值 可以利用 read 读取到键盘输入返回0 ctrl+D出入文件结束符则返回非0 通常是1\n</code></pre><p>for语句 </p>\n<pre><code>for i in 1 2 3\nfor i in `seq 3`    # 1 2 3 注意是反引号                 \n</code></pre><ol>\n<li>字符串比较</li>\n<li>文件测试</li>\n<li>数字比较 只能比较整数</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>$? 获得上一条语句返回值 </p>\n<ul>\n<li><p>如果函数没有明确指定返回值 则是最后一条语句运算结果 0 为true 1 为false </p>\n</li>\n<li><p>仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 $? 获得。</p>\n</li>\n</ul>\n<h2 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>\n<ul>\n<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>\n<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>\n<li><p>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>\n<pre><code>  command 2 &gt; file    # 错误文件重定向到file \n  command &gt; file 2&gt;&amp;1 # stdout和stderr合并到file 放在&gt;后面的&amp;，表示重定向的目标不是一个文件，而是一个文件描述符\n  tee file   # 双重导向 往下级传输的同时输出一份到屏幕  \n</code></pre><h3 id=\"即时脚本-here-document\"><a href=\"#即时脚本-here-document\" class=\"headerlink\" title=\"即时脚本 here document\"></a>即时脚本 here document</h3><p>基本形式</p>\n<pre><code>  command &lt;&lt; delimiter\n      document\n  delimiter\n</code></pre></li>\n</ul>\n<p>例子</p>\n<pre><code>    $ wc -l &lt;&lt; EOF\n        欢迎来到\n        菜鸟教程\n        www.runoob.com\n    EOF \n</code></pre><h3 id=\"禁止输出\"><a href=\"#禁止输出\" class=\"headerlink\" title=\"禁止输出\"></a>禁止输出</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>\n<pre><code>command &gt; /dev/null\ncommand &gt; /dev/null 2&gt;&amp;1\n</code></pre><h2 id=\"文件包含\"><a href=\"#文件包含\" class=\"headerlink\" title=\"文件包含\"></a>文件包含</h2><p>两种方式 都不需要执行权限就可以</p>\n<pre><code>. filename   # 注意点号(.)和文件名中间有一空格\n\nsource filename   # 这种方式也可以\n</code></pre><p>source命令可以让一个脚本强行影响其父shell环境<br>export命令可以让脚本影响其子shell<br>    export EDITOR=’gedit’      </p>\n<p>运行一个shell脚本时会启动另一个命令解释器.<br>每个shell脚本有效地运行在父shell(parent shell)的一个子进程里。.<br>这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程.</p>\n<pre><code>export | grep ROS   #查看ROS相关的bash变量\n</code></pre><h2 id=\"变量键盘读取、阵列与宣告-read-array-declare\"><a href=\"#变量键盘读取、阵列与宣告-read-array-declare\" class=\"headerlink\" title=\"变量键盘读取、阵列与宣告:read, array, declare\"></a>变量键盘读取、阵列与宣告:read, array, declare</h2><ol>\n<li><p>read:读取键盘输入</p>\n<pre><code> read -p &quot;Please keyin your name: &quot; -t 30 named\n</code></pre></li>\n</ol>\n<ul>\n<li>read接受变量名为参数 从标准输入接收到的信息储存 如果没有提供变量 则储存在<strong>REPLY</strong></li>\n<li><p>用作输出一段内容后暂停</p>\n<pre><code>  echo &quot;press enter to continue&quot;\n  read\n</code></pre></li>\n</ul>\n<ol>\n<li><p>declare / typeset:宣告变量类型</p>\n<pre><code> declare [-aixr] variable\n 选项与参数：\n -a  ：將后面名为 variable 的变数定义成为阵列 (array) 类型\n -i  ：將后面名为 variable 的变数定义成为整数数字 (integer) 类型\n -x  ：用法与 export 一样，就是將后面的 variable 变成环境变数；\n -r  ：將变数设定成为 readonly 类型，该变数不可被更改內容，也不能 unset\n</code></pre><p> 注意:变量类型预设为<strong>字符串</strong>,1+2不会计算,除非申明为integer;bash只能进行整数运算,1/3=0                </p>\n</li>\n</ol>\n<h2 id=\"exit-trap\"><a href=\"#exit-trap\" class=\"headerlink\" title=\"exit trap\"></a>exit trap</h2><p>exit 返回信号<br>trap 捕捉信号<br>    trap ‘echo “goodbye”; exit’ EXIT    # 捕捉退出        </p>\n<h2 id=\"常用命令-1\"><a href=\"#常用命令-1\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ol>\n<li>cut 指定的方式分割行</li>\n<li>diff 比较文件差异</li>\n<li>sort 按照字母排序(不改变源文件)</li>\n<li>uniq 对<strong>已经排好序</strong>的输入删除重复的行</li>\n<li>tr   按照制定方式对字符进行替换</li>\n<li>wc   (word counts) 统计文中字节 单词 行的数量</li>\n<li><p>substr 从字符中提取一部分 必须搭配expr进行求值</p>\n<pre><code> expr substr &quot;hello world&quot; 1 5   # hello  起始位置从1开始算\n</code></pre></li>\n<li>seq 产生一个整数序列 </li>\n</ol>\n<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><ol>\n<li>type cd 查询是否为内建命令 </li>\n<li><p>常用组合键</p>\n<pre><code> [ctrl]+u/[ctrl]+k 从光标处向前删除指令串  及向后删除指令串 \n [ctrl]+a/[ctrl]+e 让光标移动到整个指令串的最前面  或最后面  home end也可以\n</code></pre></li>\n</ol>\n<h1 id=\"下载工具\"><a href=\"#下载工具\" class=\"headerlink\" title=\"下载工具\"></a>下载工具</h1><ul>\n<li>apt</li>\n<li>wget</li>\n<li><p>Transmission   #种子下载</p>\n<pre><code>  wget  -r -np -nd http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录\n  wget  -r -np -nd --accept=cpp http://10.143.2.9/packages/      递归下载 不遍历父目录  不在本地重新创建目录 扩展名为cpp的文件\n  wget -i filename.txt      URL地址放在filename.txt文件，自动下载所有文件\n  wget -c  ...  断点续传\n</code></pre></li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.runoob.com/linux/linux-shell.html\" target=\"_blank\" rel=\"noopener\">Shell 教程</a></li>\n</ol>\n"},{"title":"ubuntu小技巧","date":"2019-09-29T13:11:37.000Z","_content":"\n# 后台运行\n\tgedit test.txt &   #  &告诉终端后台运行,\n\tgedit test.txt  \n\tctrl+Z  #移到后台\n\tbg    #返回gedit\n# 进程 \n\tps ax | grep sample\n\tkill <id>     #终止进程\n\n\ttop   #show process and memory usage\n\tP   #sort by cpu\n\tM  #sort by memory\n\t\n\tcron  at #周期任务和临时任务安排\n# 网络\n\tnmap -sn 10.1.1.1-255  # 扫描局域网ip\n\tnmap -sT -O 10.1.1.20     #扫描主机网络端口 和操作系统  -sT是默认 可以不用\n\tnamp -p1-5000 10.1.1.20 #扫描1-5000端口\n\t\n# 软件安装路径\n\twhereis gcc   #查看gcc安装路径 只是寻找系统中某些特定目录 \n\twhereis -l    #查看寻找的特定目录\n\t\n\twhich   gcc   #查看gcc运行路径\n查找命令\t\n\n\tlocate -i frankaconfig  # 不区分大小写 匹配 *frankaconfig*\n\tfind / -iname '*frankaconfig*'  #同上,区分大小写则参数是-name 不要i(case-insensitive)\n\t\n\tlocate -l 5 passwd  #显示5行结果 通过数据库查找 使用updatedb 更新\n\t\n\tfind / -mtime +4    # 5天前的文件 0表示当前到24小时之前 \n\tfind / -mtime 4     # 前4-5天的文件 \n\tfind / -mtime -4    # 4天内的文件 \n\t# 对find找到的内容再利用 {}为找到的内容 -exec 到\\;是关键词 代表find的额外动作\n\tfind / -mtime -4 -exec ls -l {} \\;\n\t\n\tfind /home -user yang   #属于yang的文件\n\tfind / -nouser          #不属于任何人的文件 \n    #那个 -a 是 and 的意思,为符合两者才算成功 ubuntu下 -exec 会有点不一样\n\tfind /etc -size +50k -a -size -60k -exec ls -l {} \\;\nrpm\n\n\trpm -ql gcc        #查看gcc相关文件的安装路径\n\trpm -qa | grep gcc #查看有没有安装gcc\n\trpm -qa            #查看全部使用rpm安装的软件\n\t\n\tsudo rpm -ivh xxx.rpm   # install  -e  (to remove)\ndeb\n\n    dpkg -L gcc         #查看gcc相关文件的安装路径\n    dpkg -l | grep gcc  #查看有没有安装gcc\n    dpkg -l             #查看全部安装包\n    \n    dpkg -i xxx.deb     #install   --remove\n## 卸载软件\n    dpkg -l    #列表显示安装的软件 配合grep 过滤\n    dpkg -r packagename    \n# 获取命令\n    whatis uname    #一行介绍性文字\n    apropos search  #想搜索一个文件又忘了命令  \n    \n# 文件压缩与归档\n\n    gzip xxx    #压缩工具\n    bzip xxx    #更高效的压缩工具\n    #c:create f:指定归档文件名 v:显示执行过程  提取c -> x\n    # czvf 会在归档之后调用gzip  cjf 调用bzip  短划线- 都是可以省略的\n    tar -cvf shell.tar shell/   \n    \n    dump restore    # 增量备份和回复 但是备份不会注意删除的文件，有可能恢复了删除的\n    cron            # 计划任务配合，自动备份          \n# 查看帮助\n1. --help\n2. man page       // man ls    1代表一般账号可用命令，8代表管理员常用命令，5代表系统配置文件\n        \n        # man page 是呼叫less来显示说明的 指令同less\n        空格  向下翻页\n        PgDn  向下\n        PgUp  向上\n        /string   向下查找string字符串\n        ?string  向上查找\n        n、N  继续下/上一个查找\n        g G   前进到第一/最后一行  \n\n3. info page   可读性高\n    \n        空格  向下翻页\n        PgDn  向下\n        PgUp  向上\n        Tab    在节点之间移动，节点通常以*表示\n        Enter    进入节点\n        b    光标移动到info界面第一处\n        e    光标移动到info界面最后一个节点\n        n    上一个节点\n        p     下一个节点\n        u    向上移动一层\n        s(/)    查找\n        h,?    显示帮助\n4. 数据同步写入磁盘 sync\n虽然目前的shutdown reboot halt在关机前执行了sync，但是多执行几次确保\n\n        \n# 高效工具\n1. **tldr** **cheat**\n\n    这两个是很好的命令备忘录　相比man 会简洁很多\n    安装tldr   (Too long, Don't read)\n    \n        sudo npm install -g tldr\n        tldr ls   #　查看ls 常用命令使用\n    安装cheat\n\n        # [对于 Python2]\n        sudo apt install python-pip python-setuptools\n        # [对于 Python3]\n        sudo apt install python3-pip\n        \n        sudo pip install cheat\n        cheat ls  #　查看ls 常用命令使用\n2. the fuck\n    \n    命令行自动纠错工具\n\n        sudo apt update\n        sudo apt install python3-d\n        ev python3-pip python3-setuptools\n        sudo pip3 install thefuck\n        \n        # .bashrc 添加如下内容\n        eval $(thefuck --alias)\n        # You can use whatever you want as an alias, like for Mondays:\n        eval $(thefuck --alias FUCK)\n\n# 时间\n- modification time (mtime):\n当该文件的『内容数据』变更时,就会更新这个时间!内容数据指的是文件的内容,而不是文件的属性或\n权限\n- status time (ctime):\n当该文件的『状态 (status)』改变时,就会更新这个时间,举例来说,像是权限与属性被更改了,都会更新\n这个时间啊。\n- access time (atime):\n当『该文件的内容被取用』时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取\n/etc/man_db.conf , 就会更新该文件的 atime 了。 \n    \n        # 查看文件的各个时间  ls 默认mtime\n        date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \\\n        > ls -l --time=ctime /etc/man_db.conf\n        \n        touch -t 201406150202 bashrc    # 修改时间\ntouch可以方便修改时间,但是复制的时候即使复制所有属性,但是没办法复制ctime  \n\n\n# 磁盘管理\n    \n    df -aT  # 查看所有特殊文件格式和名称\n    du -sb  # 查看当前目录下有多少bytes\n系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中\n\n1. /proc 的东西都是 Linux 系统所需要加载的系统数据,而且是挂载在『内存当中』\n的, 没有占任何的磁盘空间 \n\n2. /dev/shm/ 目录,其实是利用内存虚拟出来的磁盘空间,通常是总物理内存的一半     \n\n     lsblk  #列出系统上的所有磁盘列表 \n     sudo blkid #列出装置的 UUID 等参数  \n     sudo parted /dev/sdb print #列出磁盘的分区表类型与分区信息\n\n## 磁盘分区\n磁盘分区: gdisk/fdisk/parted 不要处理正在活动文件系统\n     \nMBR 分区使用 fdisk 分区, GPT 分区使用 gdisk 分区 parted两个都适用\n\n分区过程中 Last sector 后面只需要 : +1G 就可以 (增加的容量) \n\n**使用的『装置文件名』请不要加上数字,因为 partition 是针对『整个磁盘装置』而不是某个 partition** \n    \n    cat /proc/partitions    #查看分区信息\n    partprobe -s    #更新核心的分区表信息\n    \n    mkfs.ext4 /dev/sda6  #ext4文件系统 格式化\n    \n    mount -o remount,rw,auto /  #将/ 重新挂载 并加入rw与auto参数\n    mount --bind /var /data/var #将某个目录挂载到其他目录\n在配置 /etc/fstab 文件时中文件系统参数使用default就可以 包含rw, suid, dev, exec, auto, nouser, async\n\n# 网络设置\n查看网络信息\n        \n        nmcli connection show   # 后面可接特定网卡名称如eth0\n        nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto\n        nmcli connection up eth0    #启动\n        \n        hostnamectl     #主机名\n        hostnamectl set-hostname yangbenbo\n        \n        timedatectl # 时间\n        \n        localectl set-locale LANG=en_US.utf8    #设置语系\n        \n        dmidecode   #查看硬件设\n        \n        smartctl -a /dev/sda    #查看磁盘状态\n\n# 守护进程\nps 与 top 来观察程序时,都会发现到很多的 {xxx}d 的程序, 通常那就是一些daemon(守护程序)\n\n将目前工作放在**bash后台** 程序后增加 & 或者 ctrl+z\n\n        tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &   #错误和标准输出到文件 避免影响terminal\n        jobs    #列出后台进程\n        fg      #将后台工作拿到当前terminal\n        fg jobnumber\nvim 的工作无法被结束喔!因为他无法透过 kill 正常终止 \n\nkill 后面直接加数字(pid)与加上 %number (后台工作号) 的情况是不同的\n   \n        kill -l     #查看常用signal  -1 启动被终止的进程 -9 强制删除一个不正常的工作  -15 默认值 正常结束一项工作 \n        kill %2     # 结束后台2号进程\n注销系统还能运行 at nohup\n        \n动态查看进程变化 load average 分别是1 5 15分钟cpu负载 0-1 /cpu个数\n        \n        top     #按下1 可查看不同cpu的负载  \n        pstree  #查看进程依赖   \n        \n# 杀死僵尸程序\n    top  # 查看是否有僵尸进程 zombie\n    ps -A -ostat,ppid,pid,cmd | grep -e '^[zZ]'        \n    sudo kill -9 ppid(父进程pid)\n                            \n    \n# 其他\n\tuname    #查看当前系统信息 包括内核\n\tctrl + L #在资源管理器中显示绝对路径\n\tsu       #切换用户  sudo su\n\twho      #查看当前登录用户\n\tdf -t ext4     #查看磁盘使用情况\n\tdd if=xxx of=xxx    #拷贝 少用\n\tstartup  #搜索　软件开启自启动\n\tfile filename   # 查看文件类型  二进制 可执行\n\tcd ~   # home 目录\n\tcd ~yang    # 杨的home目录\n\tcd -    # 上一个目录\n\t\\rm -r /tmp/etc     # 加上反斜杠可以忽略alias的指定选项\n\tbasename /etc/sysconfig/network # 取得文档名\n\tdirname /etc/sysconfig/network  # 取得目录名字\n\tnl /etc/issue   # 带行号显示文件内容 也可以使用cat -n\n\techo password | od -t oCc   #找到 password 这几个字的 ASCII 对照\n\tfile filename # 查看文件类型 ASCII data binary\n\trmdir   #仅能删除空目录\n\t\n\t\n- ubuntu 4个工作区 和win10的多桌面一样 ctrl+alt+方向箭头 切换 setting->appearance->behavior->enable workspaces\n\n  可以在应用：键盘　设置快捷键　默认的是ctrl+alt+方向键\n  \n  - shift+1 切换到左边工作区　ctrl+shift+1 把当前窗口移动到左边工作区 \n  - shift+2 切换到左边工作区　ctrl+shift+2 把当前窗口移动到右边工作区 \n  \n  切换程序到不同工作区　快捷键或者鼠标拖动就可以\n\n- deb文件包含二进制文件、库文件、配置文件、帮助文档\nubuntu软件包：二进制包 (Binary Packages)   源码包(Source Packages)\nRedhat Linux  -> RPM包    ubunut -> Deb包\t\n\t\n\t\n\t\n\t\n# 问题\n1. 更新linux时候提示无法“由于没有公钥，无法验证下列签名 ***”的解决方案\n\n      sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6AF0E1940624A220 #此处6AF0E1940624A220需要是错误提示的key\n2. ctrl+alt  会调出窗口最大最小化之类的窗口(其实就是　激活当前窗口菜单的快捷键)　使得这类快捷键无法使用 \n快捷键窗口找相关快捷键删除 　激活当前窗口菜单冲突了　改成默认的alt+空格就行了\n\n3. qt无法输入中文\n    ubuntu16安装搜狗输入法,启动fcitx之后qtcreator无法输入中文,原因是缺少fcitx的支持库**libfcitxplatforminputcontextplugin.so**.\n    - 查找库是否安装\n        \n            dpkg -L fcitx-frontend-qt5 | grep .so\n            sudo apt-get install fcitx-frontend-qt5   #若没有则安装\n    - 拷贝到qt插件库中\n            \n            # 我是用命令行安装qt的,安装目录可能和安装包安装不一样\n            sudo cp libfcitxplatforminputcontextplugin.so /opt/qt59/plugins/platforminputcontexts \n        /opt 给第三方协力软件放置的目录.比如chrome就在这里.不确认安装目录可以查找\n            \n            sudo find / -name '*platforminputcontexts*'   \n    - 重启qtcreator            \n                           \n\t\n# 引用\n1. [linux下查看软件安装路径](https://blog.csdn.net/liufuchun111/article/details/80402109)\n2. [更新linux时候提示无法“由于没有公钥，无法验证下列签名 ***”的解决方案](https://blog.csdn.net/loovejava/article/details/21837935)\n3. [Ubuntu ctrl+alt会导致窗口还原的问题](https://www.cnblogs.com/stono/p/7105083.html)\n4. [github the fuck](https://github.com/nvbn/thefuck)\n5. [github tldr](https://github.com/lord63/tldr.py)\n6. [理解Linux系统负荷](https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)\n7. [Ubuntu下Qtcreator无法输入中文的解决办法](https://blog.csdn.net/baidu_33850454/article/details/81212026?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)\n8. [Ubuntu查找和杀死僵尸进程](https://blog.csdn.net/wzy_1988/article/details/16944789)","source":"_posts/ubuntu小技巧.md","raw":"---\ntitle: ubuntu小技巧\ndate: 2019-09-29 21:11:37\ncategories:\n- Linux\ntags:\n- \n\n---\n\n# 后台运行\n\tgedit test.txt &   #  &告诉终端后台运行,\n\tgedit test.txt  \n\tctrl+Z  #移到后台\n\tbg    #返回gedit\n# 进程 \n\tps ax | grep sample\n\tkill <id>     #终止进程\n\n\ttop   #show process and memory usage\n\tP   #sort by cpu\n\tM  #sort by memory\n\t\n\tcron  at #周期任务和临时任务安排\n# 网络\n\tnmap -sn 10.1.1.1-255  # 扫描局域网ip\n\tnmap -sT -O 10.1.1.20     #扫描主机网络端口 和操作系统  -sT是默认 可以不用\n\tnamp -p1-5000 10.1.1.20 #扫描1-5000端口\n\t\n# 软件安装路径\n\twhereis gcc   #查看gcc安装路径 只是寻找系统中某些特定目录 \n\twhereis -l    #查看寻找的特定目录\n\t\n\twhich   gcc   #查看gcc运行路径\n查找命令\t\n\n\tlocate -i frankaconfig  # 不区分大小写 匹配 *frankaconfig*\n\tfind / -iname '*frankaconfig*'  #同上,区分大小写则参数是-name 不要i(case-insensitive)\n\t\n\tlocate -l 5 passwd  #显示5行结果 通过数据库查找 使用updatedb 更新\n\t\n\tfind / -mtime +4    # 5天前的文件 0表示当前到24小时之前 \n\tfind / -mtime 4     # 前4-5天的文件 \n\tfind / -mtime -4    # 4天内的文件 \n\t# 对find找到的内容再利用 {}为找到的内容 -exec 到\\;是关键词 代表find的额外动作\n\tfind / -mtime -4 -exec ls -l {} \\;\n\t\n\tfind /home -user yang   #属于yang的文件\n\tfind / -nouser          #不属于任何人的文件 \n    #那个 -a 是 and 的意思,为符合两者才算成功 ubuntu下 -exec 会有点不一样\n\tfind /etc -size +50k -a -size -60k -exec ls -l {} \\;\nrpm\n\n\trpm -ql gcc        #查看gcc相关文件的安装路径\n\trpm -qa | grep gcc #查看有没有安装gcc\n\trpm -qa            #查看全部使用rpm安装的软件\n\t\n\tsudo rpm -ivh xxx.rpm   # install  -e  (to remove)\ndeb\n\n    dpkg -L gcc         #查看gcc相关文件的安装路径\n    dpkg -l | grep gcc  #查看有没有安装gcc\n    dpkg -l             #查看全部安装包\n    \n    dpkg -i xxx.deb     #install   --remove\n## 卸载软件\n    dpkg -l    #列表显示安装的软件 配合grep 过滤\n    dpkg -r packagename    \n# 获取命令\n    whatis uname    #一行介绍性文字\n    apropos search  #想搜索一个文件又忘了命令  \n    \n# 文件压缩与归档\n\n    gzip xxx    #压缩工具\n    bzip xxx    #更高效的压缩工具\n    #c:create f:指定归档文件名 v:显示执行过程  提取c -> x\n    # czvf 会在归档之后调用gzip  cjf 调用bzip  短划线- 都是可以省略的\n    tar -cvf shell.tar shell/   \n    \n    dump restore    # 增量备份和回复 但是备份不会注意删除的文件，有可能恢复了删除的\n    cron            # 计划任务配合，自动备份          \n# 查看帮助\n1. --help\n2. man page       // man ls    1代表一般账号可用命令，8代表管理员常用命令，5代表系统配置文件\n        \n        # man page 是呼叫less来显示说明的 指令同less\n        空格  向下翻页\n        PgDn  向下\n        PgUp  向上\n        /string   向下查找string字符串\n        ?string  向上查找\n        n、N  继续下/上一个查找\n        g G   前进到第一/最后一行  \n\n3. info page   可读性高\n    \n        空格  向下翻页\n        PgDn  向下\n        PgUp  向上\n        Tab    在节点之间移动，节点通常以*表示\n        Enter    进入节点\n        b    光标移动到info界面第一处\n        e    光标移动到info界面最后一个节点\n        n    上一个节点\n        p     下一个节点\n        u    向上移动一层\n        s(/)    查找\n        h,?    显示帮助\n4. 数据同步写入磁盘 sync\n虽然目前的shutdown reboot halt在关机前执行了sync，但是多执行几次确保\n\n        \n# 高效工具\n1. **tldr** **cheat**\n\n    这两个是很好的命令备忘录　相比man 会简洁很多\n    安装tldr   (Too long, Don't read)\n    \n        sudo npm install -g tldr\n        tldr ls   #　查看ls 常用命令使用\n    安装cheat\n\n        # [对于 Python2]\n        sudo apt install python-pip python-setuptools\n        # [对于 Python3]\n        sudo apt install python3-pip\n        \n        sudo pip install cheat\n        cheat ls  #　查看ls 常用命令使用\n2. the fuck\n    \n    命令行自动纠错工具\n\n        sudo apt update\n        sudo apt install python3-d\n        ev python3-pip python3-setuptools\n        sudo pip3 install thefuck\n        \n        # .bashrc 添加如下内容\n        eval $(thefuck --alias)\n        # You can use whatever you want as an alias, like for Mondays:\n        eval $(thefuck --alias FUCK)\n\n# 时间\n- modification time (mtime):\n当该文件的『内容数据』变更时,就会更新这个时间!内容数据指的是文件的内容,而不是文件的属性或\n权限\n- status time (ctime):\n当该文件的『状态 (status)』改变时,就会更新这个时间,举例来说,像是权限与属性被更改了,都会更新\n这个时间啊。\n- access time (atime):\n当『该文件的内容被取用』时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取\n/etc/man_db.conf , 就会更新该文件的 atime 了。 \n    \n        # 查看文件的各个时间  ls 默认mtime\n        date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \\\n        > ls -l --time=ctime /etc/man_db.conf\n        \n        touch -t 201406150202 bashrc    # 修改时间\ntouch可以方便修改时间,但是复制的时候即使复制所有属性,但是没办法复制ctime  \n\n\n# 磁盘管理\n    \n    df -aT  # 查看所有特殊文件格式和名称\n    du -sb  # 查看当前目录下有多少bytes\n系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中\n\n1. /proc 的东西都是 Linux 系统所需要加载的系统数据,而且是挂载在『内存当中』\n的, 没有占任何的磁盘空间 \n\n2. /dev/shm/ 目录,其实是利用内存虚拟出来的磁盘空间,通常是总物理内存的一半     \n\n     lsblk  #列出系统上的所有磁盘列表 \n     sudo blkid #列出装置的 UUID 等参数  \n     sudo parted /dev/sdb print #列出磁盘的分区表类型与分区信息\n\n## 磁盘分区\n磁盘分区: gdisk/fdisk/parted 不要处理正在活动文件系统\n     \nMBR 分区使用 fdisk 分区, GPT 分区使用 gdisk 分区 parted两个都适用\n\n分区过程中 Last sector 后面只需要 : +1G 就可以 (增加的容量) \n\n**使用的『装置文件名』请不要加上数字,因为 partition 是针对『整个磁盘装置』而不是某个 partition** \n    \n    cat /proc/partitions    #查看分区信息\n    partprobe -s    #更新核心的分区表信息\n    \n    mkfs.ext4 /dev/sda6  #ext4文件系统 格式化\n    \n    mount -o remount,rw,auto /  #将/ 重新挂载 并加入rw与auto参数\n    mount --bind /var /data/var #将某个目录挂载到其他目录\n在配置 /etc/fstab 文件时中文件系统参数使用default就可以 包含rw, suid, dev, exec, auto, nouser, async\n\n# 网络设置\n查看网络信息\n        \n        nmcli connection show   # 后面可接特定网卡名称如eth0\n        nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto\n        nmcli connection up eth0    #启动\n        \n        hostnamectl     #主机名\n        hostnamectl set-hostname yangbenbo\n        \n        timedatectl # 时间\n        \n        localectl set-locale LANG=en_US.utf8    #设置语系\n        \n        dmidecode   #查看硬件设\n        \n        smartctl -a /dev/sda    #查看磁盘状态\n\n# 守护进程\nps 与 top 来观察程序时,都会发现到很多的 {xxx}d 的程序, 通常那就是一些daemon(守护程序)\n\n将目前工作放在**bash后台** 程序后增加 & 或者 ctrl+z\n\n        tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &   #错误和标准输出到文件 避免影响terminal\n        jobs    #列出后台进程\n        fg      #将后台工作拿到当前terminal\n        fg jobnumber\nvim 的工作无法被结束喔!因为他无法透过 kill 正常终止 \n\nkill 后面直接加数字(pid)与加上 %number (后台工作号) 的情况是不同的\n   \n        kill -l     #查看常用signal  -1 启动被终止的进程 -9 强制删除一个不正常的工作  -15 默认值 正常结束一项工作 \n        kill %2     # 结束后台2号进程\n注销系统还能运行 at nohup\n        \n动态查看进程变化 load average 分别是1 5 15分钟cpu负载 0-1 /cpu个数\n        \n        top     #按下1 可查看不同cpu的负载  \n        pstree  #查看进程依赖   \n        \n# 杀死僵尸程序\n    top  # 查看是否有僵尸进程 zombie\n    ps -A -ostat,ppid,pid,cmd | grep -e '^[zZ]'        \n    sudo kill -9 ppid(父进程pid)\n                            \n    \n# 其他\n\tuname    #查看当前系统信息 包括内核\n\tctrl + L #在资源管理器中显示绝对路径\n\tsu       #切换用户  sudo su\n\twho      #查看当前登录用户\n\tdf -t ext4     #查看磁盘使用情况\n\tdd if=xxx of=xxx    #拷贝 少用\n\tstartup  #搜索　软件开启自启动\n\tfile filename   # 查看文件类型  二进制 可执行\n\tcd ~   # home 目录\n\tcd ~yang    # 杨的home目录\n\tcd -    # 上一个目录\n\t\\rm -r /tmp/etc     # 加上反斜杠可以忽略alias的指定选项\n\tbasename /etc/sysconfig/network # 取得文档名\n\tdirname /etc/sysconfig/network  # 取得目录名字\n\tnl /etc/issue   # 带行号显示文件内容 也可以使用cat -n\n\techo password | od -t oCc   #找到 password 这几个字的 ASCII 对照\n\tfile filename # 查看文件类型 ASCII data binary\n\trmdir   #仅能删除空目录\n\t\n\t\n- ubuntu 4个工作区 和win10的多桌面一样 ctrl+alt+方向箭头 切换 setting->appearance->behavior->enable workspaces\n\n  可以在应用：键盘　设置快捷键　默认的是ctrl+alt+方向键\n  \n  - shift+1 切换到左边工作区　ctrl+shift+1 把当前窗口移动到左边工作区 \n  - shift+2 切换到左边工作区　ctrl+shift+2 把当前窗口移动到右边工作区 \n  \n  切换程序到不同工作区　快捷键或者鼠标拖动就可以\n\n- deb文件包含二进制文件、库文件、配置文件、帮助文档\nubuntu软件包：二进制包 (Binary Packages)   源码包(Source Packages)\nRedhat Linux  -> RPM包    ubunut -> Deb包\t\n\t\n\t\n\t\n\t\n# 问题\n1. 更新linux时候提示无法“由于没有公钥，无法验证下列签名 ***”的解决方案\n\n      sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6AF0E1940624A220 #此处6AF0E1940624A220需要是错误提示的key\n2. ctrl+alt  会调出窗口最大最小化之类的窗口(其实就是　激活当前窗口菜单的快捷键)　使得这类快捷键无法使用 \n快捷键窗口找相关快捷键删除 　激活当前窗口菜单冲突了　改成默认的alt+空格就行了\n\n3. qt无法输入中文\n    ubuntu16安装搜狗输入法,启动fcitx之后qtcreator无法输入中文,原因是缺少fcitx的支持库**libfcitxplatforminputcontextplugin.so**.\n    - 查找库是否安装\n        \n            dpkg -L fcitx-frontend-qt5 | grep .so\n            sudo apt-get install fcitx-frontend-qt5   #若没有则安装\n    - 拷贝到qt插件库中\n            \n            # 我是用命令行安装qt的,安装目录可能和安装包安装不一样\n            sudo cp libfcitxplatforminputcontextplugin.so /opt/qt59/plugins/platforminputcontexts \n        /opt 给第三方协力软件放置的目录.比如chrome就在这里.不确认安装目录可以查找\n            \n            sudo find / -name '*platforminputcontexts*'   \n    - 重启qtcreator            \n                           \n\t\n# 引用\n1. [linux下查看软件安装路径](https://blog.csdn.net/liufuchun111/article/details/80402109)\n2. [更新linux时候提示无法“由于没有公钥，无法验证下列签名 ***”的解决方案](https://blog.csdn.net/loovejava/article/details/21837935)\n3. [Ubuntu ctrl+alt会导致窗口还原的问题](https://www.cnblogs.com/stono/p/7105083.html)\n4. [github the fuck](https://github.com/nvbn/thefuck)\n5. [github tldr](https://github.com/lord63/tldr.py)\n6. [理解Linux系统负荷](https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)\n7. [Ubuntu下Qtcreator无法输入中文的解决办法](https://blog.csdn.net/baidu_33850454/article/details/81212026?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)\n8. [Ubuntu查找和杀死僵尸进程](https://blog.csdn.net/wzy_1988/article/details/16944789)","slug":"ubuntu小技巧","published":1,"updated":"2020-11-17T01:41:02.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cji006zmxka2wwrgn9e","content":"<h1 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h1><pre><code>gedit test.txt &amp;   #  &amp;告诉终端后台运行,\ngedit test.txt  \nctrl+Z  #移到后台\nbg    #返回gedit\n</code></pre><h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><pre><code>ps ax | grep sample\nkill &lt;id&gt;     #终止进程\n\ntop   #show process and memory usage\nP   #sort by cpu\nM  #sort by memory\n\ncron  at #周期任务和临时任务安排\n</code></pre><h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><pre><code>nmap -sn 10.1.1.1-255  # 扫描局域网ip\nnmap -sT -O 10.1.1.20     #扫描主机网络端口 和操作系统  -sT是默认 可以不用\nnamp -p1-5000 10.1.1.20 #扫描1-5000端口\n</code></pre><h1 id=\"软件安装路径\"><a href=\"#软件安装路径\" class=\"headerlink\" title=\"软件安装路径\"></a>软件安装路径</h1><pre><code>whereis gcc   #查看gcc安装路径 只是寻找系统中某些特定目录 \nwhereis -l    #查看寻找的特定目录\n\nwhich   gcc   #查看gcc运行路径\n</code></pre><p>查找命令    </p>\n<pre><code>locate -i frankaconfig  # 不区分大小写 匹配 *frankaconfig*\nfind / -iname &#39;*frankaconfig*&#39;  #同上,区分大小写则参数是-name 不要i(case-insensitive)\n\nlocate -l 5 passwd  #显示5行结果 通过数据库查找 使用updatedb 更新\n\nfind / -mtime +4    # 5天前的文件 0表示当前到24小时之前 \nfind / -mtime 4     # 前4-5天的文件 \nfind / -mtime -4    # 4天内的文件 \n# 对find找到的内容再利用 {}为找到的内容 -exec 到\\;是关键词 代表find的额外动作\nfind / -mtime -4 -exec ls -l {} \\;\n\nfind /home -user yang   #属于yang的文件\nfind / -nouser          #不属于任何人的文件 \n#那个 -a 是 and 的意思,为符合两者才算成功 ubuntu下 -exec 会有点不一样\nfind /etc -size +50k -a -size -60k -exec ls -l {} \\;\n</code></pre><p>rpm</p>\n<pre><code>rpm -ql gcc        #查看gcc相关文件的安装路径\nrpm -qa | grep gcc #查看有没有安装gcc\nrpm -qa            #查看全部使用rpm安装的软件\n\nsudo rpm -ivh xxx.rpm   # install  -e  (to remove)\n</code></pre><p>deb</p>\n<pre><code>dpkg -L gcc         #查看gcc相关文件的安装路径\ndpkg -l | grep gcc  #查看有没有安装gcc\ndpkg -l             #查看全部安装包\n\ndpkg -i xxx.deb     #install   --remove\n</code></pre><h2 id=\"卸载软件\"><a href=\"#卸载软件\" class=\"headerlink\" title=\"卸载软件\"></a>卸载软件</h2><pre><code>dpkg -l    #列表显示安装的软件 配合grep 过滤\ndpkg -r packagename    \n</code></pre><h1 id=\"获取命令\"><a href=\"#获取命令\" class=\"headerlink\" title=\"获取命令\"></a>获取命令</h1><pre><code>whatis uname    #一行介绍性文字\napropos search  #想搜索一个文件又忘了命令  \n</code></pre><h1 id=\"文件压缩与归档\"><a href=\"#文件压缩与归档\" class=\"headerlink\" title=\"文件压缩与归档\"></a>文件压缩与归档</h1><pre><code>gzip xxx    #压缩工具\nbzip xxx    #更高效的压缩工具\n#c:create f:指定归档文件名 v:显示执行过程  提取c -&gt; x\n# czvf 会在归档之后调用gzip  cjf 调用bzip  短划线- 都是可以省略的\ntar -cvf shell.tar shell/   \n\ndump restore    # 增量备份和回复 但是备份不会注意删除的文件，有可能恢复了删除的\ncron            # 计划任务配合，自动备份          \n</code></pre><h1 id=\"查看帮助\"><a href=\"#查看帮助\" class=\"headerlink\" title=\"查看帮助\"></a>查看帮助</h1><ol>\n<li>—help</li>\n<li><p>man page       // man ls    1代表一般账号可用命令，8代表管理员常用命令，5代表系统配置文件</p>\n<pre><code> # man page 是呼叫less来显示说明的 指令同less\n 空格  向下翻页\n PgDn  向下\n PgUp  向上\n /string   向下查找string字符串\n ?string  向上查找\n n、N  继续下/上一个查找\n g G   前进到第一/最后一行  \n</code></pre></li>\n<li><p>info page   可读性高</p>\n<pre><code> 空格  向下翻页\n PgDn  向下\n PgUp  向上\n Tab    在节点之间移动，节点通常以*表示\n Enter    进入节点\n b    光标移动到info界面第一处\n e    光标移动到info界面最后一个节点\n n    上一个节点\n p     下一个节点\n u    向上移动一层\n s(/)    查找\n h,?    显示帮助\n</code></pre></li>\n<li>数据同步写入磁盘 sync<br>虽然目前的shutdown reboot halt在关机前执行了sync，但是多执行几次确保</li>\n</ol>\n<h1 id=\"高效工具\"><a href=\"#高效工具\" class=\"headerlink\" title=\"高效工具\"></a>高效工具</h1><ol>\n<li><p><strong>tldr</strong> <strong>cheat</strong></p>\n<p> 这两个是很好的命令备忘录　相比man 会简洁很多<br> 安装tldr   (Too long, Don’t read)</p>\n<pre><code> sudo npm install -g tldr\n tldr ls   #　查看ls 常用命令使用\n</code></pre><p> 安装cheat</p>\n<pre><code> # [对于 Python2]\n sudo apt install python-pip python-setuptools\n # [对于 Python3]\n sudo apt install python3-pip\n\n sudo pip install cheat\n cheat ls  #　查看ls 常用命令使用\n</code></pre></li>\n<li><p>the fuck</p>\n<p> 命令行自动纠错工具</p>\n<pre><code> sudo apt update\n sudo apt install python3-d\n ev python3-pip python3-setuptools\n sudo pip3 install thefuck\n\n # .bashrc 添加如下内容\n eval $(thefuck --alias)\n # You can use whatever you want as an alias, like for Mondays:\n eval $(thefuck --alias FUCK)\n</code></pre></li>\n</ol>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><ul>\n<li>modification time (mtime):<br>当该文件的『内容数据』变更时,就会更新这个时间!内容数据指的是文件的内容,而不是文件的属性或<br>权限</li>\n<li>status time (ctime):<br>当该文件的『状态 (status)』改变时,就会更新这个时间,举例来说,像是权限与属性被更改了,都会更新<br>这个时间啊。</li>\n<li><p>access time (atime):<br>当『该文件的内容被取用』时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取<br>/etc/man_db.conf , 就会更新该文件的 atime 了。 </p>\n<pre><code>  # 查看文件的各个时间  ls 默认mtime\n  date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \\\n  &gt; ls -l --time=ctime /etc/man_db.conf\n\n  touch -t 201406150202 bashrc    # 修改时间\n</code></pre><p>touch可以方便修改时间,但是复制的时候即使复制所有属性,但是没办法复制ctime  </p>\n</li>\n</ul>\n<h1 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h1><pre><code>df -aT  # 查看所有特殊文件格式和名称\ndu -sb  # 查看当前目录下有多少bytes\n</code></pre><p>系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中</p>\n<ol>\n<li><p>/proc 的东西都是 Linux 系统所需要加载的系统数据,而且是挂载在『内存当中』<br>的, 没有占任何的磁盘空间 </p>\n</li>\n<li><p>/dev/shm/ 目录,其实是利用内存虚拟出来的磁盘空间,通常是总物理内存的一半     </p>\n<p>  lsblk  #列出系统上的所有磁盘列表<br>  sudo blkid #列出装置的 UUID 等参数<br>  sudo parted /dev/sdb print #列出磁盘的分区表类型与分区信息</p>\n</li>\n</ol>\n<h2 id=\"磁盘分区\"><a href=\"#磁盘分区\" class=\"headerlink\" title=\"磁盘分区\"></a>磁盘分区</h2><p>磁盘分区: gdisk/fdisk/parted 不要处理正在活动文件系统</p>\n<p>MBR 分区使用 fdisk 分区, GPT 分区使用 gdisk 分区 parted两个都适用</p>\n<p>分区过程中 Last sector 后面只需要 : +1G 就可以 (增加的容量) </p>\n<p><strong>使用的『装置文件名』请不要加上数字,因为 partition 是针对『整个磁盘装置』而不是某个 partition</strong> </p>\n<pre><code>cat /proc/partitions    #查看分区信息\npartprobe -s    #更新核心的分区表信息\n\nmkfs.ext4 /dev/sda6  #ext4文件系统 格式化\n\nmount -o remount,rw,auto /  #将/ 重新挂载 并加入rw与auto参数\nmount --bind /var /data/var #将某个目录挂载到其他目录\n</code></pre><p>在配置 /etc/fstab 文件时中文件系统参数使用default就可以 包含rw, suid, dev, exec, auto, nouser, async</p>\n<h1 id=\"网络设置\"><a href=\"#网络设置\" class=\"headerlink\" title=\"网络设置\"></a>网络设置</h1><p>查看网络信息</p>\n<pre><code>    nmcli connection show   # 后面可接特定网卡名称如eth0\n    nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto\n    nmcli connection up eth0    #启动\n\n    hostnamectl     #主机名\n    hostnamectl set-hostname yangbenbo\n\n    timedatectl # 时间\n\n    localectl set-locale LANG=en_US.utf8    #设置语系\n\n    dmidecode   #查看硬件设\n\n    smartctl -a /dev/sda    #查看磁盘状态\n</code></pre><h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>ps 与 top 来观察程序时,都会发现到很多的 {xxx}d 的程序, 通常那就是一些daemon(守护程序)</p>\n<p>将目前工作放在<strong>bash后台</strong> 程序后增加 &amp; 或者 ctrl+z</p>\n<pre><code>    tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;   #错误和标准输出到文件 避免影响terminal\n    jobs    #列出后台进程\n    fg      #将后台工作拿到当前terminal\n    fg jobnumber\n</code></pre><p>vim 的工作无法被结束喔!因为他无法透过 kill 正常终止 </p>\n<p>kill 后面直接加数字(pid)与加上 %number (后台工作号) 的情况是不同的</p>\n<pre><code>    kill -l     #查看常用signal  -1 启动被终止的进程 -9 强制删除一个不正常的工作  -15 默认值 正常结束一项工作 \n    kill %2     # 结束后台2号进程\n</code></pre><p>注销系统还能运行 at nohup</p>\n<p>动态查看进程变化 load average 分别是1 5 15分钟cpu负载 0-1 /cpu个数</p>\n<pre><code>    top     #按下1 可查看不同cpu的负载  \n    pstree  #查看进程依赖   \n</code></pre><h1 id=\"杀死僵尸程序\"><a href=\"#杀死僵尸程序\" class=\"headerlink\" title=\"杀死僵尸程序\"></a>杀死僵尸程序</h1><pre><code>top  # 查看是否有僵尸进程 zombie\nps -A -ostat,ppid,pid,cmd | grep -e &#39;^[zZ]&#39;        \nsudo kill -9 ppid(父进程pid)\n</code></pre><h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><pre><code>uname    #查看当前系统信息 包括内核\nctrl + L #在资源管理器中显示绝对路径\nsu       #切换用户  sudo su\nwho      #查看当前登录用户\ndf -t ext4     #查看磁盘使用情况\ndd if=xxx of=xxx    #拷贝 少用\nstartup  #搜索　软件开启自启动\nfile filename   # 查看文件类型  二进制 可执行\ncd ~   # home 目录\ncd ~yang    # 杨的home目录\ncd -    # 上一个目录\n\\rm -r /tmp/etc     # 加上反斜杠可以忽略alias的指定选项\nbasename /etc/sysconfig/network # 取得文档名\ndirname /etc/sysconfig/network  # 取得目录名字\nnl /etc/issue   # 带行号显示文件内容 也可以使用cat -n\necho password | od -t oCc   #找到 password 这几个字的 ASCII 对照\nfile filename # 查看文件类型 ASCII data binary\nrmdir   #仅能删除空目录\n</code></pre><ul>\n<li><p>ubuntu 4个工作区 和win10的多桌面一样 ctrl+alt+方向箭头 切换 setting-&gt;appearance-&gt;behavior-&gt;enable workspaces</p>\n<p>可以在应用：键盘　设置快捷键　默认的是ctrl+alt+方向键</p>\n<ul>\n<li>shift+1 切换到左边工作区　ctrl+shift+1 把当前窗口移动到左边工作区 </li>\n<li>shift+2 切换到左边工作区　ctrl+shift+2 把当前窗口移动到右边工作区 </li>\n</ul>\n<p>切换程序到不同工作区　快捷键或者鼠标拖动就可以</p>\n</li>\n<li><p>deb文件包含二进制文件、库文件、配置文件、帮助文档<br>ubuntu软件包：二进制包 (Binary Packages)   源码包(Source Packages)<br>Redhat Linux  -&gt; RPM包    ubunut -&gt; Deb包    </p>\n</li>\n</ul>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li><p>更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</p>\n<p>   sudo apt-key adv —keyserver keyserver.ubuntu.com —recv-keys 6AF0E1940624A220 #此处6AF0E1940624A220需要是错误提示的key</p>\n</li>\n<li><p>ctrl+alt  会调出窗口最大最小化之类的窗口(其实就是　激活当前窗口菜单的快捷键)　使得这类快捷键无法使用<br>快捷键窗口找相关快捷键删除 　激活当前窗口菜单冲突了　改成默认的alt+空格就行了</p>\n</li>\n<li><p>qt无法输入中文<br> ubuntu16安装搜狗输入法,启动fcitx之后qtcreator无法输入中文,原因是缺少fcitx的支持库<strong>libfcitxplatforminputcontextplugin.so</strong>.</p>\n<ul>\n<li><p>查找库是否安装</p>\n<pre><code>  dpkg -L fcitx-frontend-qt5 | grep .so\n  sudo apt-get install fcitx-frontend-qt5   #若没有则安装\n</code></pre></li>\n<li><p>拷贝到qt插件库中</p>\n<pre><code>  # 我是用命令行安装qt的,安装目录可能和安装包安装不一样\n  sudo cp libfcitxplatforminputcontextplugin.so /opt/qt59/plugins/platforminputcontexts \n</code></pre><p>  /opt 给第三方协力软件放置的目录.比如chrome就在这里.不确认安装目录可以查找</p>\n<pre><code>  sudo find / -name &#39;*platforminputcontexts*&#39;   \n</code></pre></li>\n<li>重启qtcreator            </li>\n</ul>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/liufuchun111/article/details/80402109\" target=\"_blank\" rel=\"noopener\">linux下查看软件安装路径</a></li>\n<li><a href=\"https://blog.csdn.net/loovejava/article/details/21837935\" target=\"_blank\" rel=\"noopener\">更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</a></li>\n<li><a href=\"https://www.cnblogs.com/stono/p/7105083.html\" target=\"_blank\" rel=\"noopener\">Ubuntu ctrl+alt会导致窗口还原的问题</a></li>\n<li><a href=\"https://github.com/nvbn/thefuck\" target=\"_blank\" rel=\"noopener\">github the fuck</a></li>\n<li><a href=\"https://github.com/lord63/tldr.py\" target=\"_blank\" rel=\"noopener\">github tldr</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html\" target=\"_blank\" rel=\"noopener\">理解Linux系统负荷</a></li>\n<li><a href=\"https://blog.csdn.net/baidu_33850454/article/details/81212026?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2\" target=\"_blank\" rel=\"noopener\">Ubuntu下Qtcreator无法输入中文的解决办法</a></li>\n<li><a href=\"https://blog.csdn.net/wzy_1988/article/details/16944789\" target=\"_blank\" rel=\"noopener\">Ubuntu查找和杀死僵尸进程</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"后台运行\"><a href=\"#后台运行\" class=\"headerlink\" title=\"后台运行\"></a>后台运行</h1><pre><code>gedit test.txt &amp;   #  &amp;告诉终端后台运行,\ngedit test.txt  \nctrl+Z  #移到后台\nbg    #返回gedit\n</code></pre><h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><pre><code>ps ax | grep sample\nkill &lt;id&gt;     #终止进程\n\ntop   #show process and memory usage\nP   #sort by cpu\nM  #sort by memory\n\ncron  at #周期任务和临时任务安排\n</code></pre><h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><pre><code>nmap -sn 10.1.1.1-255  # 扫描局域网ip\nnmap -sT -O 10.1.1.20     #扫描主机网络端口 和操作系统  -sT是默认 可以不用\nnamp -p1-5000 10.1.1.20 #扫描1-5000端口\n</code></pre><h1 id=\"软件安装路径\"><a href=\"#软件安装路径\" class=\"headerlink\" title=\"软件安装路径\"></a>软件安装路径</h1><pre><code>whereis gcc   #查看gcc安装路径 只是寻找系统中某些特定目录 \nwhereis -l    #查看寻找的特定目录\n\nwhich   gcc   #查看gcc运行路径\n</code></pre><p>查找命令    </p>\n<pre><code>locate -i frankaconfig  # 不区分大小写 匹配 *frankaconfig*\nfind / -iname &#39;*frankaconfig*&#39;  #同上,区分大小写则参数是-name 不要i(case-insensitive)\n\nlocate -l 5 passwd  #显示5行结果 通过数据库查找 使用updatedb 更新\n\nfind / -mtime +4    # 5天前的文件 0表示当前到24小时之前 \nfind / -mtime 4     # 前4-5天的文件 \nfind / -mtime -4    # 4天内的文件 \n# 对find找到的内容再利用 {}为找到的内容 -exec 到\\;是关键词 代表find的额外动作\nfind / -mtime -4 -exec ls -l {} \\;\n\nfind /home -user yang   #属于yang的文件\nfind / -nouser          #不属于任何人的文件 \n#那个 -a 是 and 的意思,为符合两者才算成功 ubuntu下 -exec 会有点不一样\nfind /etc -size +50k -a -size -60k -exec ls -l {} \\;\n</code></pre><p>rpm</p>\n<pre><code>rpm -ql gcc        #查看gcc相关文件的安装路径\nrpm -qa | grep gcc #查看有没有安装gcc\nrpm -qa            #查看全部使用rpm安装的软件\n\nsudo rpm -ivh xxx.rpm   # install  -e  (to remove)\n</code></pre><p>deb</p>\n<pre><code>dpkg -L gcc         #查看gcc相关文件的安装路径\ndpkg -l | grep gcc  #查看有没有安装gcc\ndpkg -l             #查看全部安装包\n\ndpkg -i xxx.deb     #install   --remove\n</code></pre><h2 id=\"卸载软件\"><a href=\"#卸载软件\" class=\"headerlink\" title=\"卸载软件\"></a>卸载软件</h2><pre><code>dpkg -l    #列表显示安装的软件 配合grep 过滤\ndpkg -r packagename    \n</code></pre><h1 id=\"获取命令\"><a href=\"#获取命令\" class=\"headerlink\" title=\"获取命令\"></a>获取命令</h1><pre><code>whatis uname    #一行介绍性文字\napropos search  #想搜索一个文件又忘了命令  \n</code></pre><h1 id=\"文件压缩与归档\"><a href=\"#文件压缩与归档\" class=\"headerlink\" title=\"文件压缩与归档\"></a>文件压缩与归档</h1><pre><code>gzip xxx    #压缩工具\nbzip xxx    #更高效的压缩工具\n#c:create f:指定归档文件名 v:显示执行过程  提取c -&gt; x\n# czvf 会在归档之后调用gzip  cjf 调用bzip  短划线- 都是可以省略的\ntar -cvf shell.tar shell/   \n\ndump restore    # 增量备份和回复 但是备份不会注意删除的文件，有可能恢复了删除的\ncron            # 计划任务配合，自动备份          \n</code></pre><h1 id=\"查看帮助\"><a href=\"#查看帮助\" class=\"headerlink\" title=\"查看帮助\"></a>查看帮助</h1><ol>\n<li>—help</li>\n<li><p>man page       // man ls    1代表一般账号可用命令，8代表管理员常用命令，5代表系统配置文件</p>\n<pre><code> # man page 是呼叫less来显示说明的 指令同less\n 空格  向下翻页\n PgDn  向下\n PgUp  向上\n /string   向下查找string字符串\n ?string  向上查找\n n、N  继续下/上一个查找\n g G   前进到第一/最后一行  \n</code></pre></li>\n<li><p>info page   可读性高</p>\n<pre><code> 空格  向下翻页\n PgDn  向下\n PgUp  向上\n Tab    在节点之间移动，节点通常以*表示\n Enter    进入节点\n b    光标移动到info界面第一处\n e    光标移动到info界面最后一个节点\n n    上一个节点\n p     下一个节点\n u    向上移动一层\n s(/)    查找\n h,?    显示帮助\n</code></pre></li>\n<li>数据同步写入磁盘 sync<br>虽然目前的shutdown reboot halt在关机前执行了sync，但是多执行几次确保</li>\n</ol>\n<h1 id=\"高效工具\"><a href=\"#高效工具\" class=\"headerlink\" title=\"高效工具\"></a>高效工具</h1><ol>\n<li><p><strong>tldr</strong> <strong>cheat</strong></p>\n<p> 这两个是很好的命令备忘录　相比man 会简洁很多<br> 安装tldr   (Too long, Don’t read)</p>\n<pre><code> sudo npm install -g tldr\n tldr ls   #　查看ls 常用命令使用\n</code></pre><p> 安装cheat</p>\n<pre><code> # [对于 Python2]\n sudo apt install python-pip python-setuptools\n # [对于 Python3]\n sudo apt install python3-pip\n\n sudo pip install cheat\n cheat ls  #　查看ls 常用命令使用\n</code></pre></li>\n<li><p>the fuck</p>\n<p> 命令行自动纠错工具</p>\n<pre><code> sudo apt update\n sudo apt install python3-d\n ev python3-pip python3-setuptools\n sudo pip3 install thefuck\n\n # .bashrc 添加如下内容\n eval $(thefuck --alias)\n # You can use whatever you want as an alias, like for Mondays:\n eval $(thefuck --alias FUCK)\n</code></pre></li>\n</ol>\n<h1 id=\"时间\"><a href=\"#时间\" class=\"headerlink\" title=\"时间\"></a>时间</h1><ul>\n<li>modification time (mtime):<br>当该文件的『内容数据』变更时,就会更新这个时间!内容数据指的是文件的内容,而不是文件的属性或<br>权限</li>\n<li>status time (ctime):<br>当该文件的『状态 (status)』改变时,就会更新这个时间,举例来说,像是权限与属性被更改了,都会更新<br>这个时间啊。</li>\n<li><p>access time (atime):<br>当『该文件的内容被取用』时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取<br>/etc/man_db.conf , 就会更新该文件的 atime 了。 </p>\n<pre><code>  # 查看文件的各个时间  ls 默认mtime\n  date; ls -l /etc/man_db.conf ; ls -l --time=atime /etc/man_db.conf ; \\\n  &gt; ls -l --time=ctime /etc/man_db.conf\n\n  touch -t 201406150202 bashrc    # 修改时间\n</code></pre><p>touch可以方便修改时间,但是复制的时候即使复制所有属性,但是没办法复制ctime  </p>\n</li>\n</ul>\n<h1 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h1><pre><code>df -aT  # 查看所有特殊文件格式和名称\ndu -sb  # 查看当前目录下有多少bytes\n</code></pre><p>系统里面其实还有很多特殊的文件系统存在的。那些比较特殊的文件系统几乎都是在内存当中</p>\n<ol>\n<li><p>/proc 的东西都是 Linux 系统所需要加载的系统数据,而且是挂载在『内存当中』<br>的, 没有占任何的磁盘空间 </p>\n</li>\n<li><p>/dev/shm/ 目录,其实是利用内存虚拟出来的磁盘空间,通常是总物理内存的一半     </p>\n<p>  lsblk  #列出系统上的所有磁盘列表<br>  sudo blkid #列出装置的 UUID 等参数<br>  sudo parted /dev/sdb print #列出磁盘的分区表类型与分区信息</p>\n</li>\n</ol>\n<h2 id=\"磁盘分区\"><a href=\"#磁盘分区\" class=\"headerlink\" title=\"磁盘分区\"></a>磁盘分区</h2><p>磁盘分区: gdisk/fdisk/parted 不要处理正在活动文件系统</p>\n<p>MBR 分区使用 fdisk 分区, GPT 分区使用 gdisk 分区 parted两个都适用</p>\n<p>分区过程中 Last sector 后面只需要 : +1G 就可以 (增加的容量) </p>\n<p><strong>使用的『装置文件名』请不要加上数字,因为 partition 是针对『整个磁盘装置』而不是某个 partition</strong> </p>\n<pre><code>cat /proc/partitions    #查看分区信息\npartprobe -s    #更新核心的分区表信息\n\nmkfs.ext4 /dev/sda6  #ext4文件系统 格式化\n\nmount -o remount,rw,auto /  #将/ 重新挂载 并加入rw与auto参数\nmount --bind /var /data/var #将某个目录挂载到其他目录\n</code></pre><p>在配置 /etc/fstab 文件时中文件系统参数使用default就可以 包含rw, suid, dev, exec, auto, nouser, async</p>\n<h1 id=\"网络设置\"><a href=\"#网络设置\" class=\"headerlink\" title=\"网络设置\"></a>网络设置</h1><p>查看网络信息</p>\n<pre><code>    nmcli connection show   # 后面可接特定网卡名称如eth0\n    nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto\n    nmcli connection up eth0    #启动\n\n    hostnamectl     #主机名\n    hostnamectl set-hostname yangbenbo\n\n    timedatectl # 时间\n\n    localectl set-locale LANG=en_US.utf8    #设置语系\n\n    dmidecode   #查看硬件设\n\n    smartctl -a /dev/sda    #查看磁盘状态\n</code></pre><h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>ps 与 top 来观察程序时,都会发现到很多的 {xxx}d 的程序, 通常那就是一些daemon(守护程序)</p>\n<p>将目前工作放在<strong>bash后台</strong> 程序后增加 &amp; 或者 ctrl+z</p>\n<pre><code>    tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;   #错误和标准输出到文件 避免影响terminal\n    jobs    #列出后台进程\n    fg      #将后台工作拿到当前terminal\n    fg jobnumber\n</code></pre><p>vim 的工作无法被结束喔!因为他无法透过 kill 正常终止 </p>\n<p>kill 后面直接加数字(pid)与加上 %number (后台工作号) 的情况是不同的</p>\n<pre><code>    kill -l     #查看常用signal  -1 启动被终止的进程 -9 强制删除一个不正常的工作  -15 默认值 正常结束一项工作 \n    kill %2     # 结束后台2号进程\n</code></pre><p>注销系统还能运行 at nohup</p>\n<p>动态查看进程变化 load average 分别是1 5 15分钟cpu负载 0-1 /cpu个数</p>\n<pre><code>    top     #按下1 可查看不同cpu的负载  \n    pstree  #查看进程依赖   \n</code></pre><h1 id=\"杀死僵尸程序\"><a href=\"#杀死僵尸程序\" class=\"headerlink\" title=\"杀死僵尸程序\"></a>杀死僵尸程序</h1><pre><code>top  # 查看是否有僵尸进程 zombie\nps -A -ostat,ppid,pid,cmd | grep -e &#39;^[zZ]&#39;        \nsudo kill -9 ppid(父进程pid)\n</code></pre><h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><pre><code>uname    #查看当前系统信息 包括内核\nctrl + L #在资源管理器中显示绝对路径\nsu       #切换用户  sudo su\nwho      #查看当前登录用户\ndf -t ext4     #查看磁盘使用情况\ndd if=xxx of=xxx    #拷贝 少用\nstartup  #搜索　软件开启自启动\nfile filename   # 查看文件类型  二进制 可执行\ncd ~   # home 目录\ncd ~yang    # 杨的home目录\ncd -    # 上一个目录\n\\rm -r /tmp/etc     # 加上反斜杠可以忽略alias的指定选项\nbasename /etc/sysconfig/network # 取得文档名\ndirname /etc/sysconfig/network  # 取得目录名字\nnl /etc/issue   # 带行号显示文件内容 也可以使用cat -n\necho password | od -t oCc   #找到 password 这几个字的 ASCII 对照\nfile filename # 查看文件类型 ASCII data binary\nrmdir   #仅能删除空目录\n</code></pre><ul>\n<li><p>ubuntu 4个工作区 和win10的多桌面一样 ctrl+alt+方向箭头 切换 setting-&gt;appearance-&gt;behavior-&gt;enable workspaces</p>\n<p>可以在应用：键盘　设置快捷键　默认的是ctrl+alt+方向键</p>\n<ul>\n<li>shift+1 切换到左边工作区　ctrl+shift+1 把当前窗口移动到左边工作区 </li>\n<li>shift+2 切换到左边工作区　ctrl+shift+2 把当前窗口移动到右边工作区 </li>\n</ul>\n<p>切换程序到不同工作区　快捷键或者鼠标拖动就可以</p>\n</li>\n<li><p>deb文件包含二进制文件、库文件、配置文件、帮助文档<br>ubuntu软件包：二进制包 (Binary Packages)   源码包(Source Packages)<br>Redhat Linux  -&gt; RPM包    ubunut -&gt; Deb包    </p>\n</li>\n</ul>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li><p>更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</p>\n<p>   sudo apt-key adv —keyserver keyserver.ubuntu.com —recv-keys 6AF0E1940624A220 #此处6AF0E1940624A220需要是错误提示的key</p>\n</li>\n<li><p>ctrl+alt  会调出窗口最大最小化之类的窗口(其实就是　激活当前窗口菜单的快捷键)　使得这类快捷键无法使用<br>快捷键窗口找相关快捷键删除 　激活当前窗口菜单冲突了　改成默认的alt+空格就行了</p>\n</li>\n<li><p>qt无法输入中文<br> ubuntu16安装搜狗输入法,启动fcitx之后qtcreator无法输入中文,原因是缺少fcitx的支持库<strong>libfcitxplatforminputcontextplugin.so</strong>.</p>\n<ul>\n<li><p>查找库是否安装</p>\n<pre><code>  dpkg -L fcitx-frontend-qt5 | grep .so\n  sudo apt-get install fcitx-frontend-qt5   #若没有则安装\n</code></pre></li>\n<li><p>拷贝到qt插件库中</p>\n<pre><code>  # 我是用命令行安装qt的,安装目录可能和安装包安装不一样\n  sudo cp libfcitxplatforminputcontextplugin.so /opt/qt59/plugins/platforminputcontexts \n</code></pre><p>  /opt 给第三方协力软件放置的目录.比如chrome就在这里.不确认安装目录可以查找</p>\n<pre><code>  sudo find / -name &#39;*platforminputcontexts*&#39;   \n</code></pre></li>\n<li>重启qtcreator            </li>\n</ul>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/liufuchun111/article/details/80402109\" target=\"_blank\" rel=\"noopener\">linux下查看软件安装路径</a></li>\n<li><a href=\"https://blog.csdn.net/loovejava/article/details/21837935\" target=\"_blank\" rel=\"noopener\">更新linux时候提示无法“由于没有公钥，无法验证下列签名 <em>*</em>”的解决方案</a></li>\n<li><a href=\"https://www.cnblogs.com/stono/p/7105083.html\" target=\"_blank\" rel=\"noopener\">Ubuntu ctrl+alt会导致窗口还原的问题</a></li>\n<li><a href=\"https://github.com/nvbn/thefuck\" target=\"_blank\" rel=\"noopener\">github the fuck</a></li>\n<li><a href=\"https://github.com/lord63/tldr.py\" target=\"_blank\" rel=\"noopener\">github tldr</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html\" target=\"_blank\" rel=\"noopener\">理解Linux系统负荷</a></li>\n<li><a href=\"https://blog.csdn.net/baidu_33850454/article/details/81212026?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2\" target=\"_blank\" rel=\"noopener\">Ubuntu下Qtcreator无法输入中文的解决办法</a></li>\n<li><a href=\"https://blog.csdn.net/wzy_1988/article/details/16944789\" target=\"_blank\" rel=\"noopener\">Ubuntu查找和杀死僵尸进程</a></li>\n</ol>\n"},{"title":"网络基础","date":"2019-12-15T14:24:56.000Z","_content":"\n TCP/IP 协定家族中，其层阶关係如下\n![](TCPIPfamily.png)\nTCP/IP 的资料流是逐层传递的\n![](TCPIPdata.png)\n\nOSI 7层:前3属网络群组,后4属于使用者群组\n\nTCP/IP 运作举例\n1. 应用程式阶段：妳打开瀏览器，在瀏览器上面输入网址列，按下 [Enter]。此时网址列与相关资料会被瀏览器包成一个资料， 並向下传给 TCP/IP 的应用层；\n2. 应用层：由应用层提供的 HTTP 通讯协定，將来自瀏览器的资料包起来，並给予一个应用层表头，再向传送层丟去；\n3. 传送层：由於 HTTP 为可靠连线，因此將该资料丟入 TCP 封包內，並给予一个 TCP 封包的表头，向网路层丟去；\n4. 网路层：將 TCP 包裹包进 IP 封包內，再给予一个 IP 表头 (主要就是来源与目標的 IP 囉)，向链结层丟去；\n5. 链结层：如果使用乙太网路时，此时 IP 会依据 CSMA/CD 的標准，包裹到 **MAC** 讯框中，並给予 MAC 表头，再转成位元串后， 利用传输媒体传送到远端主机上。\n\n**IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。**\n![OSI与TCP/IP](OSI_TCPIP.png)\n\n# ARP/RARP\n1. ARP 协定:Address Resolution Protocol,获取目标IP对应的物理地址,实际传输都是靠物理地址.\nARP 是 TCP/IP 设计者利用乙太网的广播性质﹐设计出来的位址解释协定。\n2. RARP 协定:Reverse Address Resolution Protocol,利用广播,查询网路上其它主机而得到自己的 IP 位址.\n3. PROXY ARP:代理 (Proxy) ARP 通常用来在路由器上代为回答在它后面的某个网路主机的 ARP 请求。\n这是一种欺骗手法﹐因为查询端会以为目標主机就是路由器本身﹐但事实上﹐机器是在另一个网路里面。\n\n#IP\n![](IPHead.png)\n在局域网内可通过ip广播来传递资料,非目标主机会自动丢弃资料(通过物理地址判断)\n\n同一局域网内设置成不同ip网段,广播地址不同造成无法透过广播的方式进行连线,需要路由(router)\n\n## IP地址\n1. IP划分\n    ![](IPSection.png)\n    127 (即二进位的 01111111) 需要特別一提：它是保留给本机回路测试使用的﹐\n    它不可以被运用於实际的网路中，其中的 127.0.0.1 则代表任何一台 IP 主机本身.\n    \n    - 主机号位置全为0    整个网段的地址\n    - 主机号位置全为1    广播地址\n    \n2. 私有IP\n    住主要用于组建局域网\n    \n    由於 Internet 的爆炸性成长﹐IP 的位址买少见少﹐而且在很多机构里﹐\n    也不是所有机器都有必要使用註册的 IP 位址。於是﹐我们就在 A﹑B﹑C 这三个层级里面﹐\n    各划出一些位址范围保留给私有位址所用﹐它们分別是﹕\n    \n    - 10.0.0.0 - 10.255.255.255\n    - 172.16.0.0 - 172.31.255.255\n    - 192.168.0.0 - 192.168.255.255\n    \n    限制:\n    - 私有位址的路由资讯不能对外散播;\n    - 使用私有位址作为来源或目的位址的封包﹐不能透过 Internet 来转送;\n    - 关於私有位址的参考纪录﹐只能限於內部网路使用\n\n3. Subnet:划分子网,从Host ID中借位\n    ![Subnet](Subnet.png)\n4. Supernet:从NET ID中借位使用的是 CIDR (Classless Inter-Domain Routing)技术.可不必理会 IP 的开首字元﹐你可以隨便设定您的 Net Mask 长度。\n    ![Supernet](Supernet.png)\n\n# ICMP\nICMP 的全名是『 Internet Control Message Protocol, 网际网路讯息控制协定 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以確保我们网路的连线状態与连线的正確性！\n\nICMP 同样是透过 IP 封包来进行资料传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ \n\n应用:使用ping 与 traceroute透过 ICMP 封包的辅助来確认与回报网路主机的状態。\n\n设定防火墙的时候,容易忽略的就是这个 ICMP 的封包(只会记住 TCP/UDP),基本上，ICMP 封包也不应该全部都挡掉喔! \n\n# TCP/UDP\n针对TCP表头,主要注意6个Control FLag.相应的TCP3次握手也主要是从这个来的\n\n- Urgent data:当 URG 被设定为 1 的时候﹐表示紧急资料的封包，接收端需优先处理。\n- Acknowledge field significant:当 ACK 为 1 的时候﹐表示此封包的 Acknowledge Number 是有效的﹐也就是用来回应上一个封包。一般都会为 1。一般只有只有第一个封包没有设。\n- Push function:如果 PSH 为 1 的时候﹐该封包连同传送缓衝区的其它封包应立即进行传送，而无需等待缓衝区满了才送。接收端必须儘快將此资料交给程式处理。\n- Reset:如果 RST 为 1 的时候﹐连线会被马上结束，而无需等待终止確认手续。\n- Synchronize sequence number:如果 SYN 为 1 时﹐表示要求双方进行同步处理﹐也就是要求建立连线。\n- No more data fro sender (Finish):如果封包的 FIN 为 1 的时候﹐就表示传送结束﹐然后双方发出结束回应﹐进而正式进入 TCP 传送的终止流程。\n\n![TCPHead](TCPHead.png)\nSequence 和 Acknowledge 是 TCP 传送中的重要检测手段.\n![TCPTrans](TCPTrans.png)\n![UDPHead](UDPHead.png)\nTCP 提供的是一个连线导向(Connection Oriented)的可靠传输.\nUDP 则是一个非连线型(Connectionless)的非可靠传输协定﹐\n它並不会运用確认机制来保证资料是否正確的被接收、\n不需要重传遗失的资料、资料的接收可不必按顺序进行、\n也不提供回传机制来控制资料流的速度。\n因此﹐ UDP 信息可能会在网路传送过程中丟失﹑重复﹑或不依顺序﹐\n而且抵达速度也可能比接收端的处理速度还快。\n\n- TCP: 传送可靠,程序可省略可靠机制,但速度慢\n- UDP: 传输量大,迅速,但是不可靠,需要程序自行提供可靠机制\n    \n# CSMA/CD\n\n乙太网路的传输协定 CSMA/CD (Carrier Sense Multiple Access with Collision Detection) \n\n虽然讯框会在整个网段(segment)中用广播的方式传递﹐而且所有节点都会收到讯框﹐\n然而﹐只有目的位址符合自己实体位址的讯框才会被接收下来。\n因此，不管上层协定是哪一种(可以是 TCP/IP 也可以是其它)，\n在底层的传送若是使用 Ethernet 的话，就得使用 **MAC (Media Access Control) **实体位址.\n\n1. 监听媒体使用情况 (Carrier Sense)：A 主机要发送网路封包前，需要先对网路媒体进行监听，\n確认没有人在使用后， 才能够发送出讯框；\n\n2. 多点传输 (Multiple Access)：A 主机所送出的资料会被集线器复製一份，\n然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的资料， \nB, C, D 三部电脑都能够接收的到！但由於目標是 D 主机，因此 B 与 C 会將此讯框资料丟弃，而 D 则会抓下来处理；\n\n3. 碰撞侦测 (Collision Detection)：该讯框资料附有检测能力，\n若其他主机例如 B 电脑也刚好在同时间发送讯框资料时， \n那么 A 与 B 送出的资料碰撞在一块 (出车祸) ，此时这些讯框就是损毁，\n那么 A 与 B 就会各自隨机等待一个时间， 然后重新透过第一步再传送一次该讯框资料。\n\n![CSMA/CD连线](csmacd.gif)\n\n每张乙太网路卡出厂时，就会赋予一个独一无二的卡號，那就是所谓的 MAC (Media Access Control)\n\n1. HUB 单纯的是一个 repeater﹐当它从一个 port (和 TCP 协定的 port 不一样﹐这里\n是指插网路线的接孔)接收信號进来之后﹐会將这个信號原原本本的送到所有其它\nport 上﹐不管哪些 port 是接到哪一台机器。\n\n2. 而 switch 呢﹖它自己有一份 table﹐记录著哪个 port 接到哪些 MAC 位址设备上。\n当信號从一个 port 进来之后﹐会检查这个 frame 的 destination 是哪个 MAC﹐然\n后按 table 找到这个 MAC 对应的 port ﹐而仅將信號往这个 port 送﹐其它的 port\n就不送了。\n\n\n\n# 引用\n1. [载波侦听多路访问](https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE#CSMA/CD)\n2. [基础网络概念](http://linux.vbird.org/linux_server/0110network_basic.php#ps11)\n3. [网络基础](http://www.study-area.org/network/networkfr2.htm) ","source":"_posts/网络基础.md","raw":"---\ntitle: 网络基础\ndate: 2019-12-15 22:24:56\ncategories:\n- internet\ntags:\n- 网络基础\n---\n\n TCP/IP 协定家族中，其层阶关係如下\n![](TCPIPfamily.png)\nTCP/IP 的资料流是逐层传递的\n![](TCPIPdata.png)\n\nOSI 7层:前3属网络群组,后4属于使用者群组\n\nTCP/IP 运作举例\n1. 应用程式阶段：妳打开瀏览器，在瀏览器上面输入网址列，按下 [Enter]。此时网址列与相关资料会被瀏览器包成一个资料， 並向下传给 TCP/IP 的应用层；\n2. 应用层：由应用层提供的 HTTP 通讯协定，將来自瀏览器的资料包起来，並给予一个应用层表头，再向传送层丟去；\n3. 传送层：由於 HTTP 为可靠连线，因此將该资料丟入 TCP 封包內，並给予一个 TCP 封包的表头，向网路层丟去；\n4. 网路层：將 TCP 包裹包进 IP 封包內，再给予一个 IP 表头 (主要就是来源与目標的 IP 囉)，向链结层丟去；\n5. 链结层：如果使用乙太网路时，此时 IP 会依据 CSMA/CD 的標准，包裹到 **MAC** 讯框中，並给予 MAC 表头，再转成位元串后， 利用传输媒体传送到远端主机上。\n\n**IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。**\n![OSI与TCP/IP](OSI_TCPIP.png)\n\n# ARP/RARP\n1. ARP 协定:Address Resolution Protocol,获取目标IP对应的物理地址,实际传输都是靠物理地址.\nARP 是 TCP/IP 设计者利用乙太网的广播性质﹐设计出来的位址解释协定。\n2. RARP 协定:Reverse Address Resolution Protocol,利用广播,查询网路上其它主机而得到自己的 IP 位址.\n3. PROXY ARP:代理 (Proxy) ARP 通常用来在路由器上代为回答在它后面的某个网路主机的 ARP 请求。\n这是一种欺骗手法﹐因为查询端会以为目標主机就是路由器本身﹐但事实上﹐机器是在另一个网路里面。\n\n#IP\n![](IPHead.png)\n在局域网内可通过ip广播来传递资料,非目标主机会自动丢弃资料(通过物理地址判断)\n\n同一局域网内设置成不同ip网段,广播地址不同造成无法透过广播的方式进行连线,需要路由(router)\n\n## IP地址\n1. IP划分\n    ![](IPSection.png)\n    127 (即二进位的 01111111) 需要特別一提：它是保留给本机回路测试使用的﹐\n    它不可以被运用於实际的网路中，其中的 127.0.0.1 则代表任何一台 IP 主机本身.\n    \n    - 主机号位置全为0    整个网段的地址\n    - 主机号位置全为1    广播地址\n    \n2. 私有IP\n    住主要用于组建局域网\n    \n    由於 Internet 的爆炸性成长﹐IP 的位址买少见少﹐而且在很多机构里﹐\n    也不是所有机器都有必要使用註册的 IP 位址。於是﹐我们就在 A﹑B﹑C 这三个层级里面﹐\n    各划出一些位址范围保留给私有位址所用﹐它们分別是﹕\n    \n    - 10.0.0.0 - 10.255.255.255\n    - 172.16.0.0 - 172.31.255.255\n    - 192.168.0.0 - 192.168.255.255\n    \n    限制:\n    - 私有位址的路由资讯不能对外散播;\n    - 使用私有位址作为来源或目的位址的封包﹐不能透过 Internet 来转送;\n    - 关於私有位址的参考纪录﹐只能限於內部网路使用\n\n3. Subnet:划分子网,从Host ID中借位\n    ![Subnet](Subnet.png)\n4. Supernet:从NET ID中借位使用的是 CIDR (Classless Inter-Domain Routing)技术.可不必理会 IP 的开首字元﹐你可以隨便设定您的 Net Mask 长度。\n    ![Supernet](Supernet.png)\n\n# ICMP\nICMP 的全名是『 Internet Control Message Protocol, 网际网路讯息控制协定 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以確保我们网路的连线状態与连线的正確性！\n\nICMP 同样是透过 IP 封包来进行资料传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ \n\n应用:使用ping 与 traceroute透过 ICMP 封包的辅助来確认与回报网路主机的状態。\n\n设定防火墙的时候,容易忽略的就是这个 ICMP 的封包(只会记住 TCP/UDP),基本上，ICMP 封包也不应该全部都挡掉喔! \n\n# TCP/UDP\n针对TCP表头,主要注意6个Control FLag.相应的TCP3次握手也主要是从这个来的\n\n- Urgent data:当 URG 被设定为 1 的时候﹐表示紧急资料的封包，接收端需优先处理。\n- Acknowledge field significant:当 ACK 为 1 的时候﹐表示此封包的 Acknowledge Number 是有效的﹐也就是用来回应上一个封包。一般都会为 1。一般只有只有第一个封包没有设。\n- Push function:如果 PSH 为 1 的时候﹐该封包连同传送缓衝区的其它封包应立即进行传送，而无需等待缓衝区满了才送。接收端必须儘快將此资料交给程式处理。\n- Reset:如果 RST 为 1 的时候﹐连线会被马上结束，而无需等待终止確认手续。\n- Synchronize sequence number:如果 SYN 为 1 时﹐表示要求双方进行同步处理﹐也就是要求建立连线。\n- No more data fro sender (Finish):如果封包的 FIN 为 1 的时候﹐就表示传送结束﹐然后双方发出结束回应﹐进而正式进入 TCP 传送的终止流程。\n\n![TCPHead](TCPHead.png)\nSequence 和 Acknowledge 是 TCP 传送中的重要检测手段.\n![TCPTrans](TCPTrans.png)\n![UDPHead](UDPHead.png)\nTCP 提供的是一个连线导向(Connection Oriented)的可靠传输.\nUDP 则是一个非连线型(Connectionless)的非可靠传输协定﹐\n它並不会运用確认机制来保证资料是否正確的被接收、\n不需要重传遗失的资料、资料的接收可不必按顺序进行、\n也不提供回传机制来控制资料流的速度。\n因此﹐ UDP 信息可能会在网路传送过程中丟失﹑重复﹑或不依顺序﹐\n而且抵达速度也可能比接收端的处理速度还快。\n\n- TCP: 传送可靠,程序可省略可靠机制,但速度慢\n- UDP: 传输量大,迅速,但是不可靠,需要程序自行提供可靠机制\n    \n# CSMA/CD\n\n乙太网路的传输协定 CSMA/CD (Carrier Sense Multiple Access with Collision Detection) \n\n虽然讯框会在整个网段(segment)中用广播的方式传递﹐而且所有节点都会收到讯框﹐\n然而﹐只有目的位址符合自己实体位址的讯框才会被接收下来。\n因此，不管上层协定是哪一种(可以是 TCP/IP 也可以是其它)，\n在底层的传送若是使用 Ethernet 的话，就得使用 **MAC (Media Access Control) **实体位址.\n\n1. 监听媒体使用情况 (Carrier Sense)：A 主机要发送网路封包前，需要先对网路媒体进行监听，\n確认没有人在使用后， 才能够发送出讯框；\n\n2. 多点传输 (Multiple Access)：A 主机所送出的资料会被集线器复製一份，\n然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的资料， \nB, C, D 三部电脑都能够接收的到！但由於目標是 D 主机，因此 B 与 C 会將此讯框资料丟弃，而 D 则会抓下来处理；\n\n3. 碰撞侦测 (Collision Detection)：该讯框资料附有检测能力，\n若其他主机例如 B 电脑也刚好在同时间发送讯框资料时， \n那么 A 与 B 送出的资料碰撞在一块 (出车祸) ，此时这些讯框就是损毁，\n那么 A 与 B 就会各自隨机等待一个时间， 然后重新透过第一步再传送一次该讯框资料。\n\n![CSMA/CD连线](csmacd.gif)\n\n每张乙太网路卡出厂时，就会赋予一个独一无二的卡號，那就是所谓的 MAC (Media Access Control)\n\n1. HUB 单纯的是一个 repeater﹐当它从一个 port (和 TCP 协定的 port 不一样﹐这里\n是指插网路线的接孔)接收信號进来之后﹐会將这个信號原原本本的送到所有其它\nport 上﹐不管哪些 port 是接到哪一台机器。\n\n2. 而 switch 呢﹖它自己有一份 table﹐记录著哪个 port 接到哪些 MAC 位址设备上。\n当信號从一个 port 进来之后﹐会检查这个 frame 的 destination 是哪个 MAC﹐然\n后按 table 找到这个 MAC 对应的 port ﹐而仅將信號往这个 port 送﹐其它的 port\n就不送了。\n\n\n\n# 引用\n1. [载波侦听多路访问](https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE#CSMA/CD)\n2. [基础网络概念](http://linux.vbird.org/linux_server/0110network_basic.php#ps11)\n3. [网络基础](http://www.study-area.org/network/networkfr2.htm) ","slug":"网络基础","published":1,"updated":"2020-09-23T14:42:00.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjk0071mxka4uewjewh","content":"<p> TCP/IP 协定家族中，其层阶关係如下<br><img src=\"/2019/12/15/网络基础/TCPIPfamily.png\" alt><br>TCP/IP 的资料流是逐层传递的<br><img src=\"/2019/12/15/网络基础/TCPIPdata.png\" alt></p>\n<p>OSI 7层:前3属网络群组,后4属于使用者群组</p>\n<p>TCP/IP 运作举例</p>\n<ol>\n<li>应用程式阶段：妳打开瀏览器，在瀏览器上面输入网址列，按下 [Enter]。此时网址列与相关资料会被瀏览器包成一个资料， 並向下传给 TCP/IP 的应用层；</li>\n<li>应用层：由应用层提供的 HTTP 通讯协定，將来自瀏览器的资料包起来，並给予一个应用层表头，再向传送层丟去；</li>\n<li>传送层：由於 HTTP 为可靠连线，因此將该资料丟入 TCP 封包內，並给予一个 TCP 封包的表头，向网路层丟去；</li>\n<li>网路层：將 TCP 包裹包进 IP 封包內，再给予一个 IP 表头 (主要就是来源与目標的 IP 囉)，向链结层丟去；</li>\n<li>链结层：如果使用乙太网路时，此时 IP 会依据 CSMA/CD 的標准，包裹到 <strong>MAC</strong> 讯框中，並给予 MAC 表头，再转成位元串后， 利用传输媒体传送到远端主机上。</li>\n</ol>\n<p><strong>IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</strong><br><img src=\"/2019/12/15/网络基础/OSI_TCPIP.png\" alt=\"OSI与TCP/IP\"></p>\n<h1 id=\"ARP-RARP\"><a href=\"#ARP-RARP\" class=\"headerlink\" title=\"ARP/RARP\"></a>ARP/RARP</h1><ol>\n<li>ARP 协定:Address Resolution Protocol,获取目标IP对应的物理地址,实际传输都是靠物理地址.<br>ARP 是 TCP/IP 设计者利用乙太网的广播性质﹐设计出来的位址解释协定。</li>\n<li>RARP 协定:Reverse Address Resolution Protocol,利用广播,查询网路上其它主机而得到自己的 IP 位址.</li>\n<li>PROXY ARP:代理 (Proxy) ARP 通常用来在路由器上代为回答在它后面的某个网路主机的 ARP 请求。<br>这是一种欺骗手法﹐因为查询端会以为目標主机就是路由器本身﹐但事实上﹐机器是在另一个网路里面。</li>\n</ol>\n<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p><img src=\"/2019/12/15/网络基础/IPHead.png\" alt><br>在局域网内可通过ip广播来传递资料,非目标主机会自动丢弃资料(通过物理地址判断)</p>\n<p>同一局域网内设置成不同ip网段,广播地址不同造成无法透过广播的方式进行连线,需要路由(router)</p>\n<h2 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h2><ol>\n<li><p>IP划分<br> <img src=\"/2019/12/15/网络基础/IPSection.png\" alt><br> 127 (即二进位的 01111111) 需要特別一提：它是保留给本机回路测试使用的﹐<br> 它不可以被运用於实际的网路中，其中的 127.0.0.1 则代表任何一台 IP 主机本身.</p>\n<ul>\n<li>主机号位置全为0    整个网段的地址</li>\n<li>主机号位置全为1    广播地址</li>\n</ul>\n</li>\n<li><p>私有IP<br> 住主要用于组建局域网</p>\n<p> 由於 Internet 的爆炸性成长﹐IP 的位址买少见少﹐而且在很多机构里﹐<br> 也不是所有机器都有必要使用註册的 IP 位址。於是﹐我们就在 A﹑B﹑C 这三个层级里面﹐<br> 各划出一些位址范围保留给私有位址所用﹐它们分別是﹕</p>\n<ul>\n<li>10.0.0.0 - 10.255.255.255</li>\n<li>172.16.0.0 - 172.31.255.255</li>\n<li><p>192.168.0.0 - 192.168.255.255</p>\n<p>限制:</p>\n</li>\n<li>私有位址的路由资讯不能对外散播;</li>\n<li>使用私有位址作为来源或目的位址的封包﹐不能透过 Internet 来转送;</li>\n<li>关於私有位址的参考纪录﹐只能限於內部网路使用</li>\n</ul>\n</li>\n<li><p>Subnet:划分子网,从Host ID中借位<br> <img src=\"/2019/12/15/网络基础/Subnet.png\" alt=\"Subnet\"></p>\n</li>\n<li>Supernet:从NET ID中借位使用的是 CIDR (Classless Inter-Domain Routing)技术.可不必理会 IP 的开首字元﹐你可以隨便设定您的 Net Mask 长度。<br> <img src=\"/2019/12/15/网络基础/Supernet.png\" alt=\"Supernet\"></li>\n</ol>\n<h1 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a>ICMP</h1><p>ICMP 的全名是『 Internet Control Message Protocol, 网际网路讯息控制协定 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以確保我们网路的连线状態与连线的正確性！</p>\n<p>ICMP 同样是透过 IP 封包来进行资料传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ </p>\n<p>应用:使用ping 与 traceroute透过 ICMP 封包的辅助来確认与回报网路主机的状態。</p>\n<p>设定防火墙的时候,容易忽略的就是这个 ICMP 的封包(只会记住 TCP/UDP),基本上，ICMP 封包也不应该全部都挡掉喔! </p>\n<h1 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h1><p>针对TCP表头,主要注意6个Control FLag.相应的TCP3次握手也主要是从这个来的</p>\n<ul>\n<li>Urgent data:当 URG 被设定为 1 的时候﹐表示紧急资料的封包，接收端需优先处理。</li>\n<li>Acknowledge field significant:当 ACK 为 1 的时候﹐表示此封包的 Acknowledge Number 是有效的﹐也就是用来回应上一个封包。一般都会为 1。一般只有只有第一个封包没有设。</li>\n<li>Push function:如果 PSH 为 1 的时候﹐该封包连同传送缓衝区的其它封包应立即进行传送，而无需等待缓衝区满了才送。接收端必须儘快將此资料交给程式处理。</li>\n<li>Reset:如果 RST 为 1 的时候﹐连线会被马上结束，而无需等待终止確认手续。</li>\n<li>Synchronize sequence number:如果 SYN 为 1 时﹐表示要求双方进行同步处理﹐也就是要求建立连线。</li>\n<li>No more data fro sender (Finish):如果封包的 FIN 为 1 的时候﹐就表示传送结束﹐然后双方发出结束回应﹐进而正式进入 TCP 传送的终止流程。</li>\n</ul>\n<p><img src=\"/2019/12/15/网络基础/TCPHead.png\" alt=\"TCPHead\"><br>Sequence 和 Acknowledge 是 TCP 传送中的重要检测手段.<br><img src=\"/2019/12/15/网络基础/TCPTrans.png\" alt=\"TCPTrans\"><br><img src=\"/2019/12/15/网络基础/UDPHead.png\" alt=\"UDPHead\"><br>TCP 提供的是一个连线导向(Connection Oriented)的可靠传输.<br>UDP 则是一个非连线型(Connectionless)的非可靠传输协定﹐<br>它並不会运用確认机制来保证资料是否正確的被接收、<br>不需要重传遗失的资料、资料的接收可不必按顺序进行、<br>也不提供回传机制来控制资料流的速度。<br>因此﹐ UDP 信息可能会在网路传送过程中丟失﹑重复﹑或不依顺序﹐<br>而且抵达速度也可能比接收端的处理速度还快。</p>\n<ul>\n<li>TCP: 传送可靠,程序可省略可靠机制,但速度慢</li>\n<li>UDP: 传输量大,迅速,但是不可靠,需要程序自行提供可靠机制</li>\n</ul>\n<h1 id=\"CSMA-CD\"><a href=\"#CSMA-CD\" class=\"headerlink\" title=\"CSMA/CD\"></a>CSMA/CD</h1><p>乙太网路的传输协定 CSMA/CD (Carrier Sense Multiple Access with Collision Detection) </p>\n<p>虽然讯框会在整个网段(segment)中用广播的方式传递﹐而且所有节点都会收到讯框﹐<br>然而﹐只有目的位址符合自己实体位址的讯框才会被接收下来。<br>因此，不管上层协定是哪一种(可以是 TCP/IP 也可以是其它)，<br>在底层的传送若是使用 Ethernet 的话，就得使用 <strong>MAC (Media Access Control) </strong>实体位址.</p>\n<ol>\n<li><p>监听媒体使用情况 (Carrier Sense)：A 主机要发送网路封包前，需要先对网路媒体进行监听，<br>確认没有人在使用后， 才能够发送出讯框；</p>\n</li>\n<li><p>多点传输 (Multiple Access)：A 主机所送出的资料会被集线器复製一份，<br>然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的资料，<br>B, C, D 三部电脑都能够接收的到！但由於目標是 D 主机，因此 B 与 C 会將此讯框资料丟弃，而 D 则会抓下来处理；</p>\n</li>\n<li><p>碰撞侦测 (Collision Detection)：该讯框资料附有检测能力，<br>若其他主机例如 B 电脑也刚好在同时间发送讯框资料时，<br>那么 A 与 B 送出的资料碰撞在一块 (出车祸) ，此时这些讯框就是损毁，<br>那么 A 与 B 就会各自隨机等待一个时间， 然后重新透过第一步再传送一次该讯框资料。</p>\n</li>\n</ol>\n<p><img src=\"/2019/12/15/网络基础/csmacd.gif\" alt=\"CSMA/CD连线\"></p>\n<p>每张乙太网路卡出厂时，就会赋予一个独一无二的卡號，那就是所谓的 MAC (Media Access Control)</p>\n<ol>\n<li><p>HUB 单纯的是一个 repeater﹐当它从一个 port (和 TCP 协定的 port 不一样﹐这里<br>是指插网路线的接孔)接收信號进来之后﹐会將这个信號原原本本的送到所有其它<br>port 上﹐不管哪些 port 是接到哪一台机器。</p>\n</li>\n<li><p>而 switch 呢﹖它自己有一份 table﹐记录著哪个 port 接到哪些 MAC 位址设备上。<br>当信號从一个 port 进来之后﹐会检查这个 frame 的 destination 是哪个 MAC﹐然<br>后按 table 找到这个 MAC 对应的 port ﹐而仅將信號往这个 port 送﹐其它的 port<br>就不送了。</p>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE#CSMA/CD\" target=\"_blank\" rel=\"noopener\">载波侦听多路访问</a></li>\n<li><a href=\"http://linux.vbird.org/linux_server/0110network_basic.php#ps11\" target=\"_blank\" rel=\"noopener\">基础网络概念</a></li>\n<li><a href=\"http://www.study-area.org/network/networkfr2.htm\" target=\"_blank\" rel=\"noopener\">网络基础</a> </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p> TCP/IP 协定家族中，其层阶关係如下<br><img src=\"/2019/12/15/网络基础/TCPIPfamily.png\" alt><br>TCP/IP 的资料流是逐层传递的<br><img src=\"/2019/12/15/网络基础/TCPIPdata.png\" alt></p>\n<p>OSI 7层:前3属网络群组,后4属于使用者群组</p>\n<p>TCP/IP 运作举例</p>\n<ol>\n<li>应用程式阶段：妳打开瀏览器，在瀏览器上面输入网址列，按下 [Enter]。此时网址列与相关资料会被瀏览器包成一个资料， 並向下传给 TCP/IP 的应用层；</li>\n<li>应用层：由应用层提供的 HTTP 通讯协定，將来自瀏览器的资料包起来，並给予一个应用层表头，再向传送层丟去；</li>\n<li>传送层：由於 HTTP 为可靠连线，因此將该资料丟入 TCP 封包內，並给予一个 TCP 封包的表头，向网路层丟去；</li>\n<li>网路层：將 TCP 包裹包进 IP 封包內，再给予一个 IP 表头 (主要就是来源与目標的 IP 囉)，向链结层丟去；</li>\n<li>链结层：如果使用乙太网路时，此时 IP 会依据 CSMA/CD 的標准，包裹到 <strong>MAC</strong> 讯框中，並给予 MAC 表头，再转成位元串后， 利用传输媒体传送到远端主机上。</li>\n</ol>\n<p><strong>IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</strong><br><img src=\"/2019/12/15/网络基础/OSI_TCPIP.png\" alt=\"OSI与TCP/IP\"></p>\n<h1 id=\"ARP-RARP\"><a href=\"#ARP-RARP\" class=\"headerlink\" title=\"ARP/RARP\"></a>ARP/RARP</h1><ol>\n<li>ARP 协定:Address Resolution Protocol,获取目标IP对应的物理地址,实际传输都是靠物理地址.<br>ARP 是 TCP/IP 设计者利用乙太网的广播性质﹐设计出来的位址解释协定。</li>\n<li>RARP 协定:Reverse Address Resolution Protocol,利用广播,查询网路上其它主机而得到自己的 IP 位址.</li>\n<li>PROXY ARP:代理 (Proxy) ARP 通常用来在路由器上代为回答在它后面的某个网路主机的 ARP 请求。<br>这是一种欺骗手法﹐因为查询端会以为目標主机就是路由器本身﹐但事实上﹐机器是在另一个网路里面。</li>\n</ol>\n<h1 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h1><p><img src=\"/2019/12/15/网络基础/IPHead.png\" alt><br>在局域网内可通过ip广播来传递资料,非目标主机会自动丢弃资料(通过物理地址判断)</p>\n<p>同一局域网内设置成不同ip网段,广播地址不同造成无法透过广播的方式进行连线,需要路由(router)</p>\n<h2 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h2><ol>\n<li><p>IP划分<br> <img src=\"/2019/12/15/网络基础/IPSection.png\" alt><br> 127 (即二进位的 01111111) 需要特別一提：它是保留给本机回路测试使用的﹐<br> 它不可以被运用於实际的网路中，其中的 127.0.0.1 则代表任何一台 IP 主机本身.</p>\n<ul>\n<li>主机号位置全为0    整个网段的地址</li>\n<li>主机号位置全为1    广播地址</li>\n</ul>\n</li>\n<li><p>私有IP<br> 住主要用于组建局域网</p>\n<p> 由於 Internet 的爆炸性成长﹐IP 的位址买少见少﹐而且在很多机构里﹐<br> 也不是所有机器都有必要使用註册的 IP 位址。於是﹐我们就在 A﹑B﹑C 这三个层级里面﹐<br> 各划出一些位址范围保留给私有位址所用﹐它们分別是﹕</p>\n<ul>\n<li>10.0.0.0 - 10.255.255.255</li>\n<li>172.16.0.0 - 172.31.255.255</li>\n<li><p>192.168.0.0 - 192.168.255.255</p>\n<p>限制:</p>\n</li>\n<li>私有位址的路由资讯不能对外散播;</li>\n<li>使用私有位址作为来源或目的位址的封包﹐不能透过 Internet 来转送;</li>\n<li>关於私有位址的参考纪录﹐只能限於內部网路使用</li>\n</ul>\n</li>\n<li><p>Subnet:划分子网,从Host ID中借位<br> <img src=\"/2019/12/15/网络基础/Subnet.png\" alt=\"Subnet\"></p>\n</li>\n<li>Supernet:从NET ID中借位使用的是 CIDR (Classless Inter-Domain Routing)技术.可不必理会 IP 的开首字元﹐你可以隨便设定您的 Net Mask 长度。<br> <img src=\"/2019/12/15/网络基础/Supernet.png\" alt=\"Supernet\"></li>\n</ol>\n<h1 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a>ICMP</h1><p>ICMP 的全名是『 Internet Control Message Protocol, 网际网路讯息控制协定 』。 基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以確保我们网路的连线状態与连线的正確性！</p>\n<p>ICMP 同样是透过 IP 封包来进行资料传送的啦！因为在 Internet 上面有传输能力的就是 IP 封包啊！ </p>\n<p>应用:使用ping 与 traceroute透过 ICMP 封包的辅助来確认与回报网路主机的状態。</p>\n<p>设定防火墙的时候,容易忽略的就是这个 ICMP 的封包(只会记住 TCP/UDP),基本上，ICMP 封包也不应该全部都挡掉喔! </p>\n<h1 id=\"TCP-UDP\"><a href=\"#TCP-UDP\" class=\"headerlink\" title=\"TCP/UDP\"></a>TCP/UDP</h1><p>针对TCP表头,主要注意6个Control FLag.相应的TCP3次握手也主要是从这个来的</p>\n<ul>\n<li>Urgent data:当 URG 被设定为 1 的时候﹐表示紧急资料的封包，接收端需优先处理。</li>\n<li>Acknowledge field significant:当 ACK 为 1 的时候﹐表示此封包的 Acknowledge Number 是有效的﹐也就是用来回应上一个封包。一般都会为 1。一般只有只有第一个封包没有设。</li>\n<li>Push function:如果 PSH 为 1 的时候﹐该封包连同传送缓衝区的其它封包应立即进行传送，而无需等待缓衝区满了才送。接收端必须儘快將此资料交给程式处理。</li>\n<li>Reset:如果 RST 为 1 的时候﹐连线会被马上结束，而无需等待终止確认手续。</li>\n<li>Synchronize sequence number:如果 SYN 为 1 时﹐表示要求双方进行同步处理﹐也就是要求建立连线。</li>\n<li>No more data fro sender (Finish):如果封包的 FIN 为 1 的时候﹐就表示传送结束﹐然后双方发出结束回应﹐进而正式进入 TCP 传送的终止流程。</li>\n</ul>\n<p><img src=\"/2019/12/15/网络基础/TCPHead.png\" alt=\"TCPHead\"><br>Sequence 和 Acknowledge 是 TCP 传送中的重要检测手段.<br><img src=\"/2019/12/15/网络基础/TCPTrans.png\" alt=\"TCPTrans\"><br><img src=\"/2019/12/15/网络基础/UDPHead.png\" alt=\"UDPHead\"><br>TCP 提供的是一个连线导向(Connection Oriented)的可靠传输.<br>UDP 则是一个非连线型(Connectionless)的非可靠传输协定﹐<br>它並不会运用確认机制来保证资料是否正確的被接收、<br>不需要重传遗失的资料、资料的接收可不必按顺序进行、<br>也不提供回传机制来控制资料流的速度。<br>因此﹐ UDP 信息可能会在网路传送过程中丟失﹑重复﹑或不依顺序﹐<br>而且抵达速度也可能比接收端的处理速度还快。</p>\n<ul>\n<li>TCP: 传送可靠,程序可省略可靠机制,但速度慢</li>\n<li>UDP: 传输量大,迅速,但是不可靠,需要程序自行提供可靠机制</li>\n</ul>\n<h1 id=\"CSMA-CD\"><a href=\"#CSMA-CD\" class=\"headerlink\" title=\"CSMA/CD\"></a>CSMA/CD</h1><p>乙太网路的传输协定 CSMA/CD (Carrier Sense Multiple Access with Collision Detection) </p>\n<p>虽然讯框会在整个网段(segment)中用广播的方式传递﹐而且所有节点都会收到讯框﹐<br>然而﹐只有目的位址符合自己实体位址的讯框才会被接收下来。<br>因此，不管上层协定是哪一种(可以是 TCP/IP 也可以是其它)，<br>在底层的传送若是使用 Ethernet 的话，就得使用 <strong>MAC (Media Access Control) </strong>实体位址.</p>\n<ol>\n<li><p>监听媒体使用情况 (Carrier Sense)：A 主机要发送网路封包前，需要先对网路媒体进行监听，<br>確认没有人在使用后， 才能够发送出讯框；</p>\n</li>\n<li><p>多点传输 (Multiple Access)：A 主机所送出的资料会被集线器复製一份，<br>然后传送给所有连接到此集线器的主机！ 也就是说， A 所送出的资料，<br>B, C, D 三部电脑都能够接收的到！但由於目標是 D 主机，因此 B 与 C 会將此讯框资料丟弃，而 D 则会抓下来处理；</p>\n</li>\n<li><p>碰撞侦测 (Collision Detection)：该讯框资料附有检测能力，<br>若其他主机例如 B 电脑也刚好在同时间发送讯框资料时，<br>那么 A 与 B 送出的资料碰撞在一块 (出车祸) ，此时这些讯框就是损毁，<br>那么 A 与 B 就会各自隨机等待一个时间， 然后重新透过第一步再传送一次该讯框资料。</p>\n</li>\n</ol>\n<p><img src=\"/2019/12/15/网络基础/csmacd.gif\" alt=\"CSMA/CD连线\"></p>\n<p>每张乙太网路卡出厂时，就会赋予一个独一无二的卡號，那就是所谓的 MAC (Media Access Control)</p>\n<ol>\n<li><p>HUB 单纯的是一个 repeater﹐当它从一个 port (和 TCP 协定的 port 不一样﹐这里<br>是指插网路线的接孔)接收信號进来之后﹐会將这个信號原原本本的送到所有其它<br>port 上﹐不管哪些 port 是接到哪一台机器。</p>\n</li>\n<li><p>而 switch 呢﹖它自己有一份 table﹐记录著哪个 port 接到哪些 MAC 位址设备上。<br>当信號从一个 port 进来之后﹐会检查这个 frame 的 destination 是哪个 MAC﹐然<br>后按 table 找到这个 MAC 对应的 port ﹐而仅將信號往这个 port 送﹐其它的 port<br>就不送了。</p>\n</li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE#CSMA/CD\" target=\"_blank\" rel=\"noopener\">载波侦听多路访问</a></li>\n<li><a href=\"http://linux.vbird.org/linux_server/0110network_basic.php#ps11\" target=\"_blank\" rel=\"noopener\">基础网络概念</a></li>\n<li><a href=\"http://www.study-area.org/network/networkfr2.htm\" target=\"_blank\" rel=\"noopener\">网络基础</a> </li>\n</ol>\n"},{"title":"雅克比矩阵零空间","date":"2020-02-19T03:10:14.000Z","mathjax":true,"_content":"\n先来看广义逆阵\n# 广义逆阵\n\n广义逆也称为伪逆（pseudoinverse），有些时候，伪逆特指摩尔－彭若斯广义逆(M-P逆)。\n\n## 种类\n彭若斯条件\n$$\n\\begin{aligned}\n&A A^{\\mathrm{g}} A=A\\\\\n&A^{\\mathrm{g}} A A^{\\mathrm{g}}=A^{g}\\\\\n&\\left(A A^{\\mathrm{g}}\\right)^{\\mathrm{T}}=A A^{\\mathrm{g}}\\\\\n&\\left(A^{\\mathrm{g}} A\\right)^{\\mathrm{T}}=A^{\\mathrm{g}} A\n\\end{aligned}\n$$\n\n若$${A^{\\rm{g}}}$$满足条件1,则为A的广义逆阵;满足条件1和2,则为A的广义反身逆阵;\n4个条件都满足则为摩尔-彭若斯逆(M-P逆)\n\n除此之外还有其他广义逆阵包括左侧逆阵,右侧逆阵等\n\n## 应用\n求解线性方程组  \n$$\\eqalign{\n  & Ax = b  \\cr \n  & x = {A^{\\rm{g}}}b + \\left[ {I - {A^{\\rm{g}}}A} \\right]w \\cr} $$  \n\n## M-P逆\n任意矩阵都存在M-P逆,且唯一,是应用最广泛的一种逆矩阵\n\n计算方法\n1. 满秩分解\n\n    $$\n    \\begin{aligned}\n    \\mathbf{A}=\\mathbf{B C}, \\mathbf{B} \\in \\mathbf{C}^{n \\times r}, \\mathbf{C} \\in \\mathbf{C}^{r \\times n}, & \\operatorname{rank}(\\mathbf{B})=\\operatorname{rank}(\\mathbf{C})=r \\\\\n    \\mathbf{A}^{+}=\\mathbf{C}^{\\mathrm{H}}\\left(\\mathbf{C} \\mathbf{C}^{\\mathrm{H}}\\right)^{-1}\\left(\\mathbf{B}^{\\mathrm{H}} \\mathbf{B}\\right)^{-1} \\mathbf{B}^{\\mathrm{H}}\n    \\end{aligned}\n    $$\n\n2. 奇异值分解svd\n    \n    $$\n    \\begin{aligned}\n    &A=U\\left(\\begin{array}{ll}\n    {\\Delta} & {0} \\\\\n    {0} & {0}\n    \\end{array}\\right) V^{H}\\\\\n    &A^{+}=V\\left(\\begin{array}{cc}\n    {\\Delta^{-1}} & {0} \\\\\n    {0} & {0}\n    \\end{array}\\right)^{\\mathrm{H}} U^{H}\n    \\end{aligned}\n    $$\n\n\n\n# 雅克比矩阵零空间\n雅克比矩阵是关节空间到笛卡尔空间(机械臂末端)的映射,求解方程得\n\n\n$$\\matrix{\n   {\\delta x = J\\delta q} \\hfill  \\cr \n   {\\delta q = {J^\\# }\\delta x + \\left[ {I - {J^\\# }J} \\right]\\delta {q_0}} \\hfill  \\cr \n } $$\n \n其中$${J^\\# }$$为J的伪逆矩阵,从这里可以看出对于冗余机械臂(此时雅克比矩阵具有零空间)\n可以在保证末端位置不变的情况下关节运动\n\n## 冗余机械臂关节空间力矩\n推导过程在pdf已经很详细了,这里摘取结论,资料出自[Advanced Robotic Manipulation](https://cs.stanford.edu/groups/manips/teaching/cs327a/)\n![冗余机械臂关节空间和任务空间](redundancy.png)\n![velocity_force](velocity_force.png)\n\n这里需要注意的是关节空间线性方程组求解时选择不同伪逆会有不同结果在pdf里面推导出来的逆是为了保证在对应零空间施加关节力矩不会影响操作空间加速度\n\n**不清楚的是[franka笛卡尔空间阻抗控制](https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp)\n以及这里使用的[矩阵求伪逆](https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/include/franka_example_controllers/pseudo_inversion.h)多了一个参数的作用**\n\n{% pdf Redundancy-19.pdf%}\n\n\n# 引用\n1. [维基百科:广义逆阵](https://zh.wikipedia.org/zh/%E5%B9%BF%E4%B9%89%E9%80%86%E9%98%B5#cite_note-James-4)\n2. [雅克比矩阵零空间](https://blog.csdn.net/u013528298/article/details/80558315)\n3. [ROBOT CONTROL PART 5: CONTROLLING IN THE NULL SPACE](https://studywolf.wordpress.com/2013/09/17/robot-control-5-controlling-in-the-null-space/)\n4. [冗余机器人以及雅克比伪逆矩阵](https://blog.csdn.net/u013528298/article/details/79952949)\n5. [斯坦福课程:Advanced Robotic Manipulation](https://cs.stanford.edu/groups/manips/teaching/cs327a/)\n6. 书籍:矩阵论 杨明 刘先忠 华中科技大学出版社\n","source":"_posts/雅克比矩阵零空间.md","raw":"---\ntitle: 雅克比矩阵零空间\ndate: 2020-02-19 11:10:14\ncategories:\n- math\ntags:\n- 雅克比矩阵\n- 伪逆\nmathjax: true\n\n---\n\n先来看广义逆阵\n# 广义逆阵\n\n广义逆也称为伪逆（pseudoinverse），有些时候，伪逆特指摩尔－彭若斯广义逆(M-P逆)。\n\n## 种类\n彭若斯条件\n$$\n\\begin{aligned}\n&A A^{\\mathrm{g}} A=A\\\\\n&A^{\\mathrm{g}} A A^{\\mathrm{g}}=A^{g}\\\\\n&\\left(A A^{\\mathrm{g}}\\right)^{\\mathrm{T}}=A A^{\\mathrm{g}}\\\\\n&\\left(A^{\\mathrm{g}} A\\right)^{\\mathrm{T}}=A^{\\mathrm{g}} A\n\\end{aligned}\n$$\n\n若$${A^{\\rm{g}}}$$满足条件1,则为A的广义逆阵;满足条件1和2,则为A的广义反身逆阵;\n4个条件都满足则为摩尔-彭若斯逆(M-P逆)\n\n除此之外还有其他广义逆阵包括左侧逆阵,右侧逆阵等\n\n## 应用\n求解线性方程组  \n$$\\eqalign{\n  & Ax = b  \\cr \n  & x = {A^{\\rm{g}}}b + \\left[ {I - {A^{\\rm{g}}}A} \\right]w \\cr} $$  \n\n## M-P逆\n任意矩阵都存在M-P逆,且唯一,是应用最广泛的一种逆矩阵\n\n计算方法\n1. 满秩分解\n\n    $$\n    \\begin{aligned}\n    \\mathbf{A}=\\mathbf{B C}, \\mathbf{B} \\in \\mathbf{C}^{n \\times r}, \\mathbf{C} \\in \\mathbf{C}^{r \\times n}, & \\operatorname{rank}(\\mathbf{B})=\\operatorname{rank}(\\mathbf{C})=r \\\\\n    \\mathbf{A}^{+}=\\mathbf{C}^{\\mathrm{H}}\\left(\\mathbf{C} \\mathbf{C}^{\\mathrm{H}}\\right)^{-1}\\left(\\mathbf{B}^{\\mathrm{H}} \\mathbf{B}\\right)^{-1} \\mathbf{B}^{\\mathrm{H}}\n    \\end{aligned}\n    $$\n\n2. 奇异值分解svd\n    \n    $$\n    \\begin{aligned}\n    &A=U\\left(\\begin{array}{ll}\n    {\\Delta} & {0} \\\\\n    {0} & {0}\n    \\end{array}\\right) V^{H}\\\\\n    &A^{+}=V\\left(\\begin{array}{cc}\n    {\\Delta^{-1}} & {0} \\\\\n    {0} & {0}\n    \\end{array}\\right)^{\\mathrm{H}} U^{H}\n    \\end{aligned}\n    $$\n\n\n\n# 雅克比矩阵零空间\n雅克比矩阵是关节空间到笛卡尔空间(机械臂末端)的映射,求解方程得\n\n\n$$\\matrix{\n   {\\delta x = J\\delta q} \\hfill  \\cr \n   {\\delta q = {J^\\# }\\delta x + \\left[ {I - {J^\\# }J} \\right]\\delta {q_0}} \\hfill  \\cr \n } $$\n \n其中$${J^\\# }$$为J的伪逆矩阵,从这里可以看出对于冗余机械臂(此时雅克比矩阵具有零空间)\n可以在保证末端位置不变的情况下关节运动\n\n## 冗余机械臂关节空间力矩\n推导过程在pdf已经很详细了,这里摘取结论,资料出自[Advanced Robotic Manipulation](https://cs.stanford.edu/groups/manips/teaching/cs327a/)\n![冗余机械臂关节空间和任务空间](redundancy.png)\n![velocity_force](velocity_force.png)\n\n这里需要注意的是关节空间线性方程组求解时选择不同伪逆会有不同结果在pdf里面推导出来的逆是为了保证在对应零空间施加关节力矩不会影响操作空间加速度\n\n**不清楚的是[franka笛卡尔空间阻抗控制](https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp)\n以及这里使用的[矩阵求伪逆](https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/include/franka_example_controllers/pseudo_inversion.h)多了一个参数的作用**\n\n{% pdf Redundancy-19.pdf%}\n\n\n# 引用\n1. [维基百科:广义逆阵](https://zh.wikipedia.org/zh/%E5%B9%BF%E4%B9%89%E9%80%86%E9%98%B5#cite_note-James-4)\n2. [雅克比矩阵零空间](https://blog.csdn.net/u013528298/article/details/80558315)\n3. [ROBOT CONTROL PART 5: CONTROLLING IN THE NULL SPACE](https://studywolf.wordpress.com/2013/09/17/robot-control-5-controlling-in-the-null-space/)\n4. [冗余机器人以及雅克比伪逆矩阵](https://blog.csdn.net/u013528298/article/details/79952949)\n5. [斯坦福课程:Advanced Robotic Manipulation](https://cs.stanford.edu/groups/manips/teaching/cs327a/)\n6. 书籍:矩阵论 杨明 刘先忠 华中科技大学出版社\n","slug":"雅克比矩阵零空间","published":1,"updated":"2020-09-23T14:42:00.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjm0073mxka16di8yew","content":"<p>先来看广义逆阵</p>\n<h1 id=\"广义逆阵\"><a href=\"#广义逆阵\" class=\"headerlink\" title=\"广义逆阵\"></a>广义逆阵</h1><p>广义逆也称为伪逆（pseudoinverse），有些时候，伪逆特指摩尔－彭若斯广义逆(M-P逆)。</p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><p>彭若斯条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&A A^{\\mathrm{g}} A=A\\\\\n&A^{\\mathrm{g}} A A^{\\mathrm{g}}=A^{g}\\\\\n&\\left(A A^{\\mathrm{g}}\\right)^{\\mathrm{T}}=A A^{\\mathrm{g}}\\\\\n&\\left(A^{\\mathrm{g}} A\\right)^{\\mathrm{T}}=A^{\\mathrm{g}} A\n\\end{aligned}</script><p>若<script type=\"math/tex\">{A^{\\rm{g}}}</script>满足条件1,则为A的广义逆阵;满足条件1和2,则为A的广义反身逆阵;<br>4个条件都满足则为摩尔-彭若斯逆(M-P逆)</p>\n<p>除此之外还有其他广义逆阵包括左侧逆阵,右侧逆阵等</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>求解线性方程组  </p>\n<script type=\"math/tex; mode=display\">\\eqalign{\n  & Ax = b  \\cr \n  & x = {A^{\\rm{g}}}b + \\left[ {I - {A^{\\rm{g}}}A} \\right]w \\cr}</script><h2 id=\"M-P逆\"><a href=\"#M-P逆\" class=\"headerlink\" title=\"M-P逆\"></a>M-P逆</h2><p>任意矩阵都存在M-P逆,且唯一,是应用最广泛的一种逆矩阵</p>\n<p>计算方法</p>\n<ol>\n<li><p>满秩分解</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n \\mathbf{A}=\\mathbf{B C}, \\mathbf{B} \\in \\mathbf{C}^{n \\times r}, \\mathbf{C} \\in \\mathbf{C}^{r \\times n}, & \\operatorname{rank}(\\mathbf{B})=\\operatorname{rank}(\\mathbf{C})=r \\\\\n \\mathbf{A}^{+}=\\mathbf{C}^{\\mathrm{H}}\\left(\\mathbf{C} \\mathbf{C}^{\\mathrm{H}}\\right)^{-1}\\left(\\mathbf{B}^{\\mathrm{H}} \\mathbf{B}\\right)^{-1} \\mathbf{B}^{\\mathrm{H}}\n \\end{aligned}</script></li>\n<li><p>奇异值分解svd</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n &A=U\\left(\\begin{array}{ll}\n {\\Delta} & {0} \\\\\n {0} & {0}\n \\end{array}\\right) V^{H}\\\\\n &A^{+}=V\\left(\\begin{array}{cc}\n {\\Delta^{-1}} & {0} \\\\\n {0} & {0}\n \\end{array}\\right)^{\\mathrm{H}} U^{H}\n \\end{aligned}</script></li>\n</ol>\n<h1 id=\"雅克比矩阵零空间\"><a href=\"#雅克比矩阵零空间\" class=\"headerlink\" title=\"雅克比矩阵零空间\"></a>雅克比矩阵零空间</h1><p>雅克比矩阵是关节空间到笛卡尔空间(机械臂末端)的映射,求解方程得</p>\n<script type=\"math/tex; mode=display\">\\matrix{\n   {\\delta x = J\\delta q} \\hfill  \\cr \n   {\\delta q = {J^\\# }\\delta x + \\left[ {I - {J^\\# }J} \\right]\\delta {q_0}} \\hfill  \\cr \n }</script><p>其中<script type=\"math/tex\">{J^\\# }</script>为J的伪逆矩阵,从这里可以看出对于冗余机械臂(此时雅克比矩阵具有零空间)<br>可以在保证末端位置不变的情况下关节运动</p>\n<h2 id=\"冗余机械臂关节空间力矩\"><a href=\"#冗余机械臂关节空间力矩\" class=\"headerlink\" title=\"冗余机械臂关节空间力矩\"></a>冗余机械臂关节空间力矩</h2><p>推导过程在pdf已经很详细了,这里摘取结论,资料出自<a href=\"https://cs.stanford.edu/groups/manips/teaching/cs327a/\" target=\"_blank\" rel=\"noopener\">Advanced Robotic Manipulation</a><br><img src=\"/2020/02/19/雅克比矩阵零空间/redundancy.png\" alt=\"冗余机械臂关节空间和任务空间\"><br><img src=\"/2020/02/19/雅克比矩阵零空间/velocity_force.png\" alt=\"velocity_force\"></p>\n<p>这里需要注意的是关节空间线性方程组求解时选择不同伪逆会有不同结果在pdf里面推导出来的逆是为了保证在对应零空间施加关节力矩不会影响操作空间加速度</p>\n<p><strong>不清楚的是<a href=\"https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp\" target=\"_blank\" rel=\"noopener\">franka笛卡尔空间阻抗控制</a><br>以及这里使用的<a href=\"https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/include/franka_example_controllers/pseudo_inversion.h\" target=\"_blank\" rel=\"noopener\">矩阵求伪逆</a>多了一个参数的作用</strong></p>\n\n\n\t<div class=\"row\">\n    <embed src=\"Redundancy-19.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/zh/%E5%B9%BF%E4%B9%89%E9%80%86%E9%98%B5#cite_note-James-4\" target=\"_blank\" rel=\"noopener\">维基百科:广义逆阵</a></li>\n<li><a href=\"https://blog.csdn.net/u013528298/article/details/80558315\" target=\"_blank\" rel=\"noopener\">雅克比矩阵零空间</a></li>\n<li><a href=\"https://studywolf.wordpress.com/2013/09/17/robot-control-5-controlling-in-the-null-space/\" target=\"_blank\" rel=\"noopener\">ROBOT CONTROL PART 5: CONTROLLING IN THE NULL SPACE</a></li>\n<li><a href=\"https://blog.csdn.net/u013528298/article/details/79952949\" target=\"_blank\" rel=\"noopener\">冗余机器人以及雅克比伪逆矩阵</a></li>\n<li><a href=\"https://cs.stanford.edu/groups/manips/teaching/cs327a/\" target=\"_blank\" rel=\"noopener\">斯坦福课程:Advanced Robotic Manipulation</a></li>\n<li>书籍:矩阵论 杨明 刘先忠 华中科技大学出版社</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>先来看广义逆阵</p>\n<h1 id=\"广义逆阵\"><a href=\"#广义逆阵\" class=\"headerlink\" title=\"广义逆阵\"></a>广义逆阵</h1><p>广义逆也称为伪逆（pseudoinverse），有些时候，伪逆特指摩尔－彭若斯广义逆(M-P逆)。</p>\n<h2 id=\"种类\"><a href=\"#种类\" class=\"headerlink\" title=\"种类\"></a>种类</h2><p>彭若斯条件</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&A A^{\\mathrm{g}} A=A\\\\\n&A^{\\mathrm{g}} A A^{\\mathrm{g}}=A^{g}\\\\\n&\\left(A A^{\\mathrm{g}}\\right)^{\\mathrm{T}}=A A^{\\mathrm{g}}\\\\\n&\\left(A^{\\mathrm{g}} A\\right)^{\\mathrm{T}}=A^{\\mathrm{g}} A\n\\end{aligned}</script><p>若<script type=\"math/tex\">{A^{\\rm{g}}}</script>满足条件1,则为A的广义逆阵;满足条件1和2,则为A的广义反身逆阵;<br>4个条件都满足则为摩尔-彭若斯逆(M-P逆)</p>\n<p>除此之外还有其他广义逆阵包括左侧逆阵,右侧逆阵等</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>求解线性方程组  </p>\n<script type=\"math/tex; mode=display\">\\eqalign{\n  & Ax = b  \\cr \n  & x = {A^{\\rm{g}}}b + \\left[ {I - {A^{\\rm{g}}}A} \\right]w \\cr}</script><h2 id=\"M-P逆\"><a href=\"#M-P逆\" class=\"headerlink\" title=\"M-P逆\"></a>M-P逆</h2><p>任意矩阵都存在M-P逆,且唯一,是应用最广泛的一种逆矩阵</p>\n<p>计算方法</p>\n<ol>\n<li><p>满秩分解</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n \\mathbf{A}=\\mathbf{B C}, \\mathbf{B} \\in \\mathbf{C}^{n \\times r}, \\mathbf{C} \\in \\mathbf{C}^{r \\times n}, & \\operatorname{rank}(\\mathbf{B})=\\operatorname{rank}(\\mathbf{C})=r \\\\\n \\mathbf{A}^{+}=\\mathbf{C}^{\\mathrm{H}}\\left(\\mathbf{C} \\mathbf{C}^{\\mathrm{H}}\\right)^{-1}\\left(\\mathbf{B}^{\\mathrm{H}} \\mathbf{B}\\right)^{-1} \\mathbf{B}^{\\mathrm{H}}\n \\end{aligned}</script></li>\n<li><p>奇异值分解svd</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n &A=U\\left(\\begin{array}{ll}\n {\\Delta} & {0} \\\\\n {0} & {0}\n \\end{array}\\right) V^{H}\\\\\n &A^{+}=V\\left(\\begin{array}{cc}\n {\\Delta^{-1}} & {0} \\\\\n {0} & {0}\n \\end{array}\\right)^{\\mathrm{H}} U^{H}\n \\end{aligned}</script></li>\n</ol>\n<h1 id=\"雅克比矩阵零空间\"><a href=\"#雅克比矩阵零空间\" class=\"headerlink\" title=\"雅克比矩阵零空间\"></a>雅克比矩阵零空间</h1><p>雅克比矩阵是关节空间到笛卡尔空间(机械臂末端)的映射,求解方程得</p>\n<script type=\"math/tex; mode=display\">\\matrix{\n   {\\delta x = J\\delta q} \\hfill  \\cr \n   {\\delta q = {J^\\# }\\delta x + \\left[ {I - {J^\\# }J} \\right]\\delta {q_0}} \\hfill  \\cr \n }</script><p>其中<script type=\"math/tex\">{J^\\# }</script>为J的伪逆矩阵,从这里可以看出对于冗余机械臂(此时雅克比矩阵具有零空间)<br>可以在保证末端位置不变的情况下关节运动</p>\n<h2 id=\"冗余机械臂关节空间力矩\"><a href=\"#冗余机械臂关节空间力矩\" class=\"headerlink\" title=\"冗余机械臂关节空间力矩\"></a>冗余机械臂关节空间力矩</h2><p>推导过程在pdf已经很详细了,这里摘取结论,资料出自<a href=\"https://cs.stanford.edu/groups/manips/teaching/cs327a/\" target=\"_blank\" rel=\"noopener\">Advanced Robotic Manipulation</a><br><img src=\"/2020/02/19/雅克比矩阵零空间/redundancy.png\" alt=\"冗余机械臂关节空间和任务空间\"><br><img src=\"/2020/02/19/雅克比矩阵零空间/velocity_force.png\" alt=\"velocity_force\"></p>\n<p>这里需要注意的是关节空间线性方程组求解时选择不同伪逆会有不同结果在pdf里面推导出来的逆是为了保证在对应零空间施加关节力矩不会影响操作空间加速度</p>\n<p><strong>不清楚的是<a href=\"https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/src/cartesian_impedance_example_controller.cpp\" target=\"_blank\" rel=\"noopener\">franka笛卡尔空间阻抗控制</a><br>以及这里使用的<a href=\"https://github.com/frankaemika/franka_ros/blob/kinetic-devel/franka_example_controllers/include/franka_example_controllers/pseudo_inversion.h\" target=\"_blank\" rel=\"noopener\">矩阵求伪逆</a>多了一个参数的作用</strong></p>\n\n\n\t<div class=\"row\">\n    <embed src=\"Redundancy-19.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://zh.wikipedia.org/zh/%E5%B9%BF%E4%B9%89%E9%80%86%E9%98%B5#cite_note-James-4\" target=\"_blank\" rel=\"noopener\">维基百科:广义逆阵</a></li>\n<li><a href=\"https://blog.csdn.net/u013528298/article/details/80558315\" target=\"_blank\" rel=\"noopener\">雅克比矩阵零空间</a></li>\n<li><a href=\"https://studywolf.wordpress.com/2013/09/17/robot-control-5-controlling-in-the-null-space/\" target=\"_blank\" rel=\"noopener\">ROBOT CONTROL PART 5: CONTROLLING IN THE NULL SPACE</a></li>\n<li><a href=\"https://blog.csdn.net/u013528298/article/details/79952949\" target=\"_blank\" rel=\"noopener\">冗余机器人以及雅克比伪逆矩阵</a></li>\n<li><a href=\"https://cs.stanford.edu/groups/manips/teaching/cs327a/\" target=\"_blank\" rel=\"noopener\">斯坦福课程:Advanced Robotic Manipulation</a></li>\n<li>书籍:矩阵论 杨明 刘先忠 华中科技大学出版社</li>\n</ol>\n"},{"title":"高效工具","date":"2019-11-30T14:07:24.000Z","_content":"\n# 截图识别公式\n[mathpix](https://mathpix.com/) 一款优秀的截图识别公式软件,支持Linux,Windows,Mac,IOS,Android\nubuntu 安装\n    \n    sudo apt update\n    sudo apt install snapd\n    sudo snap install mathpix-snipping-tool\n\n\n\n","source":"_posts/高效工具.md","raw":"---\ntitle: 高效工具\ndate: 2019-11-30 22:07:24\ncategories:\n- software\ntags:\n- efficiency\n---\n\n# 截图识别公式\n[mathpix](https://mathpix.com/) 一款优秀的截图识别公式软件,支持Linux,Windows,Mac,IOS,Android\nubuntu 安装\n    \n    sudo apt update\n    sudo apt install snapd\n    sudo snap install mathpix-snipping-tool\n\n\n\n","slug":"高效工具","published":1,"updated":"2020-09-23T14:42:00.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjn0076mxkaac491axk","content":"<h1 id=\"截图识别公式\"><a href=\"#截图识别公式\" class=\"headerlink\" title=\"截图识别公式\"></a>截图识别公式</h1><p><a href=\"https://mathpix.com/\" target=\"_blank\" rel=\"noopener\">mathpix</a> 一款优秀的截图识别公式软件,支持Linux,Windows,Mac,IOS,Android<br>ubuntu 安装</p>\n<pre><code>sudo apt update\nsudo apt install snapd\nsudo snap install mathpix-snipping-tool\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"截图识别公式\"><a href=\"#截图识别公式\" class=\"headerlink\" title=\"截图识别公式\"></a>截图识别公式</h1><p><a href=\"https://mathpix.com/\" target=\"_blank\" rel=\"noopener\">mathpix</a> 一款优秀的截图识别公式软件,支持Linux,Windows,Mac,IOS,Android<br>ubuntu 安装</p>\n<pre><code>sudo apt update\nsudo apt install snapd\nsudo snap install mathpix-snipping-tool\n</code></pre>"},{"title":"高斯分布","date":"2019-10-16T05:30:27.000Z","mathjax":true,"_content":"# 高斯分布表达式\n### 一元高斯分布\n\n$$\n\\mathcal{N}\\left(x | \\mu, \\sigma^{2}\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2 \\sigma^{2}}(x-\\mu)^{2}\\right\\}\n$$\n\n### 多元高斯分布\n\n$$\n\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\mathbf{\\Sigma})=\\frac{1}{(2 \\pi)^{\\frac{D}{2}}} \\frac{1}{|\\boldsymbol{\\Sigma}|^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right\\}\n$$\n# 性质\n高斯分布依赖于下面二次型，即马氏距离\n$$\n\\Delta^{2}=(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\n$$\n\n协方差矩阵$\\sum $可以取对称矩阵，**任何非对称项都会从指数中消失**（也可以从协方差矩阵定义看）可分解成对角矩阵\n\n$$\n$$\n\\begin{array}{l}{\\Delta^{2}=[(\\vec{X}-\\vec{\\mu})]^{\\top}\\left(Q \\Lambda Q^{\\top}\\right)^{-1}[(\\vec{X}-\\vec{\\mu})]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top} \\Lambda^{-1}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left(\\Lambda^{-\\frac{1}{2}}\\right)^{\\top} \\Lambda^{-\\frac{1}{2}}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\begin{array}{c}{\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})}\\end{array}\\right]} \\\\ {=\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]}\\end{array}\n$$\n$$\n含义：高斯分布中心在u,平移u之后高斯分布中心到原点，高斯分布椭圆轴拉伸变换成正圆，称一个旋转矩阵，将之前椭圆轴方向旋转到全局坐标系(Oxyz)，特别注意：变换矩阵Q\n\n椭圆中心u,轴方向：变换矩阵Q的列向量\n![高斯分布](高斯分布.png)\n\n# 条件高斯分布\n多元⾼斯分布的⼀个重要性质是，如果两组变量是联合⾼斯分布，那么以⼀组变量为条件，\n另⼀组变量同样是⾼斯分布。类似地，任何⼀个变量的边缘分布也是⾼斯分布\n## 协方差矩阵&精度矩阵&分块矩阵求逆\n$$\n\\Sigma=\\left(\\begin{array}{cc}{\\Sigma_{a a}} & {\\Sigma_{a b}} \\\\ {\\Sigma_{b a}} & {\\Sigma_{b b}}\\end{array}\\right), \\quad A=\\left(\\begin{array}{cc}{A_{a}} & {A_{b}} \\\\ {A_{b a}} & {A_{b b}}\\end{array}\\right), A=\\Sigma^{-}\n$$\n分块矩阵求逆\n$$\n\\left(\\begin{array}{cc}{\\boldsymbol{A}} & {\\boldsymbol{B}} \\\\ {\\boldsymbol{C}} & {\\boldsymbol{D}}\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}{\\boldsymbol{M}} & {-\\boldsymbol{M B D}^{-1}} \\\\ {-\\boldsymbol{D}^{-1} \\boldsymbol{C M}} & {\\boldsymbol{D}^{-1}+\\boldsymbol{D}^{-1} \\boldsymbol{C M B D}^{-1}}\\end{array}\\right)\n$$\n其中 $M=\\left(A-B D^{-1} C\\right)^{-}$\n## 完全平方项\n通过对比二次型找到均值何方差的表达式\n\n分解式如下\n$$\n\\begin{aligned}-\\frac{1}{2}(& \\boldsymbol{x}-\\boldsymbol{\\mu}^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=\\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}\n$$\n二次型\n$$\n-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=-\\frac{1}{2} \\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{x}+\\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}+\\text {const}_{-} \\text {value}\n$$\n\n条件概率均值和协方差\n$$\n\\begin{array}{l}{\\mu_{a b}=\\mu_{a}+\\Sigma_{a b} \\Sigma_{b b}^{-1}\\left(x_{b}-\\mu_{b}\\right)=\\mu_{a}-H_{a b}^{-1} A_{b b}\\left(x_{b}-\\mu_{b}\\right)} \\\\ {\\Sigma_{a b}=\\Sigma_{a a}-\\Sigma_{a b} \\Sigma_{b b}^{-1} \\Sigma_{b a}=\\Lambda_{b b}^{-1}}\\end{array}\n$$\n\n# 边缘高斯分布\n$$\np\\left(\\boldsymbol{x}_{a}\\right)=\\int p\\left(\\boldsymbol{x}_{a}, \\boldsymbol{x}_{b}\\right) \\mathrm{d} \\boldsymbol{x}_{b}\n$$\n\n分解式对变量Xb积分\n\n关于Xb的项\n$$\n-\\frac{1}{2} \\boldsymbol{x}_{b}^{T} \\boldsymbol{\\Lambda}_{b b} \\boldsymbol{x}_{b}+\\boldsymbol{x}_{b}^{T} \\boldsymbol{m}=-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)+\\frac{1}{2} \\boldsymbol{m}^{T} \\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\n$$\n\n其中 $\\boldsymbol{m}=\\boldsymbol{\\Lambda}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)$\n容易求得变量的积分 现在看剩余部分变量Xa和常量\n$$\n\\begin{array}{l}{\\frac{1}{2}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]^{T} \\boldsymbol{A}_{b b}^{-1}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]-\\frac{1}{2} \\boldsymbol{x}_{a}^{T} \\boldsymbol{\\Lambda}_{a a} \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a} \\boldsymbol{\\mu}_{a}+\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}\\right)+\\text {const}_{-} \\text {value}} \\\\ {=-\\frac{1}{2} \\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a}-\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{h}_{b a}\\right) \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{A}_{b a}\\right) \\boldsymbol{\\mu}_{a}+\\text {const}_{-} \\text {value }}\\end{array}\n$$\n\n通过对比得\n$$\n\\begin{aligned} \\mathbb{E}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\mu}_{a} \\\\ \\operatorname{cov}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\Sigma}_{a a} \\end{aligned}\n$$\n\n## 总结\n对联合高斯分布\n$$\n\\begin{array}{l}{\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\Sigma)} \\\\ {x=\\left(\\begin{array}{l}{x_{a}} \\\\ {x_{b}}\\end{array}\\right), u=\\left(\\begin{array}{l}{\\boldsymbol{\\mu}_{a}} \\\\ {\\boldsymbol{\\mu}_{b}}\\end{array}\\right)} \\\\ {\\boldsymbol{\\Sigma}=\\left(\\begin{array}{cc}{\\boldsymbol{\\Sigma}_{a a}} & {\\boldsymbol{\\Sigma}_{a b}} \\\\ {\\boldsymbol{\\Sigma}_{b a}} & {\\boldsymbol{\\Sigma}_{b b}}\\end{array}\\right), \\quad \\boldsymbol{A}=\\left(\\begin{array}{cc}{\\boldsymbol{A}_{a a}} & {\\boldsymbol{A}_{b b}} \\\\ {\\boldsymbol{A}_{b a}} & {\\boldsymbol{A}_{b b}}\\end{array}\\right), \\boldsymbol{A}=\\boldsymbol{\\Sigma}^{-}}\\end{array}\n$$\n\n条件概率\n$$\n\\begin{aligned} p\\left(\\boldsymbol{x}_{a} | \\boldsymbol{x}_{b}\\right) &=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a | b}, \\mathbf{\\Lambda}_{a a}^{-1}\\right) \\\\ \\boldsymbol{\\mu}_{a | b} &=\\boldsymbol{\\mu}_{a}-\\boldsymbol{\\Lambda}_{a a}^{-1} \\mathbf{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}\n$$\n\n边缘概率\n$$\np\\left(\\boldsymbol{x}_{a}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a}, \\boldsymbol{\\Sigma}_{a a}\\right)\n$$\n![条件概率和边缘概率](条件边缘.png)\n\n# 引用\n1. [Pattern Recognition and Machine Learning](https://www.microsoft.com/en-us/research/people/cmbishop/)\n2. [多元高斯分布完全解析](https://zhuanlan.zhihu.com/p/58987388)","source":"_posts/高斯分布.md","raw":"---\ntitle: 高斯分布\ndate: 2019-10-16 13:30:27\ncategories:\n- math\ntags:\n- 概率论\nmathjax: true\n\n---\n# 高斯分布表达式\n### 一元高斯分布\n\n$$\n\\mathcal{N}\\left(x | \\mu, \\sigma^{2}\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2 \\sigma^{2}}(x-\\mu)^{2}\\right\\}\n$$\n\n### 多元高斯分布\n\n$$\n\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\mathbf{\\Sigma})=\\frac{1}{(2 \\pi)^{\\frac{D}{2}}} \\frac{1}{|\\boldsymbol{\\Sigma}|^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right\\}\n$$\n# 性质\n高斯分布依赖于下面二次型，即马氏距离\n$$\n\\Delta^{2}=(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\n$$\n\n协方差矩阵$\\sum $可以取对称矩阵，**任何非对称项都会从指数中消失**（也可以从协方差矩阵定义看）可分解成对角矩阵\n\n$$\n$$\n\\begin{array}{l}{\\Delta^{2}=[(\\vec{X}-\\vec{\\mu})]^{\\top}\\left(Q \\Lambda Q^{\\top}\\right)^{-1}[(\\vec{X}-\\vec{\\mu})]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top} \\Lambda^{-1}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left(\\Lambda^{-\\frac{1}{2}}\\right)^{\\top} \\Lambda^{-\\frac{1}{2}}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\begin{array}{c}{\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})}\\end{array}\\right]} \\\\ {=\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]}\\end{array}\n$$\n$$\n含义：高斯分布中心在u,平移u之后高斯分布中心到原点，高斯分布椭圆轴拉伸变换成正圆，称一个旋转矩阵，将之前椭圆轴方向旋转到全局坐标系(Oxyz)，特别注意：变换矩阵Q\n\n椭圆中心u,轴方向：变换矩阵Q的列向量\n![高斯分布](高斯分布.png)\n\n# 条件高斯分布\n多元⾼斯分布的⼀个重要性质是，如果两组变量是联合⾼斯分布，那么以⼀组变量为条件，\n另⼀组变量同样是⾼斯分布。类似地，任何⼀个变量的边缘分布也是⾼斯分布\n## 协方差矩阵&精度矩阵&分块矩阵求逆\n$$\n\\Sigma=\\left(\\begin{array}{cc}{\\Sigma_{a a}} & {\\Sigma_{a b}} \\\\ {\\Sigma_{b a}} & {\\Sigma_{b b}}\\end{array}\\right), \\quad A=\\left(\\begin{array}{cc}{A_{a}} & {A_{b}} \\\\ {A_{b a}} & {A_{b b}}\\end{array}\\right), A=\\Sigma^{-}\n$$\n分块矩阵求逆\n$$\n\\left(\\begin{array}{cc}{\\boldsymbol{A}} & {\\boldsymbol{B}} \\\\ {\\boldsymbol{C}} & {\\boldsymbol{D}}\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}{\\boldsymbol{M}} & {-\\boldsymbol{M B D}^{-1}} \\\\ {-\\boldsymbol{D}^{-1} \\boldsymbol{C M}} & {\\boldsymbol{D}^{-1}+\\boldsymbol{D}^{-1} \\boldsymbol{C M B D}^{-1}}\\end{array}\\right)\n$$\n其中 $M=\\left(A-B D^{-1} C\\right)^{-}$\n## 完全平方项\n通过对比二次型找到均值何方差的表达式\n\n分解式如下\n$$\n\\begin{aligned}-\\frac{1}{2}(& \\boldsymbol{x}-\\boldsymbol{\\mu}^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=\\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}\n$$\n二次型\n$$\n-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=-\\frac{1}{2} \\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{x}+\\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}+\\text {const}_{-} \\text {value}\n$$\n\n条件概率均值和协方差\n$$\n\\begin{array}{l}{\\mu_{a b}=\\mu_{a}+\\Sigma_{a b} \\Sigma_{b b}^{-1}\\left(x_{b}-\\mu_{b}\\right)=\\mu_{a}-H_{a b}^{-1} A_{b b}\\left(x_{b}-\\mu_{b}\\right)} \\\\ {\\Sigma_{a b}=\\Sigma_{a a}-\\Sigma_{a b} \\Sigma_{b b}^{-1} \\Sigma_{b a}=\\Lambda_{b b}^{-1}}\\end{array}\n$$\n\n# 边缘高斯分布\n$$\np\\left(\\boldsymbol{x}_{a}\\right)=\\int p\\left(\\boldsymbol{x}_{a}, \\boldsymbol{x}_{b}\\right) \\mathrm{d} \\boldsymbol{x}_{b}\n$$\n\n分解式对变量Xb积分\n\n关于Xb的项\n$$\n-\\frac{1}{2} \\boldsymbol{x}_{b}^{T} \\boldsymbol{\\Lambda}_{b b} \\boldsymbol{x}_{b}+\\boldsymbol{x}_{b}^{T} \\boldsymbol{m}=-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)+\\frac{1}{2} \\boldsymbol{m}^{T} \\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\n$$\n\n其中 $\\boldsymbol{m}=\\boldsymbol{\\Lambda}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)$\n容易求得变量的积分 现在看剩余部分变量Xa和常量\n$$\n\\begin{array}{l}{\\frac{1}{2}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]^{T} \\boldsymbol{A}_{b b}^{-1}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]-\\frac{1}{2} \\boldsymbol{x}_{a}^{T} \\boldsymbol{\\Lambda}_{a a} \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a} \\boldsymbol{\\mu}_{a}+\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}\\right)+\\text {const}_{-} \\text {value}} \\\\ {=-\\frac{1}{2} \\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a}-\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{h}_{b a}\\right) \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{A}_{b a}\\right) \\boldsymbol{\\mu}_{a}+\\text {const}_{-} \\text {value }}\\end{array}\n$$\n\n通过对比得\n$$\n\\begin{aligned} \\mathbb{E}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\mu}_{a} \\\\ \\operatorname{cov}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\Sigma}_{a a} \\end{aligned}\n$$\n\n## 总结\n对联合高斯分布\n$$\n\\begin{array}{l}{\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\Sigma)} \\\\ {x=\\left(\\begin{array}{l}{x_{a}} \\\\ {x_{b}}\\end{array}\\right), u=\\left(\\begin{array}{l}{\\boldsymbol{\\mu}_{a}} \\\\ {\\boldsymbol{\\mu}_{b}}\\end{array}\\right)} \\\\ {\\boldsymbol{\\Sigma}=\\left(\\begin{array}{cc}{\\boldsymbol{\\Sigma}_{a a}} & {\\boldsymbol{\\Sigma}_{a b}} \\\\ {\\boldsymbol{\\Sigma}_{b a}} & {\\boldsymbol{\\Sigma}_{b b}}\\end{array}\\right), \\quad \\boldsymbol{A}=\\left(\\begin{array}{cc}{\\boldsymbol{A}_{a a}} & {\\boldsymbol{A}_{b b}} \\\\ {\\boldsymbol{A}_{b a}} & {\\boldsymbol{A}_{b b}}\\end{array}\\right), \\boldsymbol{A}=\\boldsymbol{\\Sigma}^{-}}\\end{array}\n$$\n\n条件概率\n$$\n\\begin{aligned} p\\left(\\boldsymbol{x}_{a} | \\boldsymbol{x}_{b}\\right) &=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a | b}, \\mathbf{\\Lambda}_{a a}^{-1}\\right) \\\\ \\boldsymbol{\\mu}_{a | b} &=\\boldsymbol{\\mu}_{a}-\\boldsymbol{\\Lambda}_{a a}^{-1} \\mathbf{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}\n$$\n\n边缘概率\n$$\np\\left(\\boldsymbol{x}_{a}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a}, \\boldsymbol{\\Sigma}_{a a}\\right)\n$$\n![条件概率和边缘概率](条件边缘.png)\n\n# 引用\n1. [Pattern Recognition and Machine Learning](https://www.microsoft.com/en-us/research/people/cmbishop/)\n2. [多元高斯分布完全解析](https://zhuanlan.zhihu.com/p/58987388)","slug":"高斯分布","published":1,"updated":"2019-10-23T13:23:07.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3cjp0079mxkay3d9n215","content":"<h1 id=\"高斯分布表达式\"><a href=\"#高斯分布表达式\" class=\"headerlink\" title=\"高斯分布表达式\"></a>高斯分布表达式</h1><h3 id=\"一元高斯分布\"><a href=\"#一元高斯分布\" class=\"headerlink\" title=\"一元高斯分布\"></a>一元高斯分布</h3><script type=\"math/tex; mode=display\">\n\\mathcal{N}\\left(x | \\mu, \\sigma^{2}\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2 \\sigma^{2}}(x-\\mu)^{2}\\right\\}</script><h3 id=\"多元高斯分布\"><a href=\"#多元高斯分布\" class=\"headerlink\" title=\"多元高斯分布\"></a>多元高斯分布</h3><script type=\"math/tex; mode=display\">\n\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\mathbf{\\Sigma})=\\frac{1}{(2 \\pi)^{\\frac{D}{2}}} \\frac{1}{|\\boldsymbol{\\Sigma}|^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right\\}</script><h1 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h1><p>高斯分布依赖于下面二次型，即马氏距离</p>\n<script type=\"math/tex; mode=display\">\n\\Delta^{2}=(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})</script><p>协方差矩阵$\\sum $可以取对称矩阵，<strong>任何非对称项都会从指数中消失</strong>（也可以从协方差矩阵定义看）可分解成对角矩阵</p>\n<script type=\"math/tex; mode=display\">\n</script><p>\\begin{array}{l}{\\Delta^{2}=[(\\vec{X}-\\vec{\\mu})]^{\\top}\\left(Q \\Lambda Q^{\\top}\\right)^{-1}[(\\vec{X}-\\vec{\\mu})]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top} \\Lambda^{-1}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left(\\Lambda^{-\\frac{1}{2}}\\right)^{\\top} \\Lambda^{-\\frac{1}{2}}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\begin{array}{c}{\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})}\\end{array}\\right]} \\\\ {=\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]}\\end{array}</p>\n<script type=\"math/tex; mode=display\">\n</script><p>含义：高斯分布中心在u,平移u之后高斯分布中心到原点，高斯分布椭圆轴拉伸变换成正圆，称一个旋转矩阵，将之前椭圆轴方向旋转到全局坐标系(Oxyz)，特别注意：变换矩阵Q</p>\n<p>椭圆中心u,轴方向：变换矩阵Q的列向量<br><img src=\"/2019/10/16/高斯分布/高斯分布.png\" alt=\"高斯分布\"></p>\n<h1 id=\"条件高斯分布\"><a href=\"#条件高斯分布\" class=\"headerlink\" title=\"条件高斯分布\"></a>条件高斯分布</h1><p>多元⾼斯分布的⼀个重要性质是，如果两组变量是联合⾼斯分布，那么以⼀组变量为条件，<br>另⼀组变量同样是⾼斯分布。类似地，任何⼀个变量的边缘分布也是⾼斯分布</p>\n<h2 id=\"协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆\"><a href=\"#协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆\" class=\"headerlink\" title=\"协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆\"></a>协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆</h2><script type=\"math/tex; mode=display\">\n\\Sigma=\\left(\\begin{array}{cc}{\\Sigma_{a a}} & {\\Sigma_{a b}} \\\\ {\\Sigma_{b a}} & {\\Sigma_{b b}}\\end{array}\\right), \\quad A=\\left(\\begin{array}{cc}{A_{a}} & {A_{b}} \\\\ {A_{b a}} & {A_{b b}}\\end{array}\\right), A=\\Sigma^{-}</script><p>分块矩阵求逆</p>\n<script type=\"math/tex; mode=display\">\n\\left(\\begin{array}{cc}{\\boldsymbol{A}} & {\\boldsymbol{B}} \\\\ {\\boldsymbol{C}} & {\\boldsymbol{D}}\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}{\\boldsymbol{M}} & {-\\boldsymbol{M B D}^{-1}} \\\\ {-\\boldsymbol{D}^{-1} \\boldsymbol{C M}} & {\\boldsymbol{D}^{-1}+\\boldsymbol{D}^{-1} \\boldsymbol{C M B D}^{-1}}\\end{array}\\right)</script><p>其中 $M=\\left(A-B D^{-1} C\\right)^{-}$</p>\n<h2 id=\"完全平方项\"><a href=\"#完全平方项\" class=\"headerlink\" title=\"完全平方项\"></a>完全平方项</h2><p>通过对比二次型找到均值何方差的表达式</p>\n<p>分解式如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}-\\frac{1}{2}(& \\boldsymbol{x}-\\boldsymbol{\\mu}^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=\\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}</script><p>二次型</p>\n<script type=\"math/tex; mode=display\">\n-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=-\\frac{1}{2} \\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{x}+\\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}+\\text {const}_{-} \\text {value}</script><p>条件概率均值和协方差</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\mu_{a b}=\\mu_{a}+\\Sigma_{a b} \\Sigma_{b b}^{-1}\\left(x_{b}-\\mu_{b}\\right)=\\mu_{a}-H_{a b}^{-1} A_{b b}\\left(x_{b}-\\mu_{b}\\right)} \\\\ {\\Sigma_{a b}=\\Sigma_{a a}-\\Sigma_{a b} \\Sigma_{b b}^{-1} \\Sigma_{b a}=\\Lambda_{b b}^{-1}}\\end{array}</script><h1 id=\"边缘高斯分布\"><a href=\"#边缘高斯分布\" class=\"headerlink\" title=\"边缘高斯分布\"></a>边缘高斯分布</h1><script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{x}_{a}\\right)=\\int p\\left(\\boldsymbol{x}_{a}, \\boldsymbol{x}_{b}\\right) \\mathrm{d} \\boldsymbol{x}_{b}</script><p>分解式对变量Xb积分</p>\n<p>关于Xb的项</p>\n<script type=\"math/tex; mode=display\">\n-\\frac{1}{2} \\boldsymbol{x}_{b}^{T} \\boldsymbol{\\Lambda}_{b b} \\boldsymbol{x}_{b}+\\boldsymbol{x}_{b}^{T} \\boldsymbol{m}=-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)+\\frac{1}{2} \\boldsymbol{m}^{T} \\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}</script><p>其中 $\\boldsymbol{m}=\\boldsymbol{\\Lambda}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)$<br>容易求得变量的积分 现在看剩余部分变量Xa和常量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\frac{1}{2}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]^{T} \\boldsymbol{A}_{b b}^{-1}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]-\\frac{1}{2} \\boldsymbol{x}_{a}^{T} \\boldsymbol{\\Lambda}_{a a} \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a} \\boldsymbol{\\mu}_{a}+\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}\\right)+\\text {const}_{-} \\text {value}} \\\\ {=-\\frac{1}{2} \\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a}-\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{h}_{b a}\\right) \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{A}_{b a}\\right) \\boldsymbol{\\mu}_{a}+\\text {const}_{-} \\text {value }}\\end{array}</script><p>通过对比得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\mathbb{E}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\mu}_{a} \\\\ \\operatorname{cov}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\Sigma}_{a a} \\end{aligned}</script><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对联合高斯分布</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\Sigma)} \\\\ {x=\\left(\\begin{array}{l}{x_{a}} \\\\ {x_{b}}\\end{array}\\right), u=\\left(\\begin{array}{l}{\\boldsymbol{\\mu}_{a}} \\\\ {\\boldsymbol{\\mu}_{b}}\\end{array}\\right)} \\\\ {\\boldsymbol{\\Sigma}=\\left(\\begin{array}{cc}{\\boldsymbol{\\Sigma}_{a a}} & {\\boldsymbol{\\Sigma}_{a b}} \\\\ {\\boldsymbol{\\Sigma}_{b a}} & {\\boldsymbol{\\Sigma}_{b b}}\\end{array}\\right), \\quad \\boldsymbol{A}=\\left(\\begin{array}{cc}{\\boldsymbol{A}_{a a}} & {\\boldsymbol{A}_{b b}} \\\\ {\\boldsymbol{A}_{b a}} & {\\boldsymbol{A}_{b b}}\\end{array}\\right), \\boldsymbol{A}=\\boldsymbol{\\Sigma}^{-}}\\end{array}</script><p>条件概率</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} p\\left(\\boldsymbol{x}_{a} | \\boldsymbol{x}_{b}\\right) &=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a | b}, \\mathbf{\\Lambda}_{a a}^{-1}\\right) \\\\ \\boldsymbol{\\mu}_{a | b} &=\\boldsymbol{\\mu}_{a}-\\boldsymbol{\\Lambda}_{a a}^{-1} \\mathbf{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}</script><p>边缘概率</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{x}_{a}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a}, \\boldsymbol{\\Sigma}_{a a}\\right)</script><p><img src=\"/2019/10/16/高斯分布/条件边缘.png\" alt=\"条件概率和边缘概率\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.microsoft.com/en-us/research/people/cmbishop/\" target=\"_blank\" rel=\"noopener\">Pattern Recognition and Machine Learning</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/58987388\" target=\"_blank\" rel=\"noopener\">多元高斯分布完全解析</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"高斯分布表达式\"><a href=\"#高斯分布表达式\" class=\"headerlink\" title=\"高斯分布表达式\"></a>高斯分布表达式</h1><h3 id=\"一元高斯分布\"><a href=\"#一元高斯分布\" class=\"headerlink\" title=\"一元高斯分布\"></a>一元高斯分布</h3><script type=\"math/tex; mode=display\">\n\\mathcal{N}\\left(x | \\mu, \\sigma^{2}\\right)=\\frac{1}{\\left(2 \\pi \\sigma^{2}\\right)^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2 \\sigma^{2}}(x-\\mu)^{2}\\right\\}</script><h3 id=\"多元高斯分布\"><a href=\"#多元高斯分布\" class=\"headerlink\" title=\"多元高斯分布\"></a>多元高斯分布</h3><script type=\"math/tex; mode=display\">\n\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\mathbf{\\Sigma})=\\frac{1}{(2 \\pi)^{\\frac{D}{2}}} \\frac{1}{|\\boldsymbol{\\Sigma}|^{\\frac{1}{2}}} \\exp \\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right\\}</script><h1 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h1><p>高斯分布依赖于下面二次型，即马氏距离</p>\n<script type=\"math/tex; mode=display\">\n\\Delta^{2}=(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})</script><p>协方差矩阵$\\sum $可以取对称矩阵，<strong>任何非对称项都会从指数中消失</strong>（也可以从协方差矩阵定义看）可分解成对角矩阵</p>\n<script type=\"math/tex; mode=display\">\n</script><p>\\begin{array}{l}{\\Delta^{2}=[(\\vec{X}-\\vec{\\mu})]^{\\top}\\left(Q \\Lambda Q^{\\top}\\right)^{-1}[(\\vec{X}-\\vec{\\mu})]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top} \\Lambda^{-1}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left(\\Lambda^{-\\frac{1}{2}}\\right)^{\\top} \\Lambda^{-\\frac{1}{2}}\\left[Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]} \\\\ {=\\left[\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\begin{array}{c}{\\Lambda^{-\\frac{1}{2}} Q^{\\top}(\\vec{X}-\\vec{\\mu})}\\end{array}\\right]} \\\\ {=\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]^{\\top}\\left[\\left(Q \\Lambda^{-\\frac{1}{2}}\\right)^{\\top}(\\vec{X}-\\vec{\\mu})\\right]}\\end{array}</p>\n<script type=\"math/tex; mode=display\">\n</script><p>含义：高斯分布中心在u,平移u之后高斯分布中心到原点，高斯分布椭圆轴拉伸变换成正圆，称一个旋转矩阵，将之前椭圆轴方向旋转到全局坐标系(Oxyz)，特别注意：变换矩阵Q</p>\n<p>椭圆中心u,轴方向：变换矩阵Q的列向量<br><img src=\"/2019/10/16/高斯分布/高斯分布.png\" alt=\"高斯分布\"></p>\n<h1 id=\"条件高斯分布\"><a href=\"#条件高斯分布\" class=\"headerlink\" title=\"条件高斯分布\"></a>条件高斯分布</h1><p>多元⾼斯分布的⼀个重要性质是，如果两组变量是联合⾼斯分布，那么以⼀组变量为条件，<br>另⼀组变量同样是⾼斯分布。类似地，任何⼀个变量的边缘分布也是⾼斯分布</p>\n<h2 id=\"协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆\"><a href=\"#协方差矩阵-amp-精度矩阵-amp-分块矩阵求逆\" class=\"headerlink\" title=\"协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆\"></a>协方差矩阵&amp;精度矩阵&amp;分块矩阵求逆</h2><script type=\"math/tex; mode=display\">\n\\Sigma=\\left(\\begin{array}{cc}{\\Sigma_{a a}} & {\\Sigma_{a b}} \\\\ {\\Sigma_{b a}} & {\\Sigma_{b b}}\\end{array}\\right), \\quad A=\\left(\\begin{array}{cc}{A_{a}} & {A_{b}} \\\\ {A_{b a}} & {A_{b b}}\\end{array}\\right), A=\\Sigma^{-}</script><p>分块矩阵求逆</p>\n<script type=\"math/tex; mode=display\">\n\\left(\\begin{array}{cc}{\\boldsymbol{A}} & {\\boldsymbol{B}} \\\\ {\\boldsymbol{C}} & {\\boldsymbol{D}}\\end{array}\\right)^{-1}=\\left(\\begin{array}{cc}{\\boldsymbol{M}} & {-\\boldsymbol{M B D}^{-1}} \\\\ {-\\boldsymbol{D}^{-1} \\boldsymbol{C M}} & {\\boldsymbol{D}^{-1}+\\boldsymbol{D}^{-1} \\boldsymbol{C M B D}^{-1}}\\end{array}\\right)</script><p>其中 $M=\\left(A-B D^{-1} C\\right)^{-}$</p>\n<h2 id=\"完全平方项\"><a href=\"#完全平方项\" class=\"headerlink\" title=\"完全平方项\"></a>完全平方项</h2><p>通过对比二次型找到均值何方差的表达式</p>\n<p>分解式如下</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}-\\frac{1}{2}(& \\boldsymbol{x}-\\boldsymbol{\\mu}^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=\\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)^{T} \\boldsymbol{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\\\ &-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}</script><p>二次型</p>\n<script type=\"math/tex; mode=display\">\n-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})=-\\frac{1}{2} \\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{x}+\\boldsymbol{x}^{T} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}+\\text {const}_{-} \\text {value}</script><p>条件概率均值和协方差</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\mu_{a b}=\\mu_{a}+\\Sigma_{a b} \\Sigma_{b b}^{-1}\\left(x_{b}-\\mu_{b}\\right)=\\mu_{a}-H_{a b}^{-1} A_{b b}\\left(x_{b}-\\mu_{b}\\right)} \\\\ {\\Sigma_{a b}=\\Sigma_{a a}-\\Sigma_{a b} \\Sigma_{b b}^{-1} \\Sigma_{b a}=\\Lambda_{b b}^{-1}}\\end{array}</script><h1 id=\"边缘高斯分布\"><a href=\"#边缘高斯分布\" class=\"headerlink\" title=\"边缘高斯分布\"></a>边缘高斯分布</h1><script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{x}_{a}\\right)=\\int p\\left(\\boldsymbol{x}_{a}, \\boldsymbol{x}_{b}\\right) \\mathrm{d} \\boldsymbol{x}_{b}</script><p>分解式对变量Xb积分</p>\n<p>关于Xb的项</p>\n<script type=\"math/tex; mode=display\">\n-\\frac{1}{2} \\boldsymbol{x}_{b}^{T} \\boldsymbol{\\Lambda}_{b b} \\boldsymbol{x}_{b}+\\boldsymbol{x}_{b}^{T} \\boldsymbol{m}=-\\frac{1}{2}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)^{T} \\boldsymbol{\\Lambda}_{b b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}\\right)+\\frac{1}{2} \\boldsymbol{m}^{T} \\boldsymbol{\\Lambda}_{b b}^{-1} \\boldsymbol{m}</script><p>其中 $\\boldsymbol{m}=\\boldsymbol{\\Lambda}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{\\Lambda}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)$<br>容易求得变量的积分 现在看剩余部分变量Xa和常量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\frac{1}{2}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]^{T} \\boldsymbol{A}_{b b}^{-1}\\left[\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}-\\boldsymbol{A}_{b a}\\left(\\boldsymbol{x}_{a}-\\boldsymbol{\\mu}_{a}\\right)\\right]-\\frac{1}{2} \\boldsymbol{x}_{a}^{T} \\boldsymbol{\\Lambda}_{a a} \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a} \\boldsymbol{\\mu}_{a}+\\boldsymbol{A}_{b b} \\boldsymbol{\\mu}_{b}\\right)+\\text {const}_{-} \\text {value}} \\\\ {=-\\frac{1}{2} \\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a a}-\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{h}_{b a}\\right) \\boldsymbol{x}_{a}+\\boldsymbol{x}_{a}^{T}\\left(\\boldsymbol{A}_{a b} \\boldsymbol{A}_{b b}^{-1} \\boldsymbol{A}_{b a}\\right) \\boldsymbol{\\mu}_{a}+\\text {const}_{-} \\text {value }}\\end{array}</script><p>通过对比得</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\mathbb{E}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\mu}_{a} \\\\ \\operatorname{cov}\\left[\\boldsymbol{x}_{a}\\right] &=\\boldsymbol{\\Sigma}_{a a} \\end{aligned}</script><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对联合高斯分布</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{l}{\\mathcal{N}(\\boldsymbol{x} | \\boldsymbol{\\mu}, \\Sigma)} \\\\ {x=\\left(\\begin{array}{l}{x_{a}} \\\\ {x_{b}}\\end{array}\\right), u=\\left(\\begin{array}{l}{\\boldsymbol{\\mu}_{a}} \\\\ {\\boldsymbol{\\mu}_{b}}\\end{array}\\right)} \\\\ {\\boldsymbol{\\Sigma}=\\left(\\begin{array}{cc}{\\boldsymbol{\\Sigma}_{a a}} & {\\boldsymbol{\\Sigma}_{a b}} \\\\ {\\boldsymbol{\\Sigma}_{b a}} & {\\boldsymbol{\\Sigma}_{b b}}\\end{array}\\right), \\quad \\boldsymbol{A}=\\left(\\begin{array}{cc}{\\boldsymbol{A}_{a a}} & {\\boldsymbol{A}_{b b}} \\\\ {\\boldsymbol{A}_{b a}} & {\\boldsymbol{A}_{b b}}\\end{array}\\right), \\boldsymbol{A}=\\boldsymbol{\\Sigma}^{-}}\\end{array}</script><p>条件概率</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} p\\left(\\boldsymbol{x}_{a} | \\boldsymbol{x}_{b}\\right) &=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a | b}, \\mathbf{\\Lambda}_{a a}^{-1}\\right) \\\\ \\boldsymbol{\\mu}_{a | b} &=\\boldsymbol{\\mu}_{a}-\\boldsymbol{\\Lambda}_{a a}^{-1} \\mathbf{\\Lambda}_{a b}\\left(\\boldsymbol{x}_{b}-\\boldsymbol{\\mu}_{b}\\right) \\end{aligned}</script><p>边缘概率</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{x}_{a}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{a} | \\boldsymbol{\\mu}_{a}, \\boldsymbol{\\Sigma}_{a a}\\right)</script><p><img src=\"/2019/10/16/高斯分布/条件边缘.png\" alt=\"条件概率和边缘概率\"></p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://www.microsoft.com/en-us/research/people/cmbishop/\" target=\"_blank\" rel=\"noopener\">Pattern Recognition and Machine Learning</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/58987388\" target=\"_blank\" rel=\"noopener\">多元高斯分布完全解析</a></li>\n</ol>\n"},{"title":"逆运动学","date":"2020-11-23T05:37:45.000Z","mathjax":true,"_content":"\n# 逆运动学\n逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:\n- 解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.\n- 优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长\n\n## 优化法\n1. 雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)\n    逆运动学就是求解方程$f(\\theta)=0$,目标是找到关节坐标满足$x_{d}-f\\left(\\theta_{d}\\right)=0$,使用泰勒展开,即\n    $$\n    x_{d}=f\\left(\\theta_{d}\\right)=f\\left(\\theta_{0}\\right)+\\underbrace{\\left.\\frac{\\partial f}{\\partial \\theta}\\right|_{\\theta_{0}}}_{J\\left(\\theta_{0}\\right)} \\underbrace{\\left(\\theta_{d}-\\theta_{0}\\right)}_{\\Delta \\theta}+\\mathrm{h.o.t.}\n    $$\n    只保留泰勒级数到第一项,简化为\n    $$\n    J\\left(\\theta_{0}\\right) \\Delta \\theta=x_{d}-f\\left(\\theta_{0}\\right)\n    $$\n    如果作则雅克比矩阵可逆,则有\n    $$\n    \\Delta \\theta=J^{-1}\\left(\\theta_{0}\\right)\\left(x_{d}-f\\left(\\theta_{0}\\right)\\right)\n    $$\n    如果正向运行学$f(\\theta)$是$\\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\\theta_{1}=\\theta_{0}+\\Delta \\theta$精确满足运动学方程,\n    相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\\theta$收敛,如下图所示\n    ![牛顿-拉夫森法](niudun.png)\n    如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.\n    \n    如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:\n    - SVD分解, 然后求逆\n    - 行满秩,右逆 $J^{\\dagger}=J^{T}\\left(J J^{T}\\right)^{-1}$\n    - 列满秩,左逆 $J^{\\dagger}=\\left(J^{T} J\\right)^{-1} J^{T}$\n    使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解\n    $$\n    \\begin{array}{c}\n    \\min _{\\dot{q}}\\|\\dot{q}\\|^{2} \\\\\n    \\text {subject to } \\dot{x}=J \\dot{q}\n    \\end{array}\n    $$\n    然后使用**拉格朗日乘数法（Lagrange Multiplier）** 变成\n    $$\n    \\min _{\\dot{q}} \\frac{1}{2}\\|\\dot{q}\\|^{2}+\\lambda^{T}(\\dot{x}-J \\dot{q})\n    $$\n    分别对两个变量求导等与0得到两个方程求解就得到了右伪逆\n    \n    上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)\n    \n    首先计算相对物体坐标系的期望位形\n    $$\n    T_{b d}\\left(\\theta_{i}\\right)=T_{s b}^{-1}\\left(\\theta_{i}\\right) T_{s d}=T_{b s}\\left(\\theta_{i}\\right) T_{s d}\n    $$\n    其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量\n    $$\n    \\left[\\mathcal{V}_{b}\\right]=\\log T_{b d}\\left(\\theta_{i}\\right)\n    $$\n    然后迭代求解\n    $$\n    \\theta_{i+1}=\\theta_{i}+J_{b}^{\\dagger}\\left(\\theta_{i}\\right) \\mathcal{V}_{b}\n    $$\n    注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\\mathcal{V}_{s}=\\left[\\mathrm{Ad}_{T_{s b}}\\right] \\mathcal{V}_{b}$\n    \n    雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,\n    只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)\n2. 雅克比转置(梯度下降法)\n    逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题\n    $$\n    \\min _{q} \\frac{1}{2}\\left\\|x_{d}-x_{c}\\right\\|^{2}\n    $$\n    这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得\n    $$\n    \\min _{q} \\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\n    $$\n    这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向\n    $$\n    \\begin{aligned}\n    \\Delta q &=-\\alpha \\nabla\\left(\\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\\right) \\\\\n    &=\\alpha\\left(\\left(x_{d}-x\\right)^{T} \\frac{\\partial f(q)}{\\partial q}\\right)^{T} \\\\\n    &=\\alpha J^{T}\\left(x_{d}-x\\right)=\\alpha J^{T} \\Delta x\n    \\end{aligned}\n    $$\n    其中$\\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致\"走过头\"甚至多绕弯路,\n    最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.\n    \n    雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。\n3. 阻尼最小二平方法(DLS, Damped Least Square)\n    雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,\n    这时我们需要最小化的目标是\n    $$\n    \\|J \\Delta \\theta-\\overrightarrow{\\mathrm{e}}\\|^{2}+\\lambda^{2}\\|\\Delta \\theta\\|^{2}\n    $$\n    即把关节变化量放进最小化的目标函数,方程可等价于\n    $$\n    \\left\\|\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right) \\Delta \\theta-\\left(\\begin{array}{c}\n    \\overrightarrow{\\mathrm{e}} \\\\\n    0\n    \\end{array}\\right)\\right\\|\n    $$\n    借鉴线性方程组$A x=b$求解(伪逆)\n    $$\n    \\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right)^{T}\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right) \\Delta \\boldsymbol{\\theta}=\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right)^{T}\\left(\\begin{array}{l}\n    \\overrightarrow{\\mathbf{e}} \\\\\n    \\mathbf{0}\n    \\end{array}\\right)\n    $$\n    进而得到\n    $$\n    \\left(J^{T} J+\\lambda^{2} I\\right) \\Delta \\boldsymbol{\\theta}=J^{T} \\overrightarrow{\\mathbf{e}}\n    $$\n    由于左侧矩阵非奇异,则有\n    $$\n    \\Delta \\boldsymbol{\\theta}=\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T} \\overrightarrow{\\mathbf{e}}\n    $$\n    同时有$\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\\lambda^{2} I$\n    则有\n    $$\n    \\Delta \\boldsymbol{\\theta}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1} \\overrightarrow{\\mathbf{e}}\n    $$\n    这就是DLS方法的迭代方程\n    \n    在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解\n    $$\n    J=U D V^{T}\n    $$\n    然后化简得到\n    $${J^T}{\\left( {J{J^T} + {\\lambda ^2}I} \\right)^{ - 1}} = V{D^T}{\\left( {D{D^T} + {\\lambda ^2}I} \\right)^{ - 1}}{U^T} = VE{U^T}$$\n    从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\\sigma_$,求逆之后为倒数)\n    $$\n    e_{i, i}=\\frac{\\sigma_{i}}{\\sigma_{i}^{2}+\\lambda^{2}}\n    $$\n    所以一种比较简单的方式就是直接处理奇异值,[kuka-lwr](https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h)就是这样处理的\n    \n总结: DLS方法可以看成是两种方法的结合,\n当$\\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),\n当$\\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为$$J{J^T} = Q\\Lambda {Q^T}$$,由于分解后的特征值相对$\\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  \n\n$$\n\\Delta \\boldsymbol{\\theta}=J^{T}\\left(\\lambda^{2} \\right)^{-1} \\overrightarrow{\\mathbf{e}}\n$$\n\n逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods\n{% pdf iksurvey.pdf%}\n    \n# 引用\n1. [干货 | “逆运动学”——从操作空间到关节空间（上篇）](https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&mid=402440005&idx=1&sn=6fd6f3dab8d2a5859100b8d432b4bc57&chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&mpshare=1&scene=1&srcid=1122bJnzmLv4PJaTr2MAtKsn&sharer_sharetime=1606046642935&sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&wx_header=0#rd)\n2. [干货 | “逆运动学”——从操作空间到关节空间（下篇）](https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&mid=402732106&idx=1&sn=49072186c7c893a6e09801f11e8ffd78&chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&mpshare=1&scene=1&srcid=1122mBBiPmcRYHdHnoQr8iQ9&sharer_sharetime=1606046650729&sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&wx_header=0#rd)\n3. [MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)","source":"_posts/逆运动学.md","raw":"---\ntitle: 逆运动学\ndate: 2020-11-23 13:37:45\ncategories:\n- math\ntags:\n- 机器人\nmathjax: true\n\n---\n\n# 逆运动学\n逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:\n- 解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.\n- 优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长\n\n## 优化法\n1. 雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)\n    逆运动学就是求解方程$f(\\theta)=0$,目标是找到关节坐标满足$x_{d}-f\\left(\\theta_{d}\\right)=0$,使用泰勒展开,即\n    $$\n    x_{d}=f\\left(\\theta_{d}\\right)=f\\left(\\theta_{0}\\right)+\\underbrace{\\left.\\frac{\\partial f}{\\partial \\theta}\\right|_{\\theta_{0}}}_{J\\left(\\theta_{0}\\right)} \\underbrace{\\left(\\theta_{d}-\\theta_{0}\\right)}_{\\Delta \\theta}+\\mathrm{h.o.t.}\n    $$\n    只保留泰勒级数到第一项,简化为\n    $$\n    J\\left(\\theta_{0}\\right) \\Delta \\theta=x_{d}-f\\left(\\theta_{0}\\right)\n    $$\n    如果作则雅克比矩阵可逆,则有\n    $$\n    \\Delta \\theta=J^{-1}\\left(\\theta_{0}\\right)\\left(x_{d}-f\\left(\\theta_{0}\\right)\\right)\n    $$\n    如果正向运行学$f(\\theta)$是$\\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\\theta_{1}=\\theta_{0}+\\Delta \\theta$精确满足运动学方程,\n    相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\\theta$收敛,如下图所示\n    ![牛顿-拉夫森法](niudun.png)\n    如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.\n    \n    如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:\n    - SVD分解, 然后求逆\n    - 行满秩,右逆 $J^{\\dagger}=J^{T}\\left(J J^{T}\\right)^{-1}$\n    - 列满秩,左逆 $J^{\\dagger}=\\left(J^{T} J\\right)^{-1} J^{T}$\n    使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解\n    $$\n    \\begin{array}{c}\n    \\min _{\\dot{q}}\\|\\dot{q}\\|^{2} \\\\\n    \\text {subject to } \\dot{x}=J \\dot{q}\n    \\end{array}\n    $$\n    然后使用**拉格朗日乘数法（Lagrange Multiplier）** 变成\n    $$\n    \\min _{\\dot{q}} \\frac{1}{2}\\|\\dot{q}\\|^{2}+\\lambda^{T}(\\dot{x}-J \\dot{q})\n    $$\n    分别对两个变量求导等与0得到两个方程求解就得到了右伪逆\n    \n    上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)\n    \n    首先计算相对物体坐标系的期望位形\n    $$\n    T_{b d}\\left(\\theta_{i}\\right)=T_{s b}^{-1}\\left(\\theta_{i}\\right) T_{s d}=T_{b s}\\left(\\theta_{i}\\right) T_{s d}\n    $$\n    其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量\n    $$\n    \\left[\\mathcal{V}_{b}\\right]=\\log T_{b d}\\left(\\theta_{i}\\right)\n    $$\n    然后迭代求解\n    $$\n    \\theta_{i+1}=\\theta_{i}+J_{b}^{\\dagger}\\left(\\theta_{i}\\right) \\mathcal{V}_{b}\n    $$\n    注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\\mathcal{V}_{s}=\\left[\\mathrm{Ad}_{T_{s b}}\\right] \\mathcal{V}_{b}$\n    \n    雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,\n    只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)\n2. 雅克比转置(梯度下降法)\n    逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题\n    $$\n    \\min _{q} \\frac{1}{2}\\left\\|x_{d}-x_{c}\\right\\|^{2}\n    $$\n    这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得\n    $$\n    \\min _{q} \\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\n    $$\n    这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向\n    $$\n    \\begin{aligned}\n    \\Delta q &=-\\alpha \\nabla\\left(\\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\\right) \\\\\n    &=\\alpha\\left(\\left(x_{d}-x\\right)^{T} \\frac{\\partial f(q)}{\\partial q}\\right)^{T} \\\\\n    &=\\alpha J^{T}\\left(x_{d}-x\\right)=\\alpha J^{T} \\Delta x\n    \\end{aligned}\n    $$\n    其中$\\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致\"走过头\"甚至多绕弯路,\n    最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.\n    \n    雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。\n3. 阻尼最小二平方法(DLS, Damped Least Square)\n    雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,\n    这时我们需要最小化的目标是\n    $$\n    \\|J \\Delta \\theta-\\overrightarrow{\\mathrm{e}}\\|^{2}+\\lambda^{2}\\|\\Delta \\theta\\|^{2}\n    $$\n    即把关节变化量放进最小化的目标函数,方程可等价于\n    $$\n    \\left\\|\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right) \\Delta \\theta-\\left(\\begin{array}{c}\n    \\overrightarrow{\\mathrm{e}} \\\\\n    0\n    \\end{array}\\right)\\right\\|\n    $$\n    借鉴线性方程组$A x=b$求解(伪逆)\n    $$\n    \\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right)^{T}\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right) \\Delta \\boldsymbol{\\theta}=\\left(\\begin{array}{c}\n    J \\\\\n    \\lambda I\n    \\end{array}\\right)^{T}\\left(\\begin{array}{l}\n    \\overrightarrow{\\mathbf{e}} \\\\\n    \\mathbf{0}\n    \\end{array}\\right)\n    $$\n    进而得到\n    $$\n    \\left(J^{T} J+\\lambda^{2} I\\right) \\Delta \\boldsymbol{\\theta}=J^{T} \\overrightarrow{\\mathbf{e}}\n    $$\n    由于左侧矩阵非奇异,则有\n    $$\n    \\Delta \\boldsymbol{\\theta}=\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T} \\overrightarrow{\\mathbf{e}}\n    $$\n    同时有$\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\\lambda^{2} I$\n    则有\n    $$\n    \\Delta \\boldsymbol{\\theta}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1} \\overrightarrow{\\mathbf{e}}\n    $$\n    这就是DLS方法的迭代方程\n    \n    在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解\n    $$\n    J=U D V^{T}\n    $$\n    然后化简得到\n    $${J^T}{\\left( {J{J^T} + {\\lambda ^2}I} \\right)^{ - 1}} = V{D^T}{\\left( {D{D^T} + {\\lambda ^2}I} \\right)^{ - 1}}{U^T} = VE{U^T}$$\n    从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\\sigma_$,求逆之后为倒数)\n    $$\n    e_{i, i}=\\frac{\\sigma_{i}}{\\sigma_{i}^{2}+\\lambda^{2}}\n    $$\n    所以一种比较简单的方式就是直接处理奇异值,[kuka-lwr](https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h)就是这样处理的\n    \n总结: DLS方法可以看成是两种方法的结合,\n当$\\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),\n当$\\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为$$J{J^T} = Q\\Lambda {Q^T}$$,由于分解后的特征值相对$\\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  \n\n$$\n\\Delta \\boldsymbol{\\theta}=J^{T}\\left(\\lambda^{2} \\right)^{-1} \\overrightarrow{\\mathbf{e}}\n$$\n\n逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods\n{% pdf iksurvey.pdf%}\n    \n# 引用\n1. [干货 | “逆运动学”——从操作空间到关节空间（上篇）](https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&mid=402440005&idx=1&sn=6fd6f3dab8d2a5859100b8d432b4bc57&chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&mpshare=1&scene=1&srcid=1122bJnzmLv4PJaTr2MAtKsn&sharer_sharetime=1606046642935&sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&wx_header=0#rd)\n2. [干货 | “逆运动学”——从操作空间到关节空间（下篇）](https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&mid=402732106&idx=1&sn=49072186c7c893a6e09801f11e8ffd78&chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&mpshare=1&scene=1&srcid=1122mBBiPmcRYHdHnoQr8iQ9&sharer_sharetime=1606046650729&sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&wx_header=0#rd)\n3. [MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)","slug":"逆运动学","published":1,"updated":"2020-11-23T07:56:48.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ckj007pmxkalggkkn0f","content":"<h1 id=\"逆运动学\"><a href=\"#逆运动学\" class=\"headerlink\" title=\"逆运动学\"></a>逆运动学</h1><p>逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:</p>\n<ul>\n<li>解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.</li>\n<li>优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长</li>\n</ul>\n<h2 id=\"优化法\"><a href=\"#优化法\" class=\"headerlink\" title=\"优化法\"></a>优化法</h2><ol>\n<li><p>雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)<br> 逆运动学就是求解方程$f(\\theta)=0$,目标是找到关节坐标满足$x_{d}-f\\left(\\theta_{d}\\right)=0$,使用泰勒展开,即</p>\n<script type=\"math/tex; mode=display\">\n x_{d}=f\\left(\\theta_{d}\\right)=f\\left(\\theta_{0}\\right)+\\underbrace{\\left.\\frac{\\partial f}{\\partial \\theta}\\right|_{\\theta_{0}}}_{J\\left(\\theta_{0}\\right)} \\underbrace{\\left(\\theta_{d}-\\theta_{0}\\right)}_{\\Delta \\theta}+\\mathrm{h.o.t.}</script><p> 只保留泰勒级数到第一项,简化为</p>\n<script type=\"math/tex; mode=display\">\n J\\left(\\theta_{0}\\right) \\Delta \\theta=x_{d}-f\\left(\\theta_{0}\\right)</script><p> 如果作则雅克比矩阵可逆,则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\theta=J^{-1}\\left(\\theta_{0}\\right)\\left(x_{d}-f\\left(\\theta_{0}\\right)\\right)</script><p> 如果正向运行学$f(\\theta)$是$\\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\\theta_{1}=\\theta_{0}+\\Delta \\theta$精确满足运动学方程,<br> 相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\\theta$收敛,如下图所示<br> <img src=\"/2020/11/23/逆运动学/niudun.png\" alt=\"牛顿-拉夫森法\"><br> 如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.</p>\n<p> 如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:</p>\n<ul>\n<li>SVD分解, 然后求逆</li>\n<li>行满秩,右逆 $J^{\\dagger}=J^{T}\\left(J J^{T}\\right)^{-1}$</li>\n<li><p>列满秩,左逆 $J^{\\dagger}=\\left(J^{T} J\\right)^{-1} J^{T}$<br>使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\n\\min _{\\dot{q}}\\|\\dot{q}\\|^{2} \\\\\n\\text {subject to } \\dot{x}=J \\dot{q}\n\\end{array}</script><p>然后使用<strong>拉格朗日乘数法（Lagrange Multiplier）</strong> 变成</p>\n<script type=\"math/tex; mode=display\">\n\\min _{\\dot{q}} \\frac{1}{2}\\|\\dot{q}\\|^{2}+\\lambda^{T}(\\dot{x}-J \\dot{q})</script><p>分别对两个变量求导等与0得到两个方程求解就得到了右伪逆</p>\n<p>上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)</p>\n<p>首先计算相对物体坐标系的期望位形</p>\n<script type=\"math/tex; mode=display\">\nT_{b d}\\left(\\theta_{i}\\right)=T_{s b}^{-1}\\left(\\theta_{i}\\right) T_{s d}=T_{b s}\\left(\\theta_{i}\\right) T_{s d}</script><p>其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量</p>\n<script type=\"math/tex; mode=display\">\n\\left[\\mathcal{V}_{b}\\right]=\\log T_{b d}\\left(\\theta_{i}\\right)</script><p>然后迭代求解</p>\n<script type=\"math/tex; mode=display\">\n\\theta_{i+1}=\\theta_{i}+J_{b}^{\\dagger}\\left(\\theta_{i}\\right) \\mathcal{V}_{b}</script><p>注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\\mathcal{V}_{s}=\\left[\\mathrm{Ad}_{T_{s b}}\\right] \\mathcal{V}_{b}$</p>\n<p>雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,<br>只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)</p>\n</li>\n</ul>\n</li>\n<li><p>雅克比转置(梯度下降法)<br> 逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题</p>\n<script type=\"math/tex; mode=display\">\n \\min _{q} \\frac{1}{2}\\left\\|x_{d}-x_{c}\\right\\|^{2}</script><p> 这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得</p>\n<script type=\"math/tex; mode=display\">\n \\min _{q} \\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}</script><p> 这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n \\Delta q &=-\\alpha \\nabla\\left(\\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\\right) \\\\\n &=\\alpha\\left(\\left(x_{d}-x\\right)^{T} \\frac{\\partial f(q)}{\\partial q}\\right)^{T} \\\\\n &=\\alpha J^{T}\\left(x_{d}-x\\right)=\\alpha J^{T} \\Delta x\n \\end{aligned}</script><p> 其中$\\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致”走过头”甚至多绕弯路,<br> 最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.</p>\n<p> 雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。</p>\n</li>\n<li><p>阻尼最小二平方法(DLS, Damped Least Square)<br> 雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,<br> 这时我们需要最小化的目标是</p>\n<script type=\"math/tex; mode=display\">\n \\|J \\Delta \\theta-\\overrightarrow{\\mathrm{e}}\\|^{2}+\\lambda^{2}\\|\\Delta \\theta\\|^{2}</script><p> 即把关节变化量放进最小化的目标函数,方程可等价于</p>\n<script type=\"math/tex; mode=display\">\n \\left\\|\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right) \\Delta \\theta-\\left(\\begin{array}{c}\n \\overrightarrow{\\mathrm{e}} \\\\\n 0\n \\end{array}\\right)\\right\\|</script><p> 借鉴线性方程组$A x=b$求解(伪逆)</p>\n<script type=\"math/tex; mode=display\">\n \\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right)^{T}\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right) \\Delta \\boldsymbol{\\theta}=\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right)^{T}\\left(\\begin{array}{l}\n \\overrightarrow{\\mathbf{e}} \\\\\n \\mathbf{0}\n \\end{array}\\right)</script><p> 进而得到</p>\n<script type=\"math/tex; mode=display\">\n \\left(J^{T} J+\\lambda^{2} I\\right) \\Delta \\boldsymbol{\\theta}=J^{T} \\overrightarrow{\\mathbf{e}}</script><p> 由于左侧矩阵非奇异,则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\boldsymbol{\\theta}=\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T} \\overrightarrow{\\mathbf{e}}</script><p> 同时有$\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\\lambda^{2} I$<br> 则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\boldsymbol{\\theta}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1} \\overrightarrow{\\mathbf{e}}</script><p> 这就是DLS方法的迭代方程</p>\n<p> 在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解</p>\n<script type=\"math/tex; mode=display\">\n J=U D V^{T}</script><p> 然后化简得到</p>\n<script type=\"math/tex; mode=display\">{J^T}{\\left( {J{J^T} + {\\lambda ^2}I} \\right)^{ - 1}} = V{D^T}{\\left( {D{D^T} + {\\lambda ^2}I} \\right)^{ - 1}}{U^T} = VE{U^T}</script><p> 从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\\sigma_$,求逆之后为倒数)</p>\n<script type=\"math/tex; mode=display\">\n e_{i, i}=\\frac{\\sigma_{i}}{\\sigma_{i}^{2}+\\lambda^{2}}</script><p> 所以一种比较简单的方式就是直接处理奇异值,<a href=\"https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h\" target=\"_blank\" rel=\"noopener\">kuka-lwr</a>就是这样处理的</p>\n</li>\n</ol>\n<p>总结: DLS方法可以看成是两种方法的结合,<br>当$\\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),<br>当$\\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为<script type=\"math/tex\">J{J^T} = Q\\Lambda {Q^T}</script>,由于分解后的特征值相对$\\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  </p>\n<script type=\"math/tex; mode=display\">\n\\Delta \\boldsymbol{\\theta}=J^{T}\\left(\\lambda^{2} \\right)^{-1} \\overrightarrow{\\mathbf{e}}</script><p>逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods<br>\n\n\t<div class=\"row\">\n    <embed src=\"iksurvey.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402440005&amp;idx=1&amp;sn=6fd6f3dab8d2a5859100b8d432b4bc57&amp;chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&amp;mpshare=1&amp;scene=1&amp;srcid=1122bJnzmLv4PJaTr2MAtKsn&amp;sharer_sharetime=1606046642935&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd\" target=\"_blank\" rel=\"noopener\">干货 | “逆运动学”——从操作空间到关节空间（上篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402732106&amp;idx=1&amp;sn=49072186c7c893a6e09801f11e8ffd78&amp;chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&amp;mpshare=1&amp;scene=1&amp;srcid=1122mBBiPmcRYHdHnoQr8iQ9&amp;sharer_sharetime=1606046650729&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd\" target=\"_blank\" rel=\"noopener\">干货 | “逆运动学”——从操作空间到关节空间（下篇）</a></li>\n<li><a href=\"http://hades.mech.northwestern.edu/index.php/Modern_Robotics\" target=\"_blank\" rel=\"noopener\">MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"逆运动学\"><a href=\"#逆运动学\" class=\"headerlink\" title=\"逆运动学\"></a>逆运动学</h1><p>逆运动学是已知机械臂末端的位姿求解关节角度的过程,通常有两种方法:</p>\n<ul>\n<li>解析法.使用代数或者几何法求解,可以求得当前位姿对应的所有解,需要选择离当前位置最近的关节角解缺点是机械臂需要满足一定的要求.</li>\n<li>优化法.把问题转化为优化问题(很多问题都可以转化为优化问题),缺点是只能获得一个解,耗时相对较长</li>\n</ul>\n<h2 id=\"优化法\"><a href=\"#优化法\" class=\"headerlink\" title=\"优化法\"></a>优化法</h2><ol>\n<li><p>雅克比逆(牛顿-拉夫森法, Newton-Raphson Method)<br> 逆运动学就是求解方程$f(\\theta)=0$,目标是找到关节坐标满足$x_{d}-f\\left(\\theta_{d}\\right)=0$,使用泰勒展开,即</p>\n<script type=\"math/tex; mode=display\">\n x_{d}=f\\left(\\theta_{d}\\right)=f\\left(\\theta_{0}\\right)+\\underbrace{\\left.\\frac{\\partial f}{\\partial \\theta}\\right|_{\\theta_{0}}}_{J\\left(\\theta_{0}\\right)} \\underbrace{\\left(\\theta_{d}-\\theta_{0}\\right)}_{\\Delta \\theta}+\\mathrm{h.o.t.}</script><p> 只保留泰勒级数到第一项,简化为</p>\n<script type=\"math/tex; mode=display\">\n J\\left(\\theta_{0}\\right) \\Delta \\theta=x_{d}-f\\left(\\theta_{0}\\right)</script><p> 如果作则雅克比矩阵可逆,则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\theta=J^{-1}\\left(\\theta_{0}\\right)\\left(x_{d}-f\\left(\\theta_{0}\\right)\\right)</script><p> 如果正向运行学$f(\\theta)$是$\\theta$的线性函数,泰勒级数没有高阶项,新的估计值$\\theta_{1}=\\theta_{0}+\\Delta \\theta$精确满足运动学方程,<br> 相反,如果运动学是非线性函数,那么新的估计值将会更接近真实值,迭代不断重复,直到$\\theta$收敛,如下图所示<br> <img src=\"/2020/11/23/逆运动学/niudun.png\" alt=\"牛顿-拉夫森法\"><br> 如果逆运动学存在多组解,则只会找到最近的解.在实际使用中,矩阵求逆很耗费计算资源,通常是借鉴$A x=b$,使用矩阵的LU分解.</p>\n<p> 如果雅克比不可逆,则使用矩阵伪逆(Moore-Penrose),伪逆求法:</p>\n<ul>\n<li>SVD分解, 然后求逆</li>\n<li>行满秩,右逆 $J^{\\dagger}=J^{T}\\left(J J^{T}\\right)^{-1}$</li>\n<li><p>列满秩,左逆 $J^{\\dagger}=\\left(J^{T} J\\right)^{-1} J^{T}$<br>使用伪逆得到的解不会精确满足方程,但从最小二乘的层面会尽可能接近这个条件,求线性方程组或者拟合的时候经常用到.伪逆推导就是求解</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\n\\min _{\\dot{q}}\\|\\dot{q}\\|^{2} \\\\\n\\text {subject to } \\dot{x}=J \\dot{q}\n\\end{array}</script><p>然后使用<strong>拉格朗日乘数法（Lagrange Multiplier）</strong> 变成</p>\n<script type=\"math/tex; mode=display\">\n\\min _{\\dot{q}} \\frac{1}{2}\\|\\dot{q}\\|^{2}+\\lambda^{T}(\\dot{x}-J \\dot{q})</script><p>分别对两个变量求导等与0得到两个方程求解就得到了右伪逆</p>\n<p>上述方法只是针对机械臂的末端位置求解,如果增加姿态,则不能只是直接简单相减,使用雅克比我们可以先求出末端的线速度和角速度(物体的速度旋量)</p>\n<p>首先计算相对物体坐标系的期望位形</p>\n<script type=\"math/tex; mode=display\">\nT_{b d}\\left(\\theta_{i}\\right)=T_{s b}^{-1}\\left(\\theta_{i}\\right) T_{s d}=T_{b s}\\left(\\theta_{i}\\right) T_{s d}</script><p>其中b指代body,即当前末端位恣,d指代destination.然后使用矩阵对数求解旋量</p>\n<script type=\"math/tex; mode=display\">\n\\left[\\mathcal{V}_{b}\\right]=\\log T_{b d}\\left(\\theta_{i}\\right)</script><p>然后迭代求解</p>\n<script type=\"math/tex; mode=display\">\n\\theta_{i+1}=\\theta_{i}+J_{b}^{\\dagger}\\left(\\theta_{i}\\right) \\mathcal{V}_{b}</script><p>注意这里使用的是物体雅克比(Body Jacobian)和对应的物体运动旋量(Body Twist),如果使用空间雅克比和空间运动旋量需要转换一下,$\\mathcal{V}_{s}=\\left[\\mathrm{Ad}_{T_{s b}}\\right] \\mathcal{V}_{b}$</p>\n<p>雅克比逆的方法也可以理解从当前点到目标点的速度,然后用雅克比逆求解关节角速度,使用到下一个关节角度的叠加,<br>只是这种理解关节角度角度变化不能太大,否则雅克比不准(和关节构型有关,是变化的)</p>\n</li>\n</ul>\n</li>\n<li><p>雅克比转置(梯度下降法)<br> 逆解的目标是当前的位置距离目标位置尽可能近,转化为一个最小值问题</p>\n<script type=\"math/tex; mode=display\">\n \\min _{q} \\frac{1}{2}\\left\\|x_{d}-x_{c}\\right\\|^{2}</script><p> 这里有系数只是为了求导后没有系数,不影响结果,将当前位置带入方程得</p>\n<script type=\"math/tex; mode=display\">\n \\min _{q} \\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}</script><p> 这个时候可以使用梯度下降法,每一步都沿着下降最快的方向走,方向为梯度的反方向</p>\n<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n \\Delta q &=-\\alpha \\nabla\\left(\\frac{1}{2}\\left\\|x_{d}-f(q)\\right\\|^{2}\\right) \\\\\n &=\\alpha\\left(\\left(x_{d}-x\\right)^{T} \\frac{\\partial f(q)}{\\partial q}\\right)^{T} \\\\\n &=\\alpha J^{T}\\left(x_{d}-x\\right)=\\alpha J^{T} \\Delta x\n \\end{aligned}</script><p> 其中$\\alpha$是梯度下降法的一个系数,步长(step size)或这学习效率(learning rate).步长太大导致”走过头”甚至多绕弯路,<br> 最终迭代速度慢(甚至无法收敛),步长太小导致迭代速度太慢.</p>\n<p> 雅克比转置方法不需要求逆,不过收敛速度反而慢一点,使用这个方法控制机械臂,离end effector较远的关节常常需要输出更大的扭矩。</p>\n</li>\n<li><p>阻尼最小二平方法(DLS, Damped Least Square)<br> 雅克比奇异导致关节速度过大,这显然是我们不希望看到的,现在也有很多避奇异的方法,DLS就是一种限制关节速度的方法,<br> 这时我们需要最小化的目标是</p>\n<script type=\"math/tex; mode=display\">\n \\|J \\Delta \\theta-\\overrightarrow{\\mathrm{e}}\\|^{2}+\\lambda^{2}\\|\\Delta \\theta\\|^{2}</script><p> 即把关节变化量放进最小化的目标函数,方程可等价于</p>\n<script type=\"math/tex; mode=display\">\n \\left\\|\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right) \\Delta \\theta-\\left(\\begin{array}{c}\n \\overrightarrow{\\mathrm{e}} \\\\\n 0\n \\end{array}\\right)\\right\\|</script><p> 借鉴线性方程组$A x=b$求解(伪逆)</p>\n<script type=\"math/tex; mode=display\">\n \\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right)^{T}\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right) \\Delta \\boldsymbol{\\theta}=\\left(\\begin{array}{c}\n J \\\\\n \\lambda I\n \\end{array}\\right)^{T}\\left(\\begin{array}{l}\n \\overrightarrow{\\mathbf{e}} \\\\\n \\mathbf{0}\n \\end{array}\\right)</script><p> 进而得到</p>\n<script type=\"math/tex; mode=display\">\n \\left(J^{T} J+\\lambda^{2} I\\right) \\Delta \\boldsymbol{\\theta}=J^{T} \\overrightarrow{\\mathbf{e}}</script><p> 由于左侧矩阵非奇异,则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\boldsymbol{\\theta}=\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T} \\overrightarrow{\\mathbf{e}}</script><p> 同时有$\\left(J^{T} J+\\lambda^{2} I\\right)^{-1} J^{T}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1}$ 可以左右两侧同时乘$J^{T} J+\\lambda^{2} I$<br> 则有</p>\n<script type=\"math/tex; mode=display\">\n \\Delta \\boldsymbol{\\theta}=J^{T}\\left(J J^{T}+\\lambda^{2} I\\right)^{-1} \\overrightarrow{\\mathbf{e}}</script><p> 这就是DLS方法的迭代方程</p>\n<p> 在编程实现中,通常是直接处理雅克比矩阵奇异值分解后对奇异值操作,这是等效的,首先奇异值分解</p>\n<script type=\"math/tex; mode=display\">\n J=U D V^{T}</script><p> 然后化简得到</p>\n<script type=\"math/tex; mode=display\">{J^T}{\\left( {J{J^T} + {\\lambda ^2}I} \\right)^{ - 1}} = V{D^T}{\\left( {D{D^T} + {\\lambda ^2}I} \\right)^{ - 1}}{U^T} = VE{U^T}</script><p> 从这里可以看出E为对称矩阵,而且值为(雅克比矩阵svd分解后奇异值为$\\sigma_$,求逆之后为倒数)</p>\n<script type=\"math/tex; mode=display\">\n e_{i, i}=\\frac{\\sigma_{i}}{\\sigma_{i}^{2}+\\lambda^{2}}</script><p> 所以一种比较简单的方式就是直接处理奇异值,<a href=\"https://github.com/CentroEPiaggio/kuka-lwr/blob/master/lwr_controllers/include/utils/pseudo_inversion.h\" target=\"_blank\" rel=\"noopener\">kuka-lwr</a>就是这样处理的</p>\n</li>\n</ol>\n<p>总结: DLS方法可以看成是两种方法的结合,<br>当$\\lambda$很小时,根据SVD分解奇异值可以看出来就是牛顿-拉夫森法(矩阵逆),<br>当$\\lambda$很大, $J{J^T}$为对阵矩阵,可以分解为<script type=\"math/tex\">J{J^T} = Q\\Lambda {Q^T}</script>,由于分解后的特征值相对$\\lambda$ 很小,则最后直接成为下式,其实就是前面的梯度法  </p>\n<script type=\"math/tex; mode=display\">\n\\Delta \\boldsymbol{\\theta}=J^{T}\\left(\\lambda^{2} \\right)^{-1} \\overrightarrow{\\mathbf{e}}</script><p>逆解参考Samuel R. Buss的Introduction to Inverse Kinematics with Jacobian Transpose, Pseudoinverse and Damped Least Squares methods<br>\n\n\t<div class=\"row\">\n    <embed src=\"iksurvey.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n</p>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402440005&amp;idx=1&amp;sn=6fd6f3dab8d2a5859100b8d432b4bc57&amp;chksm=7bf084694c870d7fc3cda2050951d2464f2bf8d3a3fe53a5793b8c4853e7907f64d2f61c252e&amp;mpshare=1&amp;scene=1&amp;srcid=1122bJnzmLv4PJaTr2MAtKsn&amp;sharer_sharetime=1606046642935&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=Ax1h1mIg50AJIvm3eB93%2F%2B8%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd\" target=\"_blank\" rel=\"noopener\">干货 | “逆运动学”——从操作空间到关节空间（上篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA3MjA2Nw==&amp;mid=402732106&amp;idx=1&amp;sn=49072186c7c893a6e09801f11e8ffd78&amp;chksm=740d0f66437a86702b645b1e9a79d809e9c5feae53bdbbf39a81932c163c5bf1643f0da193ae&amp;mpshare=1&amp;scene=1&amp;srcid=1122mBBiPmcRYHdHnoQr8iQ9&amp;sharer_sharetime=1606046650729&amp;sharer_shareid=e4ca836a049d31ddd8c4060a9b422e51&amp;exportkey=A1IFM3SHYDEbQt4WRKd233w%3D&amp;pass_ticket=743iIudUQdHJurJUc1%2FU%2BuO2n%2BhM2POPvesFLxsz0kQoyT9aMsZyAJAdiewBumEC&amp;wx_header=0#rd\" target=\"_blank\" rel=\"noopener\">干货 | “逆运动学”——从操作空间到关节空间（下篇）</a></li>\n<li><a href=\"http://hades.mech.northwestern.edu/index.php/Modern_Robotics\" target=\"_blank\" rel=\"noopener\">MODERN ROBOTICS MECHANICS, PLANNING, AND CONTROL</a></li>\n</ol>\n"},{"title":"c++记录","date":"2019-10-06T08:35:06.000Z","_content":"\n## g++编译\n    g++ -g -Wall -std=c++11 main.cpp\n    \n### 常用选项\n    -ansi\t只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n    -c\t只编译并生成目标文件。\n    -DMACRO\t以字符串\"1\"定义 MACRO 宏。\n    -DMACRO=DEFN\t以字符串\"DEFN\"定义 MACRO 宏。\n    -E\t只运行 C 预编译器。\n    -g\t生成调试信息。GNU 调试器可利用该信息。\n    -IDIRECTORY\t指定额外的头文件搜索路径DIRECTORY。\n    -LDIRECTORY\t指定额外的函数库搜索路径DIRECTORY。\n    -lLIBRARY\t连接时搜索指定的函数库LIBRARY。\n    -m486\t针对 486 进行代码优化。\n    -o\tFILE 生成指定的输出文件。用在生成可执行文件时。\n    -O0\t不进行优化处理。\n    -O\t或 -O1 优化生成代码。\n    -O2\t进一步优化。\n    -O3\t比 -O2 更进一步优化，包括 inline 函数。\n    -shared\t生成共享目标文件。通常用在建立共享库时。\n    -static\t禁止使用共享连接。\n    -UMACRO\t取消对 MACRO 宏的定义。\n    -w\t不生成任何警告信息。\n    -Wall\t生成所有警告信息。  \n    \n## enum 枚举类型\n可以和switch语句很好结合      \n1. 声明 enumType 为新的数据类型，称为**枚举**(enumeration) 可用来声明这种类型的变量,就像int a;\nMonday等为符号常量，**枚举量**，默认0-6\n也可以定义的类型的时候定义变量(还可以顺带初始化)      \n\n        enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};\n        enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday = Monday;\n      \n2. 枚举量赋值给非枚举量，因为枚举量是符号常量，赋值编译器自动把枚举量转换为int\n        \n        int a = Monday;\n        int a = Monday + 1;\n3. 非枚举量强制类型转换 赋值给枚举量\n        \n        Weekday = enumType(2);  #但要注意**不要超出枚举取值范围**，超出了不会报错，但是得不到想要的结果\n4. 自定义枚举常量的值， 这里Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5\n        \n        enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};\n注意：指定的值是**整数**,**未被初始化的枚举值的值默认将比其前面的枚举值大1**,**枚举量的值可以相同**        \n5. 强类型枚举\n传统c++问题：暴露在外层作用域，如果有相同枚举常量不行\n\n        enum Side{Right,Left};\n        enum Thing{Wrong,Right};\n        \n        #强枚举类型 只能使用 Enumeration::VAL1，单独的VAL1没有意义\n        enum class Enumeration{\n         VAL1,\n         VAL2,\n        };\n        \n## 左值 右值\n- **左值(lvalue)**：指向内存位置的表达式被称为左值表达式。可以出现在赋值号的左边和右边。 如变量\n- **右值(rvalue)**：存储在内存中某些地址的数值。不能对其进行赋值表达式，只能出现在赋值号右边。如数值型字面值 10\n\n## 变量初始化\n1. 局部变量：定义时系统不会对其初始化，需要自行初始化\n2. 全局变量：系统自动初始化为下列值\n- int\t    0\n- char\t    '\\0'\n- float\t    0\n- double\t0\n- pointer\tNULL\n\n## 限定符\n\n限定符\t含义\n- const\t类型的对象在程序执行期间不能被修改改变。\n- **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。\n对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率，\n比如编译器发现两次从i读取数据代码之间没有对i操作，优化结果就是直接用上次读到的值，(变量是寄存器变量或者端口数据时容易出错)\n用了volatile生成的汇编代码就会重新从i的地址读取数据\n\n    \n        volatile int i=10;  \n        int a = i;  \n        ...  \n        // 其他代码，并未明确告诉编译器，对 i 进行过操作  \n        int b = i;  \n        \n## 存储类\n1. **auto** 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。使用少c++11已删除\n2. **register** 变量**可能**在寄存器中，取决于硬件和实现的限制。如果在寄存器中，则不能进行**一元&**运算，因为没有内存位置。用于需要快速访问的量\n3. **static** 修饰全局变量：作用域限制在声明它的文件内。 局部变量：保持局部变量的值，只初始化一次\n        \n   1. static数据成员存储在程序静态存储区，独立于该类的任意对象，类对象和类都可以调用\n   2. static数据成员必须在**类外初始化**，不能在类中\n   3. static const int 可以在类定义内部初始化 其他string double 不可以\n4. **extern** 提供一个全局变量引用，使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。通常用于多个文件夹共享全局变量\n5. **mutable** 使用类对象，mutable成员可以通过const成员函数修改\n6. **thread_local** 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\n## 运算符优先级\n~ : 二进制补码运算\n![运算符优先级](运算符优先级.png)\n\n## lambda 函数与表达式\n匿名函数\n    \n    [capture](parameters)->return-type{body}\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。可以通过前面的[]来指定：\n    \n        []      // 沒有定义任何变量。使用未定义变量会引发错误。\n        [x, &y] // x以传值方式传入（默认），y以引用方式传入。\n        [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n        [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。 一旦传值 就是常量\n        [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n        [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n        \n        //常值传递 copy一份 之后不变\n        int a=10;\n        auto func2 = [&]{return a + 1;};\n        cout << func1() << endl;\n        a++;\n        cout << func1() << endl;\n          \n        //mutable更改变量值\n        int a=10;\n        cout << [=]()mutable{return ++a;}() << endl;  //总是一个const函数，不能在函数体内修改非静态成员变量,这里是修改拷贝的参数,参数本身没有改变\n    \n1. 捕捉器，按值传递，相当于在表达式定义那一刻，表达式内就copy了一份变量，而且**值永远不变**，即使外部变量变了，这也不变\n2. 想在表达式内部修改变量的值，添加**mutable** \n\n### qt中的lambda表达式\n \n\n    QObject::connect(&newspaper, static_cast<void (Newspaper:: *)(const QString &)>(&Newspaper::newPaper),\n                    [=](const QString &name) \n                    { /* Your code here. */ }\n                    );\n这里实际函数调用的参数是从信号过来的所以不需要再赋值,下面就是调用匿名函数,a赋值为4\n\n    [](int a){cout << a}(4)                    \n\n\n   \n## 指向指针的指针\n    //函数如果要改变值就传入指针或这引用,要改变指针就得传入指针的指针,因为在函数参数传递是调用拷贝构造函数进行复制\n    int **var;   **var\n     \n## 虚继承\n菱形继承 子类多重拷贝：浪费空间，二义性\nclass B C 都继承自class A， 而class D继承自 B和C\n    \n    class A {virtual ~A()}    // 有的析构函数不是虚函数\n    class B : virtual public A;\n    class C : virtual public A;\n    class D : public B, public A;\nB C继承了A的数据成员和指向A的指针\nD继承了B C的数据成员和分别指向B C的指针\n\n## 运算符重载\n    classname operator++();   //前缀自增\n    classname operator++(int);  //后缀自增 加了int形参区分，形参是0，但在函数体内用不到\n->类成员访问运算符重载 返回类型必须是指针或者类对象 \n    \n    class Ptr{\n       //...\n       X * operator->();\n    };\n    void f(Ptr p )\n    {\n       p->m = 10 ; // (p.operator->())->m = 10\n    }\n    \n## 虚函数\n= 0 告诉编译器，函数没有主体，下面的虚函数是纯虚函数。\n\n    virtual int area() = 0;  \n    \n## c++ STL\n- Containers(容器)    deque list vector map\n- Algorithms(算法)\n- iterators(迭代器)    vector<int>::iterator v = vec.begin(); v++; 返回指向向量开头的迭代器   \n           \n## 文件和流\n如果一个数字太大,无法使用 setprecision 指定的有效数位数来打印,则许多系统会以科学表示法的方式打印.\n比如setprecision(5), 145678.99 输出 1.4568e+005\n\n为了让浮点输出以固定点或小数点表示法显示,使用流操作符fixed,结合setprecision(2)表示小数点后显示的位数\n    \n    log_file << std::fixed << std::setprecision(8) << force_sensor_val(0) << std::endl;\n\n### 文件输入输出流\n1. fstream ofstream ifstream\n    \n        void open(const char *filename, ios::openmode mode);   //文件流对象的成员函数\n    打开模式\n    - ios::app\t追加模式。所有写入都追加到文件末尾。\n    - ios::ate\t文件打开后定位到文件末尾。\n    - ios::in\t打开文件用于读取。\n    - ios::out\t打开文件用于写入。\n    - ios::trunc\t如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0。\n    - ios::binary   二进制方式打开，默认打开为文本方式\n    \n    常用函数\n    \n        getline(cin, string);   //当然也可以是 fileOgject从文件 ，cin是从键盘  好用 但是可能读取不到最后一行，如果最后一行没有回车\n        fileObject.getline(buf, size);\n2. 文件位置 istream成员函数seekg  ostream成员函数seekp\n    \n        fileObject.seekg(n);    //定位到第n个字节    \n        fileObject.seekg(n, ios::cur);    //当前位置后移n字节\n        fileObject.seekg(n, ios::end);    //末尾向前n字节\n        fileObject.seekg(0, ios::end);    //末尾\n3. cin.ignore(),默认参数cin.ignore(1,EOF),完整版本是 cin.ignore(int n, char a)\n从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。\n每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，\n则 cin.ignore()函数执行终止；否则，它继续等待。\n它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，\n消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,'\\n')，\n通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \\n 起作用，\n所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。\n        \n        int a,b;\n        cout<<\"input a:\";\n        cin>>a;\n        cin.ignore(1024, '\\n');\n        cout<<\"input b:\";\n        cin>>b;\n\n### 字符串输入输出流\n<sstream>直接对内存而不是对文件和标准输出(设备)进行操作\n\nstringstream istringstream   ostringstream\n同样可以使用seekp()移动写指针 seekg()重定位读指针\n    \n    //整数转字符串\n    #include <sstream>\n    \n    std::ostringstream oss;\n    int name_suffix = 1;\n    oss << name_suffix;\n    oss.str();       //返回一个新的string对象，替换内置的stringbuf\n    \n    // 设置输出精度,cout默认是6位有效数字\n    cout.precision(12); //设置为12位有效数字\n    printf(\"%.12f\",val);  //小数点后12位有效数字  \n    \n## 异常处理\n1. 抛出异常\n    关键字throw将创建程序抛出对象的拷贝,然后包含throw的函数返回了这个对象(即使函数返回值没有这个对象),\n    异常导致程序返回的地方和正常return返回的地方不一样.异常发生之前创建的局部对象也将析构(栈反解)\n        \n        throw \"Division by zero condition!\";   //类型为const char* 的异常 catch(const char* msg)\n        try{throw x;}catch(T& e){}   //可以抛出任意,包括内置类型 int,double...,后面用相应的类型来捕获.通常抛出异常创建的类    \n2. 捕获异常:\n    **异常处理器catch必须紧跟try之后,catch只会匹配第一个**,然后系统认为此异常已经处理了,不会继续查找下去,如果还想在抛,就必须throw\n        \n    如果没有任何一个层次的异常处理器匹配到异常,terminate()函数调用,在<exception>内,\n       \n        try\n        {\n           // 保护代码\n        }catch( ExceptionName e )    //捕获任何异常  (...)\n        {\n          // 处理 ExceptionName 异常的代码\n          throw;  //可以选择继续上抛,但是要保证这个throw仍然在try语句中(可以是上一层函数的try) 异常对象的所有信息被保留\n        }\n             \n    ![异常层次图](异常图.png)\n    ![异常说明](异常表.png)\n3. 异常安全\n    stack的pop()函数没有返回值,很重要的原因就是stack必须保证异常安全,如果为了得到返回值而调用复制构造函数,函数确抛出异常\n    导致没有获得栈顶元素,而且栈定指针下移了一个,这是不安全的,所以分成两步.        \n4. assert() 断言语句 用于开发阶段调试 #define NDEBUG 使其在最终发行软件中失效\n5. 定义自己的异常 最好从runtime_error或者logic_error继承(exception两个最主要的派生类) \n不要直接从exception继承(没有提供一个参数类型为std::string的构造函数)\n        \n        class MyError : public runtime_error{\n        public:\n            MyError(const string& msg = \"\") : runtime_error(msg){}\n        };\n        \n        int main(){\n            try{\n                throw MyError(\"my message\");\n            } catch (MyError & x){\n                cout<< x.what()<<endl;\n            }\n        } \n### 异常的使用\n1. 尽量使用引用来捕获异常\n    - 避免不必要的对象拷贝\n    - 派生类对象被当做基类对象捕获时,避免对象切割,损失信息\n2. 构造函数抛出异常时,必须注意对象内部的指针和它的清理方式\n3. 不要在析构函数中抛出异常\n    - 析构函数会在抛出其他异常的过程中别调用,避免析构函数抛出异常或者使用可能触发异常的语句(栈反解),导致程序调用teminate()\n    - 如果析构函数可能抛出异常,在析构函数内部编写try,catch,必须自己处理异常,不能抛出\n4. 避免悬挂指针(野指针)\n    构造函数抛出异常,而内部又有指针,因为指针没有析构函数,造成资源无法释放,可以使用智能指针,shared_ptr来处理指向堆内存的指针\n5. 处理简单错误尽量不用异常处理,只需要显示消息然后退出程序就可以了,然后把清理工作交给操作系统\n    cout<<\"error message\"<<endl;exit(1);             \n\n### exit函数\n    void exit(int value);  // 位于<cstdlib>中\n    exit(0);  //表示正常退出 退出整个进程.main函数要求返回值为int,在main中的exit相当于return\n\n## 类型转换\n- 转换很有用，但是在某些情况下，它强制编译器把一个数据看成比他实际更大的类型，占用更多空间，可能会破坏其他数据\n- 转换就是告诉编译器\"忘记类型检查　把它看成其他类型\"　编译器不会执行类型检查　引入了漏洞，程序出了问题，首先想到类型转换\n\n查看变量类型\n    \n    #include <typeinfo>\n    std::cout<<typeid(var).name()<<std::endl;\n\n1. C风格\n\n        int a = 200;\n        long b = (long)a;\n        long c = long(a);  //类似于函数调用\n2. c++显式转换\n比较容易发现转换的位置，定位bug\n\n    static_cast\n        \n        int a = 200;\n        long b = static_cast<long>(a);  //\n        static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged);  //qt 函数指针\n    const_cast   const 到非const volatile 到非volatile\n    \n        const int i=0;\n        int* j = const_cast<int*>(&i);   // 不用转换是不能将赋值给非const指针\n        \n        volatile int k=0;\n        int* u = const_cast<int*>(&k);     \n               \n## 继承和组合\n1. 构造函数初始化列表\n针对问题：新类的构造函数没有权利访问子对象的私有数据成员，所以不能直接对他们初始化\n        \n        //Bar是基类，m是MyType的一个成员对象\n        MyType::MyType(int i): Bar(i),m(i+1){//...}\n- 自动析构函数调用：虽然常常需要在初始化列表中显式构造函数调用，但是不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且不屈任何参数\n- 构造函数调用次序是由成员对象在类中声明的次序决定。如果由　初始化列表的次序确定，则会有两个不同构造函数有两种不同调用构造函数顺序，那么析构函数不知道如何逆序调用。\n\n## 随机数发生器\n    #include <cstdlib>\n    #include <iostream>\n    #include <ctime>\n    \n    // time(0) 返回一个和时间相关的的数作为随机数种子,如果不设置或者设置一样的数那么运行产生的随机数都一样\n    srand(time(0));   \n    rand();           // 获取随机数 线性同余法 不是真的随机数 N(j+1) = (A*N(j)+B)(mod M)\n    \n[线性同余法](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95) \n                       \n## **待续...**\n## 动态内存\n## 命名空间\n## 模板\n## 预处理器\n## 信号处理\n## 多线程\n                    \n\n# const constexpr\n- const：大致意思是说我承诺不改变这个值，主要用于说明接口，这样变量传递给函数就不担心变量会在函数内被修改了,编译器负责确认并执行const的承诺。\n- constexpr：大致意思是在编译时求值，主要用于说明常量，作用是允许数据置于只读内存以及提升性能。\n    \nconstexpr的好处：\n\n- 是一种很强的约束，更好地保证程序的正确语义不被破坏。\n- 编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。\n- 相比宏来说，没有额外的开销，但更安全可靠。\n\n# 遇到的问题\n1. 不同vector 的iterator不能混用\n    \n    迭代器(Iterator)是一个对象，它的工作是遍历并选择序列中的对象，\n    它提供了一种访问一个容器(container)对象中的各个元素，\n    而又不必暴露该对象内部细节的方法。通过迭代器，\n    开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。\n    \n    指针用来遍历**连续存储结构**,迭代器针对容器(不管底层数据结构是否连续),提供堆容器遍历的方法\n    \n    下面这种方式出错,不能简单得把iterator当成一个索引      \n    \n        vector<int>::iterator index_vec_1 = find(vec_1.begin(), vec_1.end(), val);\n        //出错\n        vector<int>::iterator vec_2_new(vec_2.begin(), index_vec_1);  \n        // 正确\n        vector<int>::iterator vec_1_new(vec_1.begin(), index_vec_1);\n        vector<int>::iterator vec_2_new(vec_2.begin(), vec_1_new.size());\n        \n\n# 引用\n1. [C++之enum枚举量声明、定义、使用与枚举类详解](https://blog.csdn.net/Bruce_0712/article/details/54984371)\n2. [C++ 教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)\n3. [C++中volatile关键字的使用详解](https://blog.csdn.net/zyx_0604/article/details/80689673)\n4. [c++中static数据成员，static成员函数](https://www.cnblogs.com/yyxt/p/4802688.html)\n5. [c++中lambda表达式的用法](https://blog.csdn.net/iloveyousunna/article/details/78532398)\n6. [C++中虚继承的作用及底层实现原理](https://blog.csdn.net/bxw1992/article/details/77726390)\n7. [关于constexpr与const](https://blog.csdn.net/qq_22274565/article/details/78719951)\n8. [C++中的const和constexpr](https://www.cnblogs.com/wodehao0808/p/3623590.html)\n9. [迭代器(Iterator)](https://blog.csdn.net/Dove_Knowledge/article/details/71023512?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)","source":"_posts/c++记录.md","raw":"---\ntitle: c++记录\ndate: 2019-10-06 16:35:06\ncategories:\n- program\n\ntags:\n- c++\n---\n\n## g++编译\n    g++ -g -Wall -std=c++11 main.cpp\n    \n### 常用选项\n    -ansi\t只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n    -c\t只编译并生成目标文件。\n    -DMACRO\t以字符串\"1\"定义 MACRO 宏。\n    -DMACRO=DEFN\t以字符串\"DEFN\"定义 MACRO 宏。\n    -E\t只运行 C 预编译器。\n    -g\t生成调试信息。GNU 调试器可利用该信息。\n    -IDIRECTORY\t指定额外的头文件搜索路径DIRECTORY。\n    -LDIRECTORY\t指定额外的函数库搜索路径DIRECTORY。\n    -lLIBRARY\t连接时搜索指定的函数库LIBRARY。\n    -m486\t针对 486 进行代码优化。\n    -o\tFILE 生成指定的输出文件。用在生成可执行文件时。\n    -O0\t不进行优化处理。\n    -O\t或 -O1 优化生成代码。\n    -O2\t进一步优化。\n    -O3\t比 -O2 更进一步优化，包括 inline 函数。\n    -shared\t生成共享目标文件。通常用在建立共享库时。\n    -static\t禁止使用共享连接。\n    -UMACRO\t取消对 MACRO 宏的定义。\n    -w\t不生成任何警告信息。\n    -Wall\t生成所有警告信息。  \n    \n## enum 枚举类型\n可以和switch语句很好结合      \n1. 声明 enumType 为新的数据类型，称为**枚举**(enumeration) 可用来声明这种类型的变量,就像int a;\nMonday等为符号常量，**枚举量**，默认0-6\n也可以定义的类型的时候定义变量(还可以顺带初始化)      \n\n        enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};\n        enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday = Monday;\n      \n2. 枚举量赋值给非枚举量，因为枚举量是符号常量，赋值编译器自动把枚举量转换为int\n        \n        int a = Monday;\n        int a = Monday + 1;\n3. 非枚举量强制类型转换 赋值给枚举量\n        \n        Weekday = enumType(2);  #但要注意**不要超出枚举取值范围**，超出了不会报错，但是得不到想要的结果\n4. 自定义枚举常量的值， 这里Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5\n        \n        enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};\n注意：指定的值是**整数**,**未被初始化的枚举值的值默认将比其前面的枚举值大1**,**枚举量的值可以相同**        \n5. 强类型枚举\n传统c++问题：暴露在外层作用域，如果有相同枚举常量不行\n\n        enum Side{Right,Left};\n        enum Thing{Wrong,Right};\n        \n        #强枚举类型 只能使用 Enumeration::VAL1，单独的VAL1没有意义\n        enum class Enumeration{\n         VAL1,\n         VAL2,\n        };\n        \n## 左值 右值\n- **左值(lvalue)**：指向内存位置的表达式被称为左值表达式。可以出现在赋值号的左边和右边。 如变量\n- **右值(rvalue)**：存储在内存中某些地址的数值。不能对其进行赋值表达式，只能出现在赋值号右边。如数值型字面值 10\n\n## 变量初始化\n1. 局部变量：定义时系统不会对其初始化，需要自行初始化\n2. 全局变量：系统自动初始化为下列值\n- int\t    0\n- char\t    '\\0'\n- float\t    0\n- double\t0\n- pointer\tNULL\n\n## 限定符\n\n限定符\t含义\n- const\t类型的对象在程序执行期间不能被修改改变。\n- **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。\n对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率，\n比如编译器发现两次从i读取数据代码之间没有对i操作，优化结果就是直接用上次读到的值，(变量是寄存器变量或者端口数据时容易出错)\n用了volatile生成的汇编代码就会重新从i的地址读取数据\n\n    \n        volatile int i=10;  \n        int a = i;  \n        ...  \n        // 其他代码，并未明确告诉编译器，对 i 进行过操作  \n        int b = i;  \n        \n## 存储类\n1. **auto** 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。使用少c++11已删除\n2. **register** 变量**可能**在寄存器中，取决于硬件和实现的限制。如果在寄存器中，则不能进行**一元&**运算，因为没有内存位置。用于需要快速访问的量\n3. **static** 修饰全局变量：作用域限制在声明它的文件内。 局部变量：保持局部变量的值，只初始化一次\n        \n   1. static数据成员存储在程序静态存储区，独立于该类的任意对象，类对象和类都可以调用\n   2. static数据成员必须在**类外初始化**，不能在类中\n   3. static const int 可以在类定义内部初始化 其他string double 不可以\n4. **extern** 提供一个全局变量引用，使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。通常用于多个文件夹共享全局变量\n5. **mutable** 使用类对象，mutable成员可以通过const成员函数修改\n6. **thread_local** 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\n## 运算符优先级\n~ : 二进制补码运算\n![运算符优先级](运算符优先级.png)\n\n## lambda 函数与表达式\n匿名函数\n    \n    [capture](parameters)->return-type{body}\n在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。可以通过前面的[]来指定：\n    \n        []      // 沒有定义任何变量。使用未定义变量会引发错误。\n        [x, &y] // x以传值方式传入（默认），y以引用方式传入。\n        [&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n        [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。 一旦传值 就是常量\n        [&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n        [=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n        \n        //常值传递 copy一份 之后不变\n        int a=10;\n        auto func2 = [&]{return a + 1;};\n        cout << func1() << endl;\n        a++;\n        cout << func1() << endl;\n          \n        //mutable更改变量值\n        int a=10;\n        cout << [=]()mutable{return ++a;}() << endl;  //总是一个const函数，不能在函数体内修改非静态成员变量,这里是修改拷贝的参数,参数本身没有改变\n    \n1. 捕捉器，按值传递，相当于在表达式定义那一刻，表达式内就copy了一份变量，而且**值永远不变**，即使外部变量变了，这也不变\n2. 想在表达式内部修改变量的值，添加**mutable** \n\n### qt中的lambda表达式\n \n\n    QObject::connect(&newspaper, static_cast<void (Newspaper:: *)(const QString &)>(&Newspaper::newPaper),\n                    [=](const QString &name) \n                    { /* Your code here. */ }\n                    );\n这里实际函数调用的参数是从信号过来的所以不需要再赋值,下面就是调用匿名函数,a赋值为4\n\n    [](int a){cout << a}(4)                    \n\n\n   \n## 指向指针的指针\n    //函数如果要改变值就传入指针或这引用,要改变指针就得传入指针的指针,因为在函数参数传递是调用拷贝构造函数进行复制\n    int **var;   **var\n     \n## 虚继承\n菱形继承 子类多重拷贝：浪费空间，二义性\nclass B C 都继承自class A， 而class D继承自 B和C\n    \n    class A {virtual ~A()}    // 有的析构函数不是虚函数\n    class B : virtual public A;\n    class C : virtual public A;\n    class D : public B, public A;\nB C继承了A的数据成员和指向A的指针\nD继承了B C的数据成员和分别指向B C的指针\n\n## 运算符重载\n    classname operator++();   //前缀自增\n    classname operator++(int);  //后缀自增 加了int形参区分，形参是0，但在函数体内用不到\n->类成员访问运算符重载 返回类型必须是指针或者类对象 \n    \n    class Ptr{\n       //...\n       X * operator->();\n    };\n    void f(Ptr p )\n    {\n       p->m = 10 ; // (p.operator->())->m = 10\n    }\n    \n## 虚函数\n= 0 告诉编译器，函数没有主体，下面的虚函数是纯虚函数。\n\n    virtual int area() = 0;  \n    \n## c++ STL\n- Containers(容器)    deque list vector map\n- Algorithms(算法)\n- iterators(迭代器)    vector<int>::iterator v = vec.begin(); v++; 返回指向向量开头的迭代器   \n           \n## 文件和流\n如果一个数字太大,无法使用 setprecision 指定的有效数位数来打印,则许多系统会以科学表示法的方式打印.\n比如setprecision(5), 145678.99 输出 1.4568e+005\n\n为了让浮点输出以固定点或小数点表示法显示,使用流操作符fixed,结合setprecision(2)表示小数点后显示的位数\n    \n    log_file << std::fixed << std::setprecision(8) << force_sensor_val(0) << std::endl;\n\n### 文件输入输出流\n1. fstream ofstream ifstream\n    \n        void open(const char *filename, ios::openmode mode);   //文件流对象的成员函数\n    打开模式\n    - ios::app\t追加模式。所有写入都追加到文件末尾。\n    - ios::ate\t文件打开后定位到文件末尾。\n    - ios::in\t打开文件用于读取。\n    - ios::out\t打开文件用于写入。\n    - ios::trunc\t如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0。\n    - ios::binary   二进制方式打开，默认打开为文本方式\n    \n    常用函数\n    \n        getline(cin, string);   //当然也可以是 fileOgject从文件 ，cin是从键盘  好用 但是可能读取不到最后一行，如果最后一行没有回车\n        fileObject.getline(buf, size);\n2. 文件位置 istream成员函数seekg  ostream成员函数seekp\n    \n        fileObject.seekg(n);    //定位到第n个字节    \n        fileObject.seekg(n, ios::cur);    //当前位置后移n字节\n        fileObject.seekg(n, ios::end);    //末尾向前n字节\n        fileObject.seekg(0, ios::end);    //末尾\n3. cin.ignore(),默认参数cin.ignore(1,EOF),完整版本是 cin.ignore(int n, char a)\n从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。\n每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，\n则 cin.ignore()函数执行终止；否则，它继续等待。\n它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，\n消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,'\\n')，\n通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \\n 起作用，\n所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。\n        \n        int a,b;\n        cout<<\"input a:\";\n        cin>>a;\n        cin.ignore(1024, '\\n');\n        cout<<\"input b:\";\n        cin>>b;\n\n### 字符串输入输出流\n<sstream>直接对内存而不是对文件和标准输出(设备)进行操作\n\nstringstream istringstream   ostringstream\n同样可以使用seekp()移动写指针 seekg()重定位读指针\n    \n    //整数转字符串\n    #include <sstream>\n    \n    std::ostringstream oss;\n    int name_suffix = 1;\n    oss << name_suffix;\n    oss.str();       //返回一个新的string对象，替换内置的stringbuf\n    \n    // 设置输出精度,cout默认是6位有效数字\n    cout.precision(12); //设置为12位有效数字\n    printf(\"%.12f\",val);  //小数点后12位有效数字  \n    \n## 异常处理\n1. 抛出异常\n    关键字throw将创建程序抛出对象的拷贝,然后包含throw的函数返回了这个对象(即使函数返回值没有这个对象),\n    异常导致程序返回的地方和正常return返回的地方不一样.异常发生之前创建的局部对象也将析构(栈反解)\n        \n        throw \"Division by zero condition!\";   //类型为const char* 的异常 catch(const char* msg)\n        try{throw x;}catch(T& e){}   //可以抛出任意,包括内置类型 int,double...,后面用相应的类型来捕获.通常抛出异常创建的类    \n2. 捕获异常:\n    **异常处理器catch必须紧跟try之后,catch只会匹配第一个**,然后系统认为此异常已经处理了,不会继续查找下去,如果还想在抛,就必须throw\n        \n    如果没有任何一个层次的异常处理器匹配到异常,terminate()函数调用,在<exception>内,\n       \n        try\n        {\n           // 保护代码\n        }catch( ExceptionName e )    //捕获任何异常  (...)\n        {\n          // 处理 ExceptionName 异常的代码\n          throw;  //可以选择继续上抛,但是要保证这个throw仍然在try语句中(可以是上一层函数的try) 异常对象的所有信息被保留\n        }\n             \n    ![异常层次图](异常图.png)\n    ![异常说明](异常表.png)\n3. 异常安全\n    stack的pop()函数没有返回值,很重要的原因就是stack必须保证异常安全,如果为了得到返回值而调用复制构造函数,函数确抛出异常\n    导致没有获得栈顶元素,而且栈定指针下移了一个,这是不安全的,所以分成两步.        \n4. assert() 断言语句 用于开发阶段调试 #define NDEBUG 使其在最终发行软件中失效\n5. 定义自己的异常 最好从runtime_error或者logic_error继承(exception两个最主要的派生类) \n不要直接从exception继承(没有提供一个参数类型为std::string的构造函数)\n        \n        class MyError : public runtime_error{\n        public:\n            MyError(const string& msg = \"\") : runtime_error(msg){}\n        };\n        \n        int main(){\n            try{\n                throw MyError(\"my message\");\n            } catch (MyError & x){\n                cout<< x.what()<<endl;\n            }\n        } \n### 异常的使用\n1. 尽量使用引用来捕获异常\n    - 避免不必要的对象拷贝\n    - 派生类对象被当做基类对象捕获时,避免对象切割,损失信息\n2. 构造函数抛出异常时,必须注意对象内部的指针和它的清理方式\n3. 不要在析构函数中抛出异常\n    - 析构函数会在抛出其他异常的过程中别调用,避免析构函数抛出异常或者使用可能触发异常的语句(栈反解),导致程序调用teminate()\n    - 如果析构函数可能抛出异常,在析构函数内部编写try,catch,必须自己处理异常,不能抛出\n4. 避免悬挂指针(野指针)\n    构造函数抛出异常,而内部又有指针,因为指针没有析构函数,造成资源无法释放,可以使用智能指针,shared_ptr来处理指向堆内存的指针\n5. 处理简单错误尽量不用异常处理,只需要显示消息然后退出程序就可以了,然后把清理工作交给操作系统\n    cout<<\"error message\"<<endl;exit(1);             \n\n### exit函数\n    void exit(int value);  // 位于<cstdlib>中\n    exit(0);  //表示正常退出 退出整个进程.main函数要求返回值为int,在main中的exit相当于return\n\n## 类型转换\n- 转换很有用，但是在某些情况下，它强制编译器把一个数据看成比他实际更大的类型，占用更多空间，可能会破坏其他数据\n- 转换就是告诉编译器\"忘记类型检查　把它看成其他类型\"　编译器不会执行类型检查　引入了漏洞，程序出了问题，首先想到类型转换\n\n查看变量类型\n    \n    #include <typeinfo>\n    std::cout<<typeid(var).name()<<std::endl;\n\n1. C风格\n\n        int a = 200;\n        long b = (long)a;\n        long c = long(a);  //类似于函数调用\n2. c++显式转换\n比较容易发现转换的位置，定位bug\n\n    static_cast\n        \n        int a = 200;\n        long b = static_cast<long>(a);  //\n        static_cast<void (QSpinBox::*)(int)>(&QSpinBox::valueChanged);  //qt 函数指针\n    const_cast   const 到非const volatile 到非volatile\n    \n        const int i=0;\n        int* j = const_cast<int*>(&i);   // 不用转换是不能将赋值给非const指针\n        \n        volatile int k=0;\n        int* u = const_cast<int*>(&k);     \n               \n## 继承和组合\n1. 构造函数初始化列表\n针对问题：新类的构造函数没有权利访问子对象的私有数据成员，所以不能直接对他们初始化\n        \n        //Bar是基类，m是MyType的一个成员对象\n        MyType::MyType(int i): Bar(i),m(i+1){//...}\n- 自动析构函数调用：虽然常常需要在初始化列表中显式构造函数调用，但是不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且不屈任何参数\n- 构造函数调用次序是由成员对象在类中声明的次序决定。如果由　初始化列表的次序确定，则会有两个不同构造函数有两种不同调用构造函数顺序，那么析构函数不知道如何逆序调用。\n\n## 随机数发生器\n    #include <cstdlib>\n    #include <iostream>\n    #include <ctime>\n    \n    // time(0) 返回一个和时间相关的的数作为随机数种子,如果不设置或者设置一样的数那么运行产生的随机数都一样\n    srand(time(0));   \n    rand();           // 获取随机数 线性同余法 不是真的随机数 N(j+1) = (A*N(j)+B)(mod M)\n    \n[线性同余法](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95) \n                       \n## **待续...**\n## 动态内存\n## 命名空间\n## 模板\n## 预处理器\n## 信号处理\n## 多线程\n                    \n\n# const constexpr\n- const：大致意思是说我承诺不改变这个值，主要用于说明接口，这样变量传递给函数就不担心变量会在函数内被修改了,编译器负责确认并执行const的承诺。\n- constexpr：大致意思是在编译时求值，主要用于说明常量，作用是允许数据置于只读内存以及提升性能。\n    \nconstexpr的好处：\n\n- 是一种很强的约束，更好地保证程序的正确语义不被破坏。\n- 编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。\n- 相比宏来说，没有额外的开销，但更安全可靠。\n\n# 遇到的问题\n1. 不同vector 的iterator不能混用\n    \n    迭代器(Iterator)是一个对象，它的工作是遍历并选择序列中的对象，\n    它提供了一种访问一个容器(container)对象中的各个元素，\n    而又不必暴露该对象内部细节的方法。通过迭代器，\n    开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。\n    \n    指针用来遍历**连续存储结构**,迭代器针对容器(不管底层数据结构是否连续),提供堆容器遍历的方法\n    \n    下面这种方式出错,不能简单得把iterator当成一个索引      \n    \n        vector<int>::iterator index_vec_1 = find(vec_1.begin(), vec_1.end(), val);\n        //出错\n        vector<int>::iterator vec_2_new(vec_2.begin(), index_vec_1);  \n        // 正确\n        vector<int>::iterator vec_1_new(vec_1.begin(), index_vec_1);\n        vector<int>::iterator vec_2_new(vec_2.begin(), vec_1_new.size());\n        \n\n# 引用\n1. [C++之enum枚举量声明、定义、使用与枚举类详解](https://blog.csdn.net/Bruce_0712/article/details/54984371)\n2. [C++ 教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)\n3. [C++中volatile关键字的使用详解](https://blog.csdn.net/zyx_0604/article/details/80689673)\n4. [c++中static数据成员，static成员函数](https://www.cnblogs.com/yyxt/p/4802688.html)\n5. [c++中lambda表达式的用法](https://blog.csdn.net/iloveyousunna/article/details/78532398)\n6. [C++中虚继承的作用及底层实现原理](https://blog.csdn.net/bxw1992/article/details/77726390)\n7. [关于constexpr与const](https://blog.csdn.net/qq_22274565/article/details/78719951)\n8. [C++中的const和constexpr](https://www.cnblogs.com/wodehao0808/p/3623590.html)\n9. [迭代器(Iterator)](https://blog.csdn.net/Dove_Knowledge/article/details/71023512?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)","slug":"c++记录","published":1,"updated":"2020-11-14T13:51:30.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhub3ckk007qmxka2mzpc0lz","content":"<h2 id=\"g-编译\"><a href=\"#g-编译\" class=\"headerlink\" title=\"g++编译\"></a>g++编译</h2><pre><code>g++ -g -Wall -std=c++11 main.cpp\n</code></pre><h3 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a>常用选项</h3><pre><code>-ansi    只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n-c    只编译并生成目标文件。\n-DMACRO    以字符串&quot;1&quot;定义 MACRO 宏。\n-DMACRO=DEFN    以字符串&quot;DEFN&quot;定义 MACRO 宏。\n-E    只运行 C 预编译器。\n-g    生成调试信息。GNU 调试器可利用该信息。\n-IDIRECTORY    指定额外的头文件搜索路径DIRECTORY。\n-LDIRECTORY    指定额外的函数库搜索路径DIRECTORY。\n-lLIBRARY    连接时搜索指定的函数库LIBRARY。\n-m486    针对 486 进行代码优化。\n-o    FILE 生成指定的输出文件。用在生成可执行文件时。\n-O0    不进行优化处理。\n-O    或 -O1 优化生成代码。\n-O2    进一步优化。\n-O3    比 -O2 更进一步优化，包括 inline 函数。\n-shared    生成共享目标文件。通常用在建立共享库时。\n-static    禁止使用共享连接。\n-UMACRO    取消对 MACRO 宏的定义。\n-w    不生成任何警告信息。\n-Wall    生成所有警告信息。  \n</code></pre><h2 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum 枚举类型\"></a>enum 枚举类型</h2><p>可以和switch语句很好结合      </p>\n<ol>\n<li><p>声明 enumType 为新的数据类型，称为<strong>枚举</strong>(enumeration) 可用来声明这种类型的变量,就像int a;<br>Monday等为符号常量，<strong>枚举量</strong>，默认0-6<br>也可以定义的类型的时候定义变量(还可以顺带初始化)      </p>\n<pre><code> enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};\n enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday = Monday;\n</code></pre></li>\n<li><p>枚举量赋值给非枚举量，因为枚举量是符号常量，赋值编译器自动把枚举量转换为int</p>\n<pre><code> int a = Monday;\n int a = Monday + 1;\n</code></pre></li>\n<li><p>非枚举量强制类型转换 赋值给枚举量</p>\n<pre><code> Weekday = enumType(2);  #但要注意**不要超出枚举取值范围**，超出了不会报错，但是得不到想要的结果\n</code></pre></li>\n<li><p>自定义枚举常量的值， 这里Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5</p>\n<pre><code> enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};\n</code></pre><p>注意：指定的值是<strong>整数</strong>,<strong>未被初始化的枚举值的值默认将比其前面的枚举值大1</strong>,<strong>枚举量的值可以相同</strong>        </p>\n</li>\n<li><p>强类型枚举<br>传统c++问题：暴露在外层作用域，如果有相同枚举常量不行</p>\n<pre><code> enum Side{Right,Left};\n enum Thing{Wrong,Right};\n\n #强枚举类型 只能使用 Enumeration::VAL1，单独的VAL1没有意义\n enum class Enumeration{\n  VAL1,\n  VAL2,\n };\n</code></pre></li>\n</ol>\n<h2 id=\"左值-右值\"><a href=\"#左值-右值\" class=\"headerlink\" title=\"左值 右值\"></a>左值 右值</h2><ul>\n<li><strong>左值(lvalue)</strong>：指向内存位置的表达式被称为左值表达式。可以出现在赋值号的左边和右边。 如变量</li>\n<li><strong>右值(rvalue)</strong>：存储在内存中某些地址的数值。不能对其进行赋值表达式，只能出现在赋值号右边。如数值型字面值 10</li>\n</ul>\n<h2 id=\"变量初始化\"><a href=\"#变量初始化\" class=\"headerlink\" title=\"变量初始化\"></a>变量初始化</h2><ol>\n<li>局部变量：定义时系统不会对其初始化，需要自行初始化</li>\n<li>全局变量：系统自动初始化为下列值</li>\n</ol>\n<ul>\n<li>int        0</li>\n<li>char        ‘\\0’</li>\n<li>float        0</li>\n<li>double    0</li>\n<li>pointer    NULL</li>\n</ul>\n<h2 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h2><p>限定符    含义</p>\n<ul>\n<li>const    类型的对象在程序执行期间不能被修改改变。</li>\n<li><strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。<br>对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率，<br>比如编译器发现两次从i读取数据代码之间没有对i操作，优化结果就是直接用上次读到的值，(变量是寄存器变量或者端口数据时容易出错)<br>用了volatile生成的汇编代码就会重新从i的地址读取数据</li>\n</ul>\n<pre><code>    volatile int i=10;  \n    int a = i;  \n    ...  \n    // 其他代码，并未明确告诉编译器，对 i 进行过操作  \n    int b = i;  \n</code></pre><h2 id=\"存储类\"><a href=\"#存储类\" class=\"headerlink\" title=\"存储类\"></a>存储类</h2><ol>\n<li><strong>auto</strong> 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。使用少c++11已删除</li>\n<li><strong>register</strong> 变量<strong>可能</strong>在寄存器中，取决于硬件和实现的限制。如果在寄存器中，则不能进行<strong>一元&amp;</strong>运算，因为没有内存位置。用于需要快速访问的量</li>\n<li><p><strong>static</strong> 修饰全局变量：作用域限制在声明它的文件内。 局部变量：保持局部变量的值，只初始化一次</p>\n<ol>\n<li>static数据成员存储在程序静态存储区，独立于该类的任意对象，类对象和类都可以调用</li>\n<li>static数据成员必须在<strong>类外初始化</strong>，不能在类中</li>\n<li>static const int 可以在类定义内部初始化 其他string double 不可以</li>\n</ol>\n</li>\n<li><strong>extern</strong> 提供一个全局变量引用，使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。通常用于多个文件夹共享全局变量</li>\n<li><strong>mutable</strong> 使用类对象，mutable成员可以通过const成员函数修改</li>\n<li><strong>thread_local</strong> 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</li>\n</ol>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h2><p>~ : 二进制补码运算<br><img src=\"/2019/10/06/c++记录/运算符优先级.png\" alt=\"运算符优先级\"></p>\n<h2 id=\"lambda-函数与表达式\"><a href=\"#lambda-函数与表达式\" class=\"headerlink\" title=\"lambda 函数与表达式\"></a>lambda 函数与表达式</h2><p>匿名函数</p>\n<pre><code>[capture](parameters)-&gt;return-type{body}\n</code></pre><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。可以通过前面的[]来指定：</p>\n<pre><code>    []      // 沒有定义任何变量。使用未定义变量会引发错误。\n    [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。\n    [&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。 一旦传值 就是常量\n    [&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n    [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n\n    //常值传递 copy一份 之后不变\n    int a=10;\n    auto func2 = [&amp;]{return a + 1;};\n    cout &lt;&lt; func1() &lt;&lt; endl;\n    a++;\n    cout &lt;&lt; func1() &lt;&lt; endl;\n\n    //mutable更改变量值\n    int a=10;\n    cout &lt;&lt; [=]()mutable{return ++a;}() &lt;&lt; endl;  //总是一个const函数，不能在函数体内修改非静态成员变量,这里是修改拷贝的参数,参数本身没有改变\n</code></pre><ol>\n<li>捕捉器，按值传递，相当于在表达式定义那一刻，表达式内就copy了一份变量，而且<strong>值永远不变</strong>，即使外部变量变了，这也不变</li>\n<li>想在表达式内部修改变量的值，添加<strong>mutable</strong> </li>\n</ol>\n<h3 id=\"qt中的lambda表达式\"><a href=\"#qt中的lambda表达式\" class=\"headerlink\" title=\"qt中的lambda表达式\"></a>qt中的lambda表达式</h3><pre><code>QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),\n                [=](const QString &amp;name) \n                { /* Your code here. */ }\n                );\n</code></pre><p>这里实际函数调用的参数是从信号过来的所以不需要再赋值,下面就是调用匿名函数,a赋值为4</p>\n<pre><code>[](int a){cout &lt;&lt; a}(4)                    \n</code></pre><h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><pre><code>//函数如果要改变值就传入指针或这引用,要改变指针就得传入指针的指针,因为在函数参数传递是调用拷贝构造函数进行复制\nint **var;   **var\n</code></pre><h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>菱形继承 子类多重拷贝：浪费空间，二义性<br>class B C 都继承自class A， 而class D继承自 B和C</p>\n<pre><code>class A {virtual ~A()}    // 有的析构函数不是虚函数\nclass B : virtual public A;\nclass C : virtual public A;\nclass D : public B, public A;\n</code></pre><p>B C继承了A的数据成员和指向A的指针<br>D继承了B C的数据成员和分别指向B C的指针</p>\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><pre><code>classname operator++();   //前缀自增\nclassname operator++(int);  //后缀自增 加了int形参区分，形参是0，但在函数体内用不到\n</code></pre><p>-&gt;类成员访问运算符重载 返回类型必须是指针或者类对象 </p>\n<pre><code>class Ptr{\n   //...\n   X * operator-&gt;();\n};\nvoid f(Ptr p )\n{\n   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10\n}\n</code></pre><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>= 0 告诉编译器，函数没有主体，下面的虚函数是纯虚函数。</p>\n<pre><code>virtual int area() = 0;  \n</code></pre><h2 id=\"c-STL\"><a href=\"#c-STL\" class=\"headerlink\" title=\"c++ STL\"></a>c++ STL</h2><ul>\n<li>Containers(容器)    deque list vector map</li>\n<li>Algorithms(算法)</li>\n<li>iterators(迭代器)    vector<int>::iterator v = vec.begin(); v++; 返回指向向量开头的迭代器   </int></li>\n</ul>\n<h2 id=\"文件和流\"><a href=\"#文件和流\" class=\"headerlink\" title=\"文件和流\"></a>文件和流</h2><p>如果一个数字太大,无法使用 setprecision 指定的有效数位数来打印,则许多系统会以科学表示法的方式打印.<br>比如setprecision(5), 145678.99 输出 1.4568e+005</p>\n<p>为了让浮点输出以固定点或小数点表示法显示,使用流操作符fixed,结合setprecision(2)表示小数点后显示的位数</p>\n<pre><code>log_file &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; force_sensor_val(0) &lt;&lt; std::endl;\n</code></pre><h3 id=\"文件输入输出流\"><a href=\"#文件输入输出流\" class=\"headerlink\" title=\"文件输入输出流\"></a>文件输入输出流</h3><ol>\n<li><p>fstream ofstream ifstream</p>\n<pre><code> void open(const char *filename, ios::openmode mode);   //文件流对象的成员函数\n</code></pre><p> 打开模式</p>\n<ul>\n<li>ios::app    追加模式。所有写入都追加到文件末尾。</li>\n<li>ios::ate    文件打开后定位到文件末尾。</li>\n<li>ios::in    打开文件用于读取。</li>\n<li>ios::out    打开文件用于写入。</li>\n<li>ios::trunc    如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0。</li>\n<li><p>ios::binary   二进制方式打开，默认打开为文本方式</p>\n<p>常用函数</p>\n<p>  getline(cin, string);   //当然也可以是 fileOgject从文件 ，cin是从键盘  好用 但是可能读取不到最后一行，如果最后一行没有回车<br>  fileObject.getline(buf, size);</p>\n</li>\n</ul>\n</li>\n<li><p>文件位置 istream成员函数seekg  ostream成员函数seekp</p>\n<pre><code> fileObject.seekg(n);    //定位到第n个字节    \n fileObject.seekg(n, ios::cur);    //当前位置后移n字节\n fileObject.seekg(n, ios::end);    //末尾向前n字节\n fileObject.seekg(0, ios::end);    //末尾\n</code></pre></li>\n<li><p>cin.ignore(),默认参数cin.ignore(1,EOF),完整版本是 cin.ignore(int n, char a)<br>从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。<br>每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，<br>则 cin.ignore()函数执行终止；否则，它继续等待。<br>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，<br>消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,’\\n’)，<br>通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \\n 起作用，<br>所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。</p>\n<pre><code> int a,b;\n cout&lt;&lt;&quot;input a:&quot;;\n cin&gt;&gt;a;\n cin.ignore(1024, &#39;\\n&#39;);\n cout&lt;&lt;&quot;input b:&quot;;\n cin&gt;&gt;b;\n</code></pre></li>\n</ol>\n<h3 id=\"字符串输入输出流\"><a href=\"#字符串输入输出流\" class=\"headerlink\" title=\"字符串输入输出流\"></a>字符串输入输出流</h3><p><sstream>直接对内存而不是对文件和标准输出(设备)进行操作</sstream></p>\n<p>stringstream istringstream   ostringstream<br>同样可以使用seekp()移动写指针 seekg()重定位读指针</p>\n<pre><code>//整数转字符串\n#include &lt;sstream&gt;\n\nstd::ostringstream oss;\nint name_suffix = 1;\noss &lt;&lt; name_suffix;\noss.str();       //返回一个新的string对象，替换内置的stringbuf\n\n// 设置输出精度,cout默认是6位有效数字\ncout.precision(12); //设置为12位有效数字\nprintf(&quot;%.12f&quot;,val);  //小数点后12位有效数字  \n</code></pre><h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><ol>\n<li><p>抛出异常<br> 关键字throw将创建程序抛出对象的拷贝,然后包含throw的函数返回了这个对象(即使函数返回值没有这个对象),<br> 异常导致程序返回的地方和正常return返回的地方不一样.异常发生之前创建的局部对象也将析构(栈反解)</p>\n<pre><code> throw &quot;Division by zero condition!&quot;;   //类型为const char* 的异常 catch(const char* msg)\n try{throw x;}catch(T&amp; e){}   //可以抛出任意,包括内置类型 int,double...,后面用相应的类型来捕获.通常抛出异常创建的类    \n</code></pre></li>\n<li><p>捕获异常:<br> <strong>异常处理器catch必须紧跟try之后,catch只会匹配第一个</strong>,然后系统认为此异常已经处理了,不会继续查找下去,如果还想在抛,就必须throw</p>\n<p> 如果没有任何一个层次的异常处理器匹配到异常,terminate()函数调用,在<exception>内,</exception></p>\n<pre><code> try\n {\n    // 保护代码\n }catch( ExceptionName e )    //捕获任何异常  (...)\n {\n   // 处理 ExceptionName 异常的代码\n   throw;  //可以选择继续上抛,但是要保证这个throw仍然在try语句中(可以是上一层函数的try) 异常对象的所有信息被保留\n }\n</code></pre><p> <img src=\"/2019/10/06/c++记录/异常图.png\" alt=\"异常层次图\"><br> <img src=\"/2019/10/06/c++记录/异常表.png\" alt=\"异常说明\"></p>\n</li>\n<li>异常安全<br> stack的pop()函数没有返回值,很重要的原因就是stack必须保证异常安全,如果为了得到返回值而调用复制构造函数,函数确抛出异常<br> 导致没有获得栈顶元素,而且栈定指针下移了一个,这是不安全的,所以分成两步.        </li>\n<li>assert() 断言语句 用于开发阶段调试 #define NDEBUG 使其在最终发行软件中失效</li>\n<li><p>定义自己的异常 最好从runtime_error或者logic_error继承(exception两个最主要的派生类)<br>不要直接从exception继承(没有提供一个参数类型为std::string的构造函数)</p>\n<pre><code> class MyError : public runtime_error{\n public:\n     MyError(const string&amp; msg = &quot;&quot;) : runtime_error(msg){}\n };\n\n int main(){\n     try{\n         throw MyError(&quot;my message&quot;);\n     } catch (MyError &amp; x){\n         cout&lt;&lt; x.what()&lt;&lt;endl;\n     }\n } \n</code></pre><h3 id=\"异常的使用\"><a href=\"#异常的使用\" class=\"headerlink\" title=\"异常的使用\"></a>异常的使用</h3></li>\n<li>尽量使用引用来捕获异常<ul>\n<li>避免不必要的对象拷贝</li>\n<li>派生类对象被当做基类对象捕获时,避免对象切割,损失信息</li>\n</ul>\n</li>\n<li>构造函数抛出异常时,必须注意对象内部的指针和它的清理方式</li>\n<li>不要在析构函数中抛出异常<ul>\n<li>析构函数会在抛出其他异常的过程中别调用,避免析构函数抛出异常或者使用可能触发异常的语句(栈反解),导致程序调用teminate()</li>\n<li>如果析构函数可能抛出异常,在析构函数内部编写try,catch,必须自己处理异常,不能抛出</li>\n</ul>\n</li>\n<li>避免悬挂指针(野指针)<br> 构造函数抛出异常,而内部又有指针,因为指针没有析构函数,造成资源无法释放,可以使用智能指针,shared_ptr来处理指向堆内存的指针</li>\n<li>处理简单错误尽量不用异常处理,只需要显示消息然后退出程序就可以了,然后把清理工作交给操作系统<br> cout&lt;&lt;”error message”&lt;&lt;endl;exit(1);             </li>\n</ol>\n<h3 id=\"exit函数\"><a href=\"#exit函数\" class=\"headerlink\" title=\"exit函数\"></a>exit函数</h3><pre><code>void exit(int value);  // 位于&lt;cstdlib&gt;中\nexit(0);  //表示正常退出 退出整个进程.main函数要求返回值为int,在main中的exit相当于return\n</code></pre><h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ul>\n<li>转换很有用，但是在某些情况下，它强制编译器把一个数据看成比他实际更大的类型，占用更多空间，可能会破坏其他数据</li>\n<li>转换就是告诉编译器”忘记类型检查　把它看成其他类型”　编译器不会执行类型检查　引入了漏洞，程序出了问题，首先想到类型转换</li>\n</ul>\n<p>查看变量类型</p>\n<pre><code>#include &lt;typeinfo&gt;\nstd::cout&lt;&lt;typeid(var).name()&lt;&lt;std::endl;\n</code></pre><ol>\n<li><p>C风格</p>\n<pre><code> int a = 200;\n long b = (long)a;\n long c = long(a);  //类似于函数调用\n</code></pre></li>\n<li><p>c++显式转换<br>比较容易发现转换的位置，定位bug</p>\n<p> static_cast</p>\n<pre><code> int a = 200;\n long b = static_cast&lt;long&gt;(a);  //\n static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged);  //qt 函数指针\n</code></pre><p> const_cast   const 到非const volatile 到非volatile</p>\n<pre><code> const int i=0;\n int* j = const_cast&lt;int*&gt;(&amp;i);   // 不用转换是不能将赋值给非const指针\n\n volatile int k=0;\n int* u = const_cast&lt;int*&gt;(&amp;k);     \n</code></pre></li>\n</ol>\n<h2 id=\"继承和组合\"><a href=\"#继承和组合\" class=\"headerlink\" title=\"继承和组合\"></a>继承和组合</h2><ol>\n<li><p>构造函数初始化列表<br>针对问题：新类的构造函数没有权利访问子对象的私有数据成员，所以不能直接对他们初始化</p>\n<pre><code> //Bar是基类，m是MyType的一个成员对象\n MyType::MyType(int i): Bar(i),m(i+1){//...}\n</code></pre></li>\n</ol>\n<ul>\n<li>自动析构函数调用：虽然常常需要在初始化列表中显式构造函数调用，但是不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且不屈任何参数</li>\n<li>构造函数调用次序是由成员对象在类中声明的次序决定。如果由　初始化列表的次序确定，则会有两个不同构造函数有两种不同调用构造函数顺序，那么析构函数不知道如何逆序调用。</li>\n</ul>\n<h2 id=\"随机数发生器\"><a href=\"#随机数发生器\" class=\"headerlink\" title=\"随机数发生器\"></a>随机数发生器</h2><pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\n// time(0) 返回一个和时间相关的的数作为随机数种子,如果不设置或者设置一样的数那么运行产生的随机数都一样\nsrand(time(0));   \nrand();           // 获取随机数 线性同余法 不是真的随机数 N(j+1) = (A*N(j)+B)(mod M)\n</code></pre><p><a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">线性同余法</a> </p>\n<h2 id=\"待续…\"><a href=\"#待续…\" class=\"headerlink\" title=\"待续…\"></a><strong>待续…</strong></h2><h2 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h2><h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><h2 id=\"预处理器\"><a href=\"#预处理器\" class=\"headerlink\" title=\"预处理器\"></a>预处理器</h2><h2 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h2><h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h1 id=\"const-constexpr\"><a href=\"#const-constexpr\" class=\"headerlink\" title=\"const constexpr\"></a>const constexpr</h1><ul>\n<li>const：大致意思是说我承诺不改变这个值，主要用于说明接口，这样变量传递给函数就不担心变量会在函数内被修改了,编译器负责确认并执行const的承诺。</li>\n<li>constexpr：大致意思是在编译时求值，主要用于说明常量，作用是允许数据置于只读内存以及提升性能。</li>\n</ul>\n<p>constexpr的好处：</p>\n<ul>\n<li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li>\n<li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li>\n<li>相比宏来说，没有额外的开销，但更安全可靠。</li>\n</ul>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><ol>\n<li><p>不同vector 的iterator不能混用</p>\n<p> 迭代器(Iterator)是一个对象，它的工作是遍历并选择序列中的对象，<br> 它提供了一种访问一个容器(container)对象中的各个元素，<br> 而又不必暴露该对象内部细节的方法。通过迭代器，<br> 开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。</p>\n<p> 指针用来遍历<strong>连续存储结构</strong>,迭代器针对容器(不管底层数据结构是否连续),提供堆容器遍历的方法</p>\n<p> 下面这种方式出错,不能简单得把iterator当成一个索引      </p>\n<pre><code> vector&lt;int&gt;::iterator index_vec_1 = find(vec_1.begin(), vec_1.end(), val);\n //出错\n vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), index_vec_1);  \n // 正确\n vector&lt;int&gt;::iterator vec_1_new(vec_1.begin(), index_vec_1);\n vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), vec_1_new.size());\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/Bruce_0712/article/details/54984371\" target=\"_blank\" rel=\"noopener\">C++之enum枚举量声明、定义、使用与枚举类详解</a></li>\n<li><a href=\"https://www.runoob.com/cplusplus/cpp-tutorial.html\" target=\"_blank\" rel=\"noopener\">C++ 教程</a></li>\n<li><a href=\"https://blog.csdn.net/zyx_0604/article/details/80689673\" target=\"_blank\" rel=\"noopener\">C++中volatile关键字的使用详解</a></li>\n<li><a href=\"https://www.cnblogs.com/yyxt/p/4802688.html\" target=\"_blank\" rel=\"noopener\">c++中static数据成员，static成员函数</a></li>\n<li><a href=\"https://blog.csdn.net/iloveyousunna/article/details/78532398\" target=\"_blank\" rel=\"noopener\">c++中lambda表达式的用法</a></li>\n<li><a href=\"https://blog.csdn.net/bxw1992/article/details/77726390\" target=\"_blank\" rel=\"noopener\">C++中虚继承的作用及底层实现原理</a></li>\n<li><a href=\"https://blog.csdn.net/qq_22274565/article/details/78719951\" target=\"_blank\" rel=\"noopener\">关于constexpr与const</a></li>\n<li><a href=\"https://www.cnblogs.com/wodehao0808/p/3623590.html\" target=\"_blank\" rel=\"noopener\">C++中的const和constexpr</a></li>\n<li><a href=\"https://blog.csdn.net/Dove_Knowledge/article/details/71023512?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">迭代器(Iterator)</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"g-编译\"><a href=\"#g-编译\" class=\"headerlink\" title=\"g++编译\"></a>g++编译</h2><pre><code>g++ -g -Wall -std=c++11 main.cpp\n</code></pre><h3 id=\"常用选项\"><a href=\"#常用选项\" class=\"headerlink\" title=\"常用选项\"></a>常用选项</h3><pre><code>-ansi    只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n-c    只编译并生成目标文件。\n-DMACRO    以字符串&quot;1&quot;定义 MACRO 宏。\n-DMACRO=DEFN    以字符串&quot;DEFN&quot;定义 MACRO 宏。\n-E    只运行 C 预编译器。\n-g    生成调试信息。GNU 调试器可利用该信息。\n-IDIRECTORY    指定额外的头文件搜索路径DIRECTORY。\n-LDIRECTORY    指定额外的函数库搜索路径DIRECTORY。\n-lLIBRARY    连接时搜索指定的函数库LIBRARY。\n-m486    针对 486 进行代码优化。\n-o    FILE 生成指定的输出文件。用在生成可执行文件时。\n-O0    不进行优化处理。\n-O    或 -O1 优化生成代码。\n-O2    进一步优化。\n-O3    比 -O2 更进一步优化，包括 inline 函数。\n-shared    生成共享目标文件。通常用在建立共享库时。\n-static    禁止使用共享连接。\n-UMACRO    取消对 MACRO 宏的定义。\n-w    不生成任何警告信息。\n-Wall    生成所有警告信息。  \n</code></pre><h2 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum 枚举类型\"></a>enum 枚举类型</h2><p>可以和switch语句很好结合      </p>\n<ol>\n<li><p>声明 enumType 为新的数据类型，称为<strong>枚举</strong>(enumeration) 可用来声明这种类型的变量,就像int a;<br>Monday等为符号常量，<strong>枚举量</strong>，默认0-6<br>也可以定义的类型的时候定义变量(还可以顺带初始化)      </p>\n<pre><code> enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};\n enum enumType {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}Weekday = Monday;\n</code></pre></li>\n<li><p>枚举量赋值给非枚举量，因为枚举量是符号常量，赋值编译器自动把枚举量转换为int</p>\n<pre><code> int a = Monday;\n int a = Monday + 1;\n</code></pre></li>\n<li><p>非枚举量强制类型转换 赋值给枚举量</p>\n<pre><code> Weekday = enumType(2);  #但要注意**不要超出枚举取值范围**，超出了不会报错，但是得不到想要的结果\n</code></pre></li>\n<li><p>自定义枚举常量的值， 这里Monday、Wednesday均被定义为1，则Tuesday=2，Thursday、Friday、Saturday、Sunday的值默认分别为2、3、4、5</p>\n<pre><code> enum enumType {Monday=1, Tuesday, Wednesday=1, Thursday, Friday, Saturday, Sunday};\n</code></pre><p>注意：指定的值是<strong>整数</strong>,<strong>未被初始化的枚举值的值默认将比其前面的枚举值大1</strong>,<strong>枚举量的值可以相同</strong>        </p>\n</li>\n<li><p>强类型枚举<br>传统c++问题：暴露在外层作用域，如果有相同枚举常量不行</p>\n<pre><code> enum Side{Right,Left};\n enum Thing{Wrong,Right};\n\n #强枚举类型 只能使用 Enumeration::VAL1，单独的VAL1没有意义\n enum class Enumeration{\n  VAL1,\n  VAL2,\n };\n</code></pre></li>\n</ol>\n<h2 id=\"左值-右值\"><a href=\"#左值-右值\" class=\"headerlink\" title=\"左值 右值\"></a>左值 右值</h2><ul>\n<li><strong>左值(lvalue)</strong>：指向内存位置的表达式被称为左值表达式。可以出现在赋值号的左边和右边。 如变量</li>\n<li><strong>右值(rvalue)</strong>：存储在内存中某些地址的数值。不能对其进行赋值表达式，只能出现在赋值号右边。如数值型字面值 10</li>\n</ul>\n<h2 id=\"变量初始化\"><a href=\"#变量初始化\" class=\"headerlink\" title=\"变量初始化\"></a>变量初始化</h2><ol>\n<li>局部变量：定义时系统不会对其初始化，需要自行初始化</li>\n<li>全局变量：系统自动初始化为下列值</li>\n</ol>\n<ul>\n<li>int        0</li>\n<li>char        ‘\\0’</li>\n<li>float        0</li>\n<li>double    0</li>\n<li>pointer    NULL</li>\n</ul>\n<h2 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h2><p>限定符    含义</p>\n<ul>\n<li>const    类型的对象在程序执行期间不能被修改改变。</li>\n<li><strong>volatile</strong> 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。<br>对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率，<br>比如编译器发现两次从i读取数据代码之间没有对i操作，优化结果就是直接用上次读到的值，(变量是寄存器变量或者端口数据时容易出错)<br>用了volatile生成的汇编代码就会重新从i的地址读取数据</li>\n</ul>\n<pre><code>    volatile int i=10;  \n    int a = i;  \n    ...  \n    // 其他代码，并未明确告诉编译器，对 i 进行过操作  \n    int b = i;  \n</code></pre><h2 id=\"存储类\"><a href=\"#存储类\" class=\"headerlink\" title=\"存储类\"></a>存储类</h2><ol>\n<li><strong>auto</strong> 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。使用少c++11已删除</li>\n<li><strong>register</strong> 变量<strong>可能</strong>在寄存器中，取决于硬件和实现的限制。如果在寄存器中，则不能进行<strong>一元&amp;</strong>运算，因为没有内存位置。用于需要快速访问的量</li>\n<li><p><strong>static</strong> 修饰全局变量：作用域限制在声明它的文件内。 局部变量：保持局部变量的值，只初始化一次</p>\n<ol>\n<li>static数据成员存储在程序静态存储区，独立于该类的任意对象，类对象和类都可以调用</li>\n<li>static数据成员必须在<strong>类外初始化</strong>，不能在类中</li>\n<li>static const int 可以在类定义内部初始化 其他string double 不可以</li>\n</ol>\n</li>\n<li><strong>extern</strong> 提供一个全局变量引用，使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。通常用于多个文件夹共享全局变量</li>\n<li><strong>mutable</strong> 使用类对象，mutable成员可以通过const成员函数修改</li>\n<li><strong>thread_local</strong> 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</li>\n</ol>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h2><p>~ : 二进制补码运算<br><img src=\"/2019/10/06/c++记录/运算符优先级.png\" alt=\"运算符优先级\"></p>\n<h2 id=\"lambda-函数与表达式\"><a href=\"#lambda-函数与表达式\" class=\"headerlink\" title=\"lambda 函数与表达式\"></a>lambda 函数与表达式</h2><p>匿名函数</p>\n<pre><code>[capture](parameters)-&gt;return-type{body}\n</code></pre><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。可以通过前面的[]来指定：</p>\n<pre><code>    []      // 沒有定义任何变量。使用未定义变量会引发错误。\n    [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。\n    [&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。\n    [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。 一旦传值 就是常量\n    [&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。\n    [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。\n\n    //常值传递 copy一份 之后不变\n    int a=10;\n    auto func2 = [&amp;]{return a + 1;};\n    cout &lt;&lt; func1() &lt;&lt; endl;\n    a++;\n    cout &lt;&lt; func1() &lt;&lt; endl;\n\n    //mutable更改变量值\n    int a=10;\n    cout &lt;&lt; [=]()mutable{return ++a;}() &lt;&lt; endl;  //总是一个const函数，不能在函数体内修改非静态成员变量,这里是修改拷贝的参数,参数本身没有改变\n</code></pre><ol>\n<li>捕捉器，按值传递，相当于在表达式定义那一刻，表达式内就copy了一份变量，而且<strong>值永远不变</strong>，即使外部变量变了，这也不变</li>\n<li>想在表达式内部修改变量的值，添加<strong>mutable</strong> </li>\n</ol>\n<h3 id=\"qt中的lambda表达式\"><a href=\"#qt中的lambda表达式\" class=\"headerlink\" title=\"qt中的lambda表达式\"></a>qt中的lambda表达式</h3><pre><code>QObject::connect(&amp;newspaper, static_cast&lt;void (Newspaper:: *)(const QString &amp;)&gt;(&amp;Newspaper::newPaper),\n                [=](const QString &amp;name) \n                { /* Your code here. */ }\n                );\n</code></pre><p>这里实际函数调用的参数是从信号过来的所以不需要再赋值,下面就是调用匿名函数,a赋值为4</p>\n<pre><code>[](int a){cout &lt;&lt; a}(4)                    \n</code></pre><h2 id=\"指向指针的指针\"><a href=\"#指向指针的指针\" class=\"headerlink\" title=\"指向指针的指针\"></a>指向指针的指针</h2><pre><code>//函数如果要改变值就传入指针或这引用,要改变指针就得传入指针的指针,因为在函数参数传递是调用拷贝构造函数进行复制\nint **var;   **var\n</code></pre><h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>菱形继承 子类多重拷贝：浪费空间，二义性<br>class B C 都继承自class A， 而class D继承自 B和C</p>\n<pre><code>class A {virtual ~A()}    // 有的析构函数不是虚函数\nclass B : virtual public A;\nclass C : virtual public A;\nclass D : public B, public A;\n</code></pre><p>B C继承了A的数据成员和指向A的指针<br>D继承了B C的数据成员和分别指向B C的指针</p>\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><pre><code>classname operator++();   //前缀自增\nclassname operator++(int);  //后缀自增 加了int形参区分，形参是0，但在函数体内用不到\n</code></pre><p>-&gt;类成员访问运算符重载 返回类型必须是指针或者类对象 </p>\n<pre><code>class Ptr{\n   //...\n   X * operator-&gt;();\n};\nvoid f(Ptr p )\n{\n   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10\n}\n</code></pre><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>= 0 告诉编译器，函数没有主体，下面的虚函数是纯虚函数。</p>\n<pre><code>virtual int area() = 0;  \n</code></pre><h2 id=\"c-STL\"><a href=\"#c-STL\" class=\"headerlink\" title=\"c++ STL\"></a>c++ STL</h2><ul>\n<li>Containers(容器)    deque list vector map</li>\n<li>Algorithms(算法)</li>\n<li>iterators(迭代器)    vector<int>::iterator v = vec.begin(); v++; 返回指向向量开头的迭代器   </int></li>\n</ul>\n<h2 id=\"文件和流\"><a href=\"#文件和流\" class=\"headerlink\" title=\"文件和流\"></a>文件和流</h2><p>如果一个数字太大,无法使用 setprecision 指定的有效数位数来打印,则许多系统会以科学表示法的方式打印.<br>比如setprecision(5), 145678.99 输出 1.4568e+005</p>\n<p>为了让浮点输出以固定点或小数点表示法显示,使用流操作符fixed,结合setprecision(2)表示小数点后显示的位数</p>\n<pre><code>log_file &lt;&lt; std::fixed &lt;&lt; std::setprecision(8) &lt;&lt; force_sensor_val(0) &lt;&lt; std::endl;\n</code></pre><h3 id=\"文件输入输出流\"><a href=\"#文件输入输出流\" class=\"headerlink\" title=\"文件输入输出流\"></a>文件输入输出流</h3><ol>\n<li><p>fstream ofstream ifstream</p>\n<pre><code> void open(const char *filename, ios::openmode mode);   //文件流对象的成员函数\n</code></pre><p> 打开模式</p>\n<ul>\n<li>ios::app    追加模式。所有写入都追加到文件末尾。</li>\n<li>ios::ate    文件打开后定位到文件末尾。</li>\n<li>ios::in    打开文件用于读取。</li>\n<li>ios::out    打开文件用于写入。</li>\n<li>ios::trunc    如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0。</li>\n<li><p>ios::binary   二进制方式打开，默认打开为文本方式</p>\n<p>常用函数</p>\n<p>  getline(cin, string);   //当然也可以是 fileOgject从文件 ，cin是从键盘  好用 但是可能读取不到最后一行，如果最后一行没有回车<br>  fileObject.getline(buf, size);</p>\n</li>\n</ul>\n</li>\n<li><p>文件位置 istream成员函数seekg  ostream成员函数seekp</p>\n<pre><code> fileObject.seekg(n);    //定位到第n个字节    \n fileObject.seekg(n, ios::cur);    //当前位置后移n字节\n fileObject.seekg(n, ios::end);    //末尾向前n字节\n fileObject.seekg(0, ios::end);    //末尾\n</code></pre></li>\n<li><p>cin.ignore(),默认参数cin.ignore(1,EOF),完整版本是 cin.ignore(int n, char a)<br>从输入流 (cin) 中提取字符，提取的字符被忽略 (ignore)，不被使用。<br>每抛弃一个字符，它都要计数和比较字符：如果计数值达到 n 或者被抛弃的字符是 a，<br>则 cin.ignore()函数执行终止；否则，它继续等待。<br>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，<br>消除上一次输入对下一次输入的影响。比如可以这么用：cin.ignore(1024,’\\n’)，<br>通常把第一个参数设置得足够大，这样实际上总是只有第二个参数 \\n 起作用，<br>所以这一句就是把回车(包括回车)之前的所以字符从输入缓冲(流)中清除出去。</p>\n<pre><code> int a,b;\n cout&lt;&lt;&quot;input a:&quot;;\n cin&gt;&gt;a;\n cin.ignore(1024, &#39;\\n&#39;);\n cout&lt;&lt;&quot;input b:&quot;;\n cin&gt;&gt;b;\n</code></pre></li>\n</ol>\n<h3 id=\"字符串输入输出流\"><a href=\"#字符串输入输出流\" class=\"headerlink\" title=\"字符串输入输出流\"></a>字符串输入输出流</h3><p><sstream>直接对内存而不是对文件和标准输出(设备)进行操作</sstream></p>\n<p>stringstream istringstream   ostringstream<br>同样可以使用seekp()移动写指针 seekg()重定位读指针</p>\n<pre><code>//整数转字符串\n#include &lt;sstream&gt;\n\nstd::ostringstream oss;\nint name_suffix = 1;\noss &lt;&lt; name_suffix;\noss.str();       //返回一个新的string对象，替换内置的stringbuf\n\n// 设置输出精度,cout默认是6位有效数字\ncout.precision(12); //设置为12位有效数字\nprintf(&quot;%.12f&quot;,val);  //小数点后12位有效数字  \n</code></pre><h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><ol>\n<li><p>抛出异常<br> 关键字throw将创建程序抛出对象的拷贝,然后包含throw的函数返回了这个对象(即使函数返回值没有这个对象),<br> 异常导致程序返回的地方和正常return返回的地方不一样.异常发生之前创建的局部对象也将析构(栈反解)</p>\n<pre><code> throw &quot;Division by zero condition!&quot;;   //类型为const char* 的异常 catch(const char* msg)\n try{throw x;}catch(T&amp; e){}   //可以抛出任意,包括内置类型 int,double...,后面用相应的类型来捕获.通常抛出异常创建的类    \n</code></pre></li>\n<li><p>捕获异常:<br> <strong>异常处理器catch必须紧跟try之后,catch只会匹配第一个</strong>,然后系统认为此异常已经处理了,不会继续查找下去,如果还想在抛,就必须throw</p>\n<p> 如果没有任何一个层次的异常处理器匹配到异常,terminate()函数调用,在<exception>内,</exception></p>\n<pre><code> try\n {\n    // 保护代码\n }catch( ExceptionName e )    //捕获任何异常  (...)\n {\n   // 处理 ExceptionName 异常的代码\n   throw;  //可以选择继续上抛,但是要保证这个throw仍然在try语句中(可以是上一层函数的try) 异常对象的所有信息被保留\n }\n</code></pre><p> <img src=\"/2019/10/06/c++记录/异常图.png\" alt=\"异常层次图\"><br> <img src=\"/2019/10/06/c++记录/异常表.png\" alt=\"异常说明\"></p>\n</li>\n<li>异常安全<br> stack的pop()函数没有返回值,很重要的原因就是stack必须保证异常安全,如果为了得到返回值而调用复制构造函数,函数确抛出异常<br> 导致没有获得栈顶元素,而且栈定指针下移了一个,这是不安全的,所以分成两步.        </li>\n<li>assert() 断言语句 用于开发阶段调试 #define NDEBUG 使其在最终发行软件中失效</li>\n<li><p>定义自己的异常 最好从runtime_error或者logic_error继承(exception两个最主要的派生类)<br>不要直接从exception继承(没有提供一个参数类型为std::string的构造函数)</p>\n<pre><code> class MyError : public runtime_error{\n public:\n     MyError(const string&amp; msg = &quot;&quot;) : runtime_error(msg){}\n };\n\n int main(){\n     try{\n         throw MyError(&quot;my message&quot;);\n     } catch (MyError &amp; x){\n         cout&lt;&lt; x.what()&lt;&lt;endl;\n     }\n } \n</code></pre><h3 id=\"异常的使用\"><a href=\"#异常的使用\" class=\"headerlink\" title=\"异常的使用\"></a>异常的使用</h3></li>\n<li>尽量使用引用来捕获异常<ul>\n<li>避免不必要的对象拷贝</li>\n<li>派生类对象被当做基类对象捕获时,避免对象切割,损失信息</li>\n</ul>\n</li>\n<li>构造函数抛出异常时,必须注意对象内部的指针和它的清理方式</li>\n<li>不要在析构函数中抛出异常<ul>\n<li>析构函数会在抛出其他异常的过程中别调用,避免析构函数抛出异常或者使用可能触发异常的语句(栈反解),导致程序调用teminate()</li>\n<li>如果析构函数可能抛出异常,在析构函数内部编写try,catch,必须自己处理异常,不能抛出</li>\n</ul>\n</li>\n<li>避免悬挂指针(野指针)<br> 构造函数抛出异常,而内部又有指针,因为指针没有析构函数,造成资源无法释放,可以使用智能指针,shared_ptr来处理指向堆内存的指针</li>\n<li>处理简单错误尽量不用异常处理,只需要显示消息然后退出程序就可以了,然后把清理工作交给操作系统<br> cout&lt;&lt;”error message”&lt;&lt;endl;exit(1);             </li>\n</ol>\n<h3 id=\"exit函数\"><a href=\"#exit函数\" class=\"headerlink\" title=\"exit函数\"></a>exit函数</h3><pre><code>void exit(int value);  // 位于&lt;cstdlib&gt;中\nexit(0);  //表示正常退出 退出整个进程.main函数要求返回值为int,在main中的exit相当于return\n</code></pre><h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><ul>\n<li>转换很有用，但是在某些情况下，它强制编译器把一个数据看成比他实际更大的类型，占用更多空间，可能会破坏其他数据</li>\n<li>转换就是告诉编译器”忘记类型检查　把它看成其他类型”　编译器不会执行类型检查　引入了漏洞，程序出了问题，首先想到类型转换</li>\n</ul>\n<p>查看变量类型</p>\n<pre><code>#include &lt;typeinfo&gt;\nstd::cout&lt;&lt;typeid(var).name()&lt;&lt;std::endl;\n</code></pre><ol>\n<li><p>C风格</p>\n<pre><code> int a = 200;\n long b = (long)a;\n long c = long(a);  //类似于函数调用\n</code></pre></li>\n<li><p>c++显式转换<br>比较容易发现转换的位置，定位bug</p>\n<p> static_cast</p>\n<pre><code> int a = 200;\n long b = static_cast&lt;long&gt;(a);  //\n static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged);  //qt 函数指针\n</code></pre><p> const_cast   const 到非const volatile 到非volatile</p>\n<pre><code> const int i=0;\n int* j = const_cast&lt;int*&gt;(&amp;i);   // 不用转换是不能将赋值给非const指针\n\n volatile int k=0;\n int* u = const_cast&lt;int*&gt;(&amp;k);     \n</code></pre></li>\n</ol>\n<h2 id=\"继承和组合\"><a href=\"#继承和组合\" class=\"headerlink\" title=\"继承和组合\"></a>继承和组合</h2><ol>\n<li><p>构造函数初始化列表<br>针对问题：新类的构造函数没有权利访问子对象的私有数据成员，所以不能直接对他们初始化</p>\n<pre><code> //Bar是基类，m是MyType的一个成员对象\n MyType::MyType(int i): Bar(i),m(i+1){//...}\n</code></pre></li>\n</ol>\n<ul>\n<li>自动析构函数调用：虽然常常需要在初始化列表中显式构造函数调用，但是不需要做显式的析构函数调用，因为对于任何类型只有一个析构函数，并且不屈任何参数</li>\n<li>构造函数调用次序是由成员对象在类中声明的次序决定。如果由　初始化列表的次序确定，则会有两个不同构造函数有两种不同调用构造函数顺序，那么析构函数不知道如何逆序调用。</li>\n</ul>\n<h2 id=\"随机数发生器\"><a href=\"#随机数发生器\" class=\"headerlink\" title=\"随机数发生器\"></a>随机数发生器</h2><pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\n// time(0) 返回一个和时间相关的的数作为随机数种子,如果不设置或者设置一样的数那么运行产生的随机数都一样\nsrand(time(0));   \nrand();           // 获取随机数 线性同余法 不是真的随机数 N(j+1) = (A*N(j)+B)(mod M)\n</code></pre><p><a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">线性同余法</a> </p>\n<h2 id=\"待续…\"><a href=\"#待续…\" class=\"headerlink\" title=\"待续…\"></a><strong>待续…</strong></h2><h2 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h2><h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><h2 id=\"预处理器\"><a href=\"#预处理器\" class=\"headerlink\" title=\"预处理器\"></a>预处理器</h2><h2 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h2><h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h1 id=\"const-constexpr\"><a href=\"#const-constexpr\" class=\"headerlink\" title=\"const constexpr\"></a>const constexpr</h1><ul>\n<li>const：大致意思是说我承诺不改变这个值，主要用于说明接口，这样变量传递给函数就不担心变量会在函数内被修改了,编译器负责确认并执行const的承诺。</li>\n<li>constexpr：大致意思是在编译时求值，主要用于说明常量，作用是允许数据置于只读内存以及提升性能。</li>\n</ul>\n<p>constexpr的好处：</p>\n<ul>\n<li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li>\n<li>编译器可以在编译期对constexpr的代码进行非常大的优化，比如将用到的constexpr表达式都直接替换成最终结果等。</li>\n<li>相比宏来说，没有额外的开销，但更安全可靠。</li>\n</ul>\n<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><ol>\n<li><p>不同vector 的iterator不能混用</p>\n<p> 迭代器(Iterator)是一个对象，它的工作是遍历并选择序列中的对象，<br> 它提供了一种访问一个容器(container)对象中的各个元素，<br> 而又不必暴露该对象内部细节的方法。通过迭代器，<br> 开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。</p>\n<p> 指针用来遍历<strong>连续存储结构</strong>,迭代器针对容器(不管底层数据结构是否连续),提供堆容器遍历的方法</p>\n<p> 下面这种方式出错,不能简单得把iterator当成一个索引      </p>\n<pre><code> vector&lt;int&gt;::iterator index_vec_1 = find(vec_1.begin(), vec_1.end(), val);\n //出错\n vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), index_vec_1);  \n // 正确\n vector&lt;int&gt;::iterator vec_1_new(vec_1.begin(), index_vec_1);\n vector&lt;int&gt;::iterator vec_2_new(vec_2.begin(), vec_1_new.size());\n</code></pre></li>\n</ol>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><a href=\"https://blog.csdn.net/Bruce_0712/article/details/54984371\" target=\"_blank\" rel=\"noopener\">C++之enum枚举量声明、定义、使用与枚举类详解</a></li>\n<li><a href=\"https://www.runoob.com/cplusplus/cpp-tutorial.html\" target=\"_blank\" rel=\"noopener\">C++ 教程</a></li>\n<li><a href=\"https://blog.csdn.net/zyx_0604/article/details/80689673\" target=\"_blank\" rel=\"noopener\">C++中volatile关键字的使用详解</a></li>\n<li><a href=\"https://www.cnblogs.com/yyxt/p/4802688.html\" target=\"_blank\" rel=\"noopener\">c++中static数据成员，static成员函数</a></li>\n<li><a href=\"https://blog.csdn.net/iloveyousunna/article/details/78532398\" target=\"_blank\" rel=\"noopener\">c++中lambda表达式的用法</a></li>\n<li><a href=\"https://blog.csdn.net/bxw1992/article/details/77726390\" target=\"_blank\" rel=\"noopener\">C++中虚继承的作用及底层实现原理</a></li>\n<li><a href=\"https://blog.csdn.net/qq_22274565/article/details/78719951\" target=\"_blank\" rel=\"noopener\">关于constexpr与const</a></li>\n<li><a href=\"https://www.cnblogs.com/wodehao0808/p/3623590.html\" target=\"_blank\" rel=\"noopener\">C++中的const和constexpr</a></li>\n<li><a href=\"https://blog.csdn.net/Dove_Knowledge/article/details/71023512?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task\" target=\"_blank\" rel=\"noopener\">迭代器(Iterator)</a></li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/QT坐标系统/coordinate.png","slug":"coordinate.png","post":"ckhub3chd000fmxka9lofpi4t","modified":0,"renderable":0},{"_id":"source/_posts/mathtype常用配置/mathtype.png","slug":"mathtype.png","post":"ckhub3chn001emxkaevspo4pi","modified":0,"renderable":0},{"_id":"source/_posts/vim常用命令/Vim.png","slug":"Vim.png","post":"ckhub3chz002omxkaevcb8bfo","modified":0,"renderable":0},{"_id":"source/_posts/多系统启动盘制作/WinSetup.png","slug":"WinSetup.png","post":"ckhub3ci20031mxka2ev4dsyb","modified":0,"renderable":0},{"_id":"source/_posts/拉氏变换/卷积.png","slug":"卷积.png","post":"ckhub3cia003mmxkahsjoc7f5","modified":0,"renderable":0},{"_id":"source/_posts/理解补码/fanma.png","slug":"fanma.png","post":"ckhub3cih0042mxkawbhb9iat","modified":0,"renderable":0},{"_id":"source/_posts/科式加速度/科式加速度.png","slug":"科式加速度.png","post":"ckhub3cin004hmxkaokeeztjd","modified":0,"renderable":0},{"_id":"source/_posts/Linux-Qt5-ROS配置Qwtplot3d/simpleplot.png","slug":"simpleplot.png","post":"ckhub3ch60006mxka5dgtb46g","modified":0,"renderable":0},{"_id":"source/_posts/Linux-Qt5-ROS配置Qwtplot3d/simpleplot_mult.png","slug":"simpleplot_mult.png","post":"ckhub3ch60006mxka5dgtb46g","modified":0,"renderable":0},{"_id":"source/_posts/python基础/OPGL_pointcloud.pdf","slug":"OPGL_pointcloud.pdf","post":"ckhub3chv0028mxka61w33g3w","modified":0,"renderable":0},{"_id":"source/_posts/python基础/matrix_multiply.png","slug":"matrix_multiply.png","post":"ckhub3chv0028mxka61w33g3w","modified":0,"renderable":0},{"_id":"source/_posts/word参考文献交叉引用/插入.png","slug":"插入.png","post":"ckhub3ci0002rmxkanroefcq7","modified":0,"renderable":0},{"_id":"source/_posts/word参考文献交叉引用/隐藏.png","slug":"隐藏.png","post":"ckhub3ci0002rmxkanroefcq7","modified":0,"renderable":0},{"_id":"source/_posts/word排版/中文字号.png","slug":"中文字号.png","post":"ckhub3ci30034mxkaph6pv29m","modified":0,"renderable":0},{"_id":"source/_posts/word排版/导出样式.png","slug":"导出样式.png","post":"ckhub3ci30034mxkaph6pv29m","modified":0,"renderable":0},{"_id":"source/_posts/实用小技巧汇总/切换对话关.png","slug":"切换对话关.png","post":"ckhub3ci40036mxka9v6gi8ab","modified":0,"renderable":0},{"_id":"source/_posts/实用小技巧汇总/切换对话开.png","slug":"切换对话开.png","post":"ckhub3ci40036mxka9v6gi8ab","modified":0,"renderable":0},{"_id":"source/_posts/根轨迹/close-loop.png","slug":"close-loop.png","post":"ckhub3cif003zmxkacbfocpiu","modified":0,"renderable":0},{"_id":"source/_posts/根轨迹/measureing phase.png","slug":"measureing phase.png","post":"ckhub3cif003zmxkacbfocpiu","modified":0,"renderable":0},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/pose.jpg","slug":"pose.jpg","post":"ckhub3ci0002umxka1rfs3mu4","modified":0,"renderable":0},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/xyz固定角.png","slug":"xyz固定角.png","post":"ckhub3ci0002umxka1rfs3mu4","modified":0,"renderable":0},{"_id":"source/_posts/位姿变换矩阵左乘和右乘理解/zyx欧拉角.png","slug":"zyx欧拉角.png","post":"ckhub3ci0002umxka1rfs3mu4","modified":0,"renderable":0},{"_id":"source/_posts/高斯分布/条件边缘.png","slug":"条件边缘.png","post":"ckhub3cjp0079mxkay3d9n215","modified":0,"renderable":0},{"_id":"source/_posts/高斯分布/高斯分布.png","slug":"高斯分布.png","post":"ckhub3cjp0079mxkay3d9n215","modified":0,"renderable":0},{"_id":"source/_posts/shell和下载工具/delete_replace.png","slug":"delete_replace.png","post":"ckhub3cjh006xmxka01n2h5zb","modified":0,"renderable":0},{"_id":"source/_posts/shell和下载工具/var_test.png","slug":"var_test.png","post":"ckhub3cjh006xmxka01n2h5zb","modified":0,"renderable":0},{"_id":"source/_posts/shell和下载工具/文件测试.png","slug":"文件测试.png","post":"ckhub3cjh006xmxka01n2h5zb","modified":0,"renderable":0},{"_id":"source/_posts/雅克比矩阵零空间/Redundancy-19.pdf","slug":"Redundancy-19.pdf","post":"ckhub3cjm0073mxka16di8yew","modified":0,"renderable":0},{"_id":"source/_posts/雅克比矩阵零空间/redundancy.png","slug":"redundancy.png","post":"ckhub3cjm0073mxka16di8yew","modified":0,"renderable":0},{"_id":"source/_posts/雅克比矩阵零空间/velocity_force.png","slug":"velocity_force.png","post":"ckhub3cjm0073mxka16di8yew","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/IPHead.png","slug":"IPHead.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/IPSection.png","slug":"IPSection.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/OSI_TCPIP.png","slug":"OSI_TCPIP.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/Subnet.png","slug":"Subnet.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/Supernet.png","slug":"Supernet.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/TCPHead.png","slug":"TCPHead.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/TCPIPdata.png","slug":"TCPIPdata.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/TCPIPfamily.png","slug":"TCPIPfamily.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/TCPTrans.png","slug":"TCPTrans.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/UDPHead.png","slug":"UDPHead.png","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/网络基础/csmacd.gif","slug":"csmacd.gif","post":"ckhub3cjk0071mxka4uewjewh","modified":0,"renderable":0},{"_id":"source/_posts/逆运动学/iksurvey.pdf","slug":"iksurvey.pdf","post":"ckhub3ckj007pmxkalggkkn0f","modified":0,"renderable":0},{"_id":"source/_posts/逆运动学/niudun.png","slug":"niudun.png","post":"ckhub3ckj007pmxkalggkkn0f","modified":0,"renderable":0},{"_id":"source/_posts/c++记录/异常图.png","slug":"异常图.png","post":"ckhub3ckk007qmxka2mzpc0lz","modified":0,"renderable":0},{"_id":"source/_posts/c++记录/异常表.png","slug":"异常表.png","post":"ckhub3ckk007qmxka2mzpc0lz","modified":0,"renderable":0},{"_id":"source/_posts/c++记录/运算符优先级.png","slug":"运算符优先级.png","post":"ckhub3ckk007qmxka2mzpc0lz","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckhub3ch50005mxkaxclpyb3o","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chc000cmxkagpba3f8h"},{"post_id":"ckhub3cgx0000mxkaf3s8hlax","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chd000gmxka47ydxy22"},{"post_id":"ckhub3ch60006mxka5dgtb46g","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3che000imxkaxv6ti2oe"},{"post_id":"ckhub3ch10001mxkawuxqkd4l","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chf000mmxkawj0yoo70"},{"post_id":"ckhub3ch40004mxka64elno8d","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chg000omxkaqznsz849"},{"post_id":"ckhub3cha000amxkalkzlp26a","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chi000vmxkaw6l6nn2c"},{"post_id":"ckhub3chf000nmxka4kbkpmhp","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chj000zmxkaiy26o09h"},{"post_id":"ckhub3chg000rmxkal1d8gle1","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chk0013mxkanje3am6v"},{"post_id":"ckhub3chc000bmxkadyz6g5e5","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chl0016mxka21jd0xcc"},{"post_id":"ckhub3chh000tmxkac3qla6cx","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chl0019mxkapjliilq2"},{"post_id":"ckhub3chi000xmxkae3typ3hf","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chm001cmxkar5c3rcwb"},{"post_id":"ckhub3chd000fmxka9lofpi4t","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3cho001fmxkakp8rhzax"},{"post_id":"ckhub3chj0011mxka09m5da3b","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chp001imxkajby56edc"},{"post_id":"ckhub3chk0015mxkamwj7t9mf","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chq001nmxka3bcjz2g5"},{"post_id":"ckhub3che000hmxka1ed4kpp4","category_id":"ckhub3chk0012mxkac3lklj2b","_id":"ckhub3chr001qmxkavyegpkp0"},{"post_id":"ckhub3chl0018mxkamv03updi","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chs001vmxkacu61g5z8"},{"post_id":"ckhub3chm001bmxkaa5k9sx7b","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3cht001ymxkawq1a6bae"},{"post_id":"ckhub3che000lmxka2shdrq9u","category_id":"ckhub3chk0012mxkac3lklj2b","_id":"ckhub3chu0023mxka3mqugv9o"},{"post_id":"ckhub3chp001mmxkacu8hlc5r","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chu0026mxka4c2n4nst"},{"post_id":"ckhub3chq001pmxkaz0j6pcde","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chv0029mxkaovojeg1d"},{"post_id":"ckhub3chn001emxkaevspo4pi","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3chw002dmxkas5z7gp32"},{"post_id":"ckhub3chs001xmxkaqr37av3r","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chx002gmxka1z1z9q0r"},{"post_id":"ckhub3cho001hmxka9f0pz0ty","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3chy002kmxkadr34pqut"},{"post_id":"ckhub3cht0020mxkau4a7qj39","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3chz002mmxkan8fld7pf"},{"post_id":"ckhub3chu0025mxkaxh5bkq54","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3chz002pmxkal5o6ew0z"},{"post_id":"ckhub3chr001smxka83d7ik25","category_id":"ckhub3cht0021mxka20xbr4qj","_id":"ckhub3ci0002smxkar92oylx3"},{"post_id":"ckhub3chv0028mxka61w33g3w","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3ci1002vmxkaa08a8wbj"},{"post_id":"ckhub3chw002cmxka778ra8ds","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3ci2002ymxkasa77glwx"},{"post_id":"ckhub3chx002fmxkawziznvsq","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ci30032mxka1dazsgll"},{"post_id":"ckhub3chx002imxkapwsvsge2","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ci30035mxka9btb5mr7"},{"post_id":"ckhub3chy002lmxka5721t0nb","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ci50039mxkaew6ckw2v"},{"post_id":"ckhub3chz002omxkaevcb8bfo","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ci5003cmxkatxvvj56y"},{"post_id":"ckhub3ci0002rmxkanroefcq7","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3ci7003emxka29m93ln4"},{"post_id":"ckhub3ci1002xmxkab34xz8h6","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ci8003imxkazed2ky1x"},{"post_id":"ckhub3ci30034mxkaph6pv29m","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3ci9003kmxka5gcbijzy"},{"post_id":"ckhub3ci0002umxka1rfs3mu4","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cib003nmxkaovl2ewg3"},{"post_id":"ckhub3ci40036mxka9v6gi8ab","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3cic003qmxkad21xgp86"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3cid003umxkakbicn6wl"},{"post_id":"ckhub3ci20031mxka2ev4dsyb","category_id":"ckhub3ci40037mxkahmpl4q0r","_id":"ckhub3cie003xmxka5md325no"},{"post_id":"ckhub3ci6003dmxkalja31e75","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cig0040mxkar2qzz5y1"},{"post_id":"ckhub3ci7003gmxkahejzzej8","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cih0043mxka5nolyzft"},{"post_id":"ckhub3ci8003jmxkauftjrn6x","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3cij0047mxkaar2qiin6"},{"post_id":"ckhub3cia003mmxkahsjoc7f5","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cik004amxkakn581oil"},{"post_id":"ckhub3cib003pmxkatxvig2qj","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3cil004cmxka46c8hxbs"},{"post_id":"ckhub3cic003tmxka30tuhgkj","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3cin004gmxka9ltglyxl"},{"post_id":"ckhub3cid003wmxkaw1be2i4s","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cio004imxkak0g5l8ug"},{"post_id":"ckhub3cif003zmxkacbfocpiu","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cip004lmxkacadqmtnw"},{"post_id":"ckhub3cih0042mxkawbhb9iat","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3ciq004nmxkapvbr5vn5"},{"post_id":"ckhub3cii0045mxka3wqy8yxi","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3ciq004pmxkaktvkjchy"},{"post_id":"ckhub3cij0049mxkakp7mtyv2","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ciq004rmxka3jizrf9s"},{"post_id":"ckhub3cik004bmxkab9oplzb9","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3ciq004tmxkackg7o5tf"},{"post_id":"ckhub3cim004emxkavd2xf8yc","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cir004vmxkar9n7kffa"},{"post_id":"ckhub3cin004hmxkaokeeztjd","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cir004wmxka7e8ur2h1"},{"post_id":"ckhub3cip004kmxka3d1sdzak","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3cir004zmxkajno2ybae"},{"post_id":"ckhub3cjf006vmxka4erdw0bm","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3cjl0072mxka1a4bvj2o"},{"post_id":"ckhub3cjh006xmxka01n2h5zb","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3cjn0074mxkace0l2mva"},{"post_id":"ckhub3cji006zmxka2wwrgn9e","category_id":"ckhub3ch20002mxkav3a8q08b","_id":"ckhub3cjo0078mxkaptto72c4"},{"post_id":"ckhub3cjm0073mxka16di8yew","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3cjq007amxkaxfcffqvk"},{"post_id":"ckhub3cjn0076mxkaac491axk","category_id":"ckhub3chp001kmxkafrc1by68","_id":"ckhub3ck6007dmxkaleef905o"},{"post_id":"ckhub3cjp0079mxkay3d9n215","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3ck6007fmxkad3cpynvr"},{"post_id":"ckhub3cjk0071mxka4uewjewh","category_id":"ckhub3cjn0075mxka9hpxk9ps","_id":"ckhub3ck7007imxka1zzitf16"},{"post_id":"ckhub3ckj007pmxkalggkkn0f","category_id":"ckhub3ci2002zmxka5ft2fmhq","_id":"ckhub3ckl007tmxkayt0mj6qq"},{"post_id":"ckhub3ckk007qmxka2mzpc0lz","category_id":"ckhub3che000jmxkatxdef798","_id":"ckhub3ckm007umxkagaxwvjfp"}],"PostTag":[{"post_id":"ckhub3cgx0000mxkaf3s8hlax","tag_id":"ckhub3ch30003mxkab0hvua9o","_id":"ckhub3cha0009mxkaj5izj3hn"},{"post_id":"ckhub3ch10001mxkawuxqkd4l","tag_id":"ckhub3ch70008mxka4u0eyak9","_id":"ckhub3chh000smxka1pdv55s1"},{"post_id":"ckhub3ch10001mxkawuxqkd4l","tag_id":"ckhub3chd000emxkaq0k54yku","_id":"ckhub3chi000wmxkauanal0yz"},{"post_id":"ckhub3ch10001mxkawuxqkd4l","tag_id":"ckhub3che000kmxka4qfu75dj","_id":"ckhub3chj0010mxkak9l4pbv7"},{"post_id":"ckhub3ch40004mxka64elno8d","tag_id":"ckhub3chg000qmxkadf4cjfve","_id":"ckhub3chk0014mxkase27pecg"},{"post_id":"ckhub3ch60006mxka5dgtb46g","tag_id":"ckhub3chj000ymxkady13kdwn","_id":"ckhub3cho001gmxkajxnnt2vb"},{"post_id":"ckhub3ch60006mxka5dgtb46g","tag_id":"ckhub3chl0017mxkaa3p5vczr","_id":"ckhub3chp001jmxkatfeqe9va"},{"post_id":"ckhub3cha000amxkalkzlp26a","tag_id":"ckhub3chm001dmxka3hia9uor","_id":"ckhub3chq001omxka9yqlqusy"},{"post_id":"ckhub3cha000amxkalkzlp26a","tag_id":"ckhub3ch70008mxka4u0eyak9","_id":"ckhub3chr001rmxkaw2337ve8"},{"post_id":"ckhub3chc000bmxkadyz6g5e5","tag_id":"ckhub3chp001lmxka2iz683x0","_id":"ckhub3chs001wmxkav4orgcg1"},{"post_id":"ckhub3chr001smxka83d7ik25","tag_id":"ckhub3ch70008mxka4u0eyak9","_id":"ckhub3cht001zmxkaevo8il2i"},{"post_id":"ckhub3chs001xmxkaqr37av3r","tag_id":"ckhub3chp001lmxka2iz683x0","_id":"ckhub3chu0024mxkatzasd285"},{"post_id":"ckhub3chd000fmxka9lofpi4t","tag_id":"ckhub3chp001lmxka2iz683x0","_id":"ckhub3chv0027mxka23big80o"},{"post_id":"ckhub3chu0025mxkaxh5bkq54","tag_id":"ckhub3chd000emxkaq0k54yku","_id":"ckhub3chw002bmxka0r94p2ie"},{"post_id":"ckhub3che000hmxka1ed4kpp4","tag_id":"ckhub3cht0022mxkafjun9v5d","_id":"ckhub3chw002emxka1shlm2z6"},{"post_id":"ckhub3che000lmxka2shdrq9u","tag_id":"ckhub3chl0017mxkaa3p5vczr","_id":"ckhub3chy002jmxkafdopbesz"},{"post_id":"ckhub3chf000nmxka4kbkpmhp","tag_id":"ckhub3chx002hmxkax19jot3g","_id":"ckhub3chz002qmxkabut9k439"},{"post_id":"ckhub3chg000rmxkal1d8gle1","tag_id":"ckhub3chz002nmxka3lq29a2w","_id":"ckhub3ci1002wmxkavh2t10uf"},{"post_id":"ckhub3chh000tmxkac3qla6cx","tag_id":"ckhub3chz002nmxka3lq29a2w","_id":"ckhub3ci30033mxkayfwz8sqw"},{"post_id":"ckhub3chi000xmxkae3typ3hf","tag_id":"ckhub3ci20030mxkarhn0wh5v","_id":"ckhub3ci5003amxkazanpzwru"},{"post_id":"ckhub3chj0011mxka09m5da3b","tag_id":"ckhub3ci40038mxka3p15jnm7","_id":"ckhub3ci8003hmxka0kx8gm4k"},{"post_id":"ckhub3chk0015mxkamwj7t9mf","tag_id":"ckhub3che000kmxka4qfu75dj","_id":"ckhub3cib003omxkawi7emxm5"},{"post_id":"ckhub3chk0015mxkamwj7t9mf","tag_id":"ckhub3ch70008mxka4u0eyak9","_id":"ckhub3cic003rmxkanujdubc8"},{"post_id":"ckhub3chk0015mxkamwj7t9mf","tag_id":"ckhub3ci7003fmxkasok32bdd","_id":"ckhub3cid003vmxkaj02i9fh7"},{"post_id":"ckhub3chl0018mxkamv03updi","tag_id":"ckhub3chz002nmxka3lq29a2w","_id":"ckhub3cih0041mxka4vzmlhxm"},{"post_id":"ckhub3chl0018mxkamv03updi","tag_id":"ckhub3cic003smxkaz8rm9ol1","_id":"ckhub3cii0044mxka9g106jmq"},{"post_id":"ckhub3chm001bmxkaa5k9sx7b","tag_id":"ckhub3cif003ymxkakjuagz9v","_id":"ckhub3cij0048mxka5bthgrz1"},{"post_id":"ckhub3chn001emxkaevspo4pi","tag_id":"ckhub3cij0046mxkannirm004","_id":"ckhub3cin004fmxkah29mv7we"},{"post_id":"ckhub3cho001hmxka9f0pz0ty","tag_id":"ckhub3cil004dmxkaod1bl0nc","_id":"ckhub3cip004mmxka8m7rb0s0"},{"post_id":"ckhub3chp001mmxkacu8hlc5r","tag_id":"ckhub3cio004jmxka67mvy54y","_id":"ckhub3ciq004qmxkay7oswmpx"},{"post_id":"ckhub3chq001pmxkaz0j6pcde","tag_id":"ckhub3ciq004omxkaixj9z5mm","_id":"ckhub3cir004umxkaxfc8it18"},{"post_id":"ckhub3cht0020mxkau4a7qj39","tag_id":"ckhub3ciq004smxkam0sfo2lp","_id":"ckhub3cir004ymxka1t9q5908"},{"post_id":"ckhub3chv0028mxka61w33g3w","tag_id":"ckhub3cio004jmxka67mvy54y","_id":"ckhub3cis0051mxkafqikhuyx"},{"post_id":"ckhub3chw002cmxka778ra8ds","tag_id":"ckhub3cil004dmxkaod1bl0nc","_id":"ckhub3cis0053mxka6ecy1rrd"},{"post_id":"ckhub3chx002fmxkawziznvsq","tag_id":"ckhub3cis0052mxkajs9z1idl","_id":"ckhub3cit0056mxkadrgndm2g"},{"post_id":"ckhub3chx002fmxkawziznvsq","tag_id":"ckhub3cis0054mxkacbu1linl","_id":"ckhub3cit0057mxkamria4ros"},{"post_id":"ckhub3chx002imxkapwsvsge2","tag_id":"ckhub3cis0055mxkarba59pwp","_id":"ckhub3cit0059mxkaizvs3un8"},{"post_id":"ckhub3chy002lmxka5721t0nb","tag_id":"ckhub3cit0058mxkaznqsm23o","_id":"ckhub3cit005bmxkaxqefhjzl"},{"post_id":"ckhub3chz002omxkaevcb8bfo","tag_id":"ckhub3cit005amxkabos0z5ns","_id":"ckhub3ciu005dmxkaqr0716p9"},{"post_id":"ckhub3ci0002rmxkanroefcq7","tag_id":"ckhub3cit005cmxkakvscc4yq","_id":"ckhub3ciu005fmxkamdwvr2sn"},{"post_id":"ckhub3ci0002umxka1rfs3mu4","tag_id":"ckhub3ciu005emxka0hkmp7wm","_id":"ckhub3ciu005imxkawp3j8v2l"},{"post_id":"ckhub3ci0002umxka1rfs3mu4","tag_id":"ckhub3ciu005gmxkakwx666lp","_id":"ckhub3civ005jmxkabpqq9w26"},{"post_id":"ckhub3ci1002xmxkab34xz8h6","tag_id":"ckhub3ciu005hmxkat8e9m5i9","_id":"ckhub3civ005lmxkar0nq9flo"},{"post_id":"ckhub3ci20031mxka2ev4dsyb","tag_id":"ckhub3civ005kmxka8nmep1k2","_id":"ckhub3civ005nmxkapr807qns"},{"post_id":"ckhub3ci30034mxkaph6pv29m","tag_id":"ckhub3civ005mmxkamwy7510q","_id":"ckhub3civ005pmxkae7uqsmh4"},{"post_id":"ckhub3ci40036mxka9v6gi8ab","tag_id":"ckhub3civ005omxkaptkoe1sv","_id":"ckhub3ciw005rmxka8an2v6gn"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","tag_id":"ckhub3ciw005qmxka053oahid","_id":"ckhub3cix005xmxkap7klkaai"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","tag_id":"ckhub3ciw005smxkabz13rnsj","_id":"ckhub3cix005ymxkarwrnuuup"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","tag_id":"ckhub3ciw005tmxka0xig79j1","_id":"ckhub3ciy0060mxkazyn5a0tw"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","tag_id":"ckhub3ciw005umxkayexa5bjt","_id":"ckhub3ciy0061mxkabnz8nw0g"},{"post_id":"ckhub3ci5003bmxkazy4jkhvd","tag_id":"ckhub3cix005vmxkagwe2lryf","_id":"ckhub3ciy0063mxkapuryova8"},{"post_id":"ckhub3ci6003dmxkalja31e75","tag_id":"ckhub3ciu005emxka0hkmp7wm","_id":"ckhub3ciy0064mxkaudc41pqy"},{"post_id":"ckhub3ci7003gmxkahejzzej8","tag_id":"ckhub3cix005zmxka9tratoz4","_id":"ckhub3ciy0066mxkaw72bcbk5"},{"post_id":"ckhub3ci8003jmxkauftjrn6x","tag_id":"ckhub3ciy0062mxkaronh0cx2","_id":"ckhub3ciz0067mxkajgm7w3bu"},{"post_id":"ckhub3cia003mmxkahsjoc7f5","tag_id":"ckhub3ciy0065mxkaq35q7yb8","_id":"ckhub3ciz0069mxkar6v31gah"},{"post_id":"ckhub3cib003pmxkatxvig2qj","tag_id":"ckhub3ciz0068mxkagq6yon25","_id":"ckhub3ciz006bmxkalbro4f0x"},{"post_id":"ckhub3cic003tmxka30tuhgkj","tag_id":"ckhub3ciz006amxkakil4cckn","_id":"ckhub3ciz006dmxkafkdbc5q6"},{"post_id":"ckhub3cid003wmxkaw1be2i4s","tag_id":"ckhub3ciz006cmxkavt9zmkt9","_id":"ckhub3cj0006fmxkafobw76c0"},{"post_id":"ckhub3cif003zmxkacbfocpiu","tag_id":"ckhub3ciz006emxkaij31givu","_id":"ckhub3cj0006hmxkab7h6xbg8"},{"post_id":"ckhub3cih0042mxkawbhb9iat","tag_id":"ckhub3cj0006gmxka9k3efpn2","_id":"ckhub3cj1006jmxkavjxkhezy"},{"post_id":"ckhub3cii0045mxka3wqy8yxi","tag_id":"ckhub3cj0006imxkag0lvfzki","_id":"ckhub3cj1006lmxkal4mce6dc"},{"post_id":"ckhub3cij0049mxkakp7mtyv2","tag_id":"ckhub3cj1006kmxkaofg8f5q7","_id":"ckhub3cj2006nmxkaiw8nj63i"},{"post_id":"ckhub3cik004bmxkab9oplzb9","tag_id":"ckhub3cj1006mmxkaizao03nf","_id":"ckhub3cj2006pmxkanx703nju"},{"post_id":"ckhub3cim004emxkavd2xf8yc","tag_id":"ckhub3ciz006cmxkavt9zmkt9","_id":"ckhub3cj2006rmxkayonasx7p"},{"post_id":"ckhub3cin004hmxkaokeeztjd","tag_id":"ckhub3cj2006qmxkakm6ad43n","_id":"ckhub3cj3006tmxka7ak58yit"},{"post_id":"ckhub3cip004kmxka3d1sdzak","tag_id":"ckhub3cj3006smxkapgghy45f","_id":"ckhub3cj3006umxka8ht3t0l2"},{"post_id":"ckhub3cjf006vmxka4erdw0bm","tag_id":"ckhub3chl0017mxkaa3p5vczr","_id":"ckhub3cji006ymxkaxmgl71cw"},{"post_id":"ckhub3cjp0079mxkay3d9n215","tag_id":"ckhub3ciz006cmxkavt9zmkt9","_id":"ckhub3ck6007cmxkazx5oxem3"},{"post_id":"ckhub3cjh006xmxka01n2h5zb","tag_id":"ckhub3cjk0070mxka3zs14uxn","_id":"ckhub3ck6007emxkav30ngy0i"},{"post_id":"ckhub3cjh006xmxka01n2h5zb","tag_id":"ckhub3cjo0077mxkadd4nmwgw","_id":"ckhub3ck7007hmxkal4p8321q"},{"post_id":"ckhub3cjk0071mxka4uewjewh","tag_id":"ckhub3cjq007bmxkaip7tbz8v","_id":"ckhub3ck7007jmxkaa5e7fxq1"},{"post_id":"ckhub3cjm0073mxka16di8yew","tag_id":"ckhub3ck6007gmxkaw6n6iqcl","_id":"ckhub3ck8007mmxkahsg9qjqj"},{"post_id":"ckhub3cjm0073mxka16di8yew","tag_id":"ckhub3ck7007kmxkaphznd11h","_id":"ckhub3ck8007nmxkaou9v0gqr"},{"post_id":"ckhub3cjn0076mxkaac491axk","tag_id":"ckhub3ck8007lmxkakbyp8tbr","_id":"ckhub3ck9007omxkaun1ydyf6"},{"post_id":"ckhub3ckk007qmxka2mzpc0lz","tag_id":"ckhub3chz002nmxka3lq29a2w","_id":"ckhub3ckl007smxkakzdzrqad"},{"post_id":"ckhub3ckj007pmxkalggkkn0f","tag_id":"ckhub3ckl007rmxkaodv1wldy","_id":"ckhub3ckm007vmxkami5ak7yp"}],"Tag":[{"name":"数据传输","_id":"ckhub3ch30003mxkab0hvua9o"},{"name":"blog","_id":"ckhub3ch70008mxka4u0eyak9"},{"name":"ssh","_id":"ckhub3chd000emxkaq0k54yku"},{"name":"hexo","_id":"ckhub3che000kmxka4qfu75dj"},{"name":"正则表达式","_id":"ckhub3chg000qmxkadf4cjfve"},{"name":"Qt","_id":"ckhub3chj000ymxkady13kdwn"},{"name":"ROS","_id":"ckhub3chl0017mxkaa3p5vczr"},{"name":"program","_id":"ckhub3chm001dmxka3hia9uor"},{"name":"qt","_id":"ckhub3chp001lmxka2iz683x0"},{"name":"NodeHandle","_id":"ckhub3cht0022mxkafjun9v5d"},{"name":"文件共享","_id":"ckhub3chx002hmxkax19jot3g"},{"name":"c++","_id":"ckhub3chz002nmxka3lq29a2w"},{"name":"gdb","_id":"ckhub3ci20030mxkarhn0wh5v"},{"name":"字符串","_id":"ckhub3ci40038mxka3p15jnm7"},{"name":"gitbook","_id":"ckhub3ci7003fmxkasok32bdd"},{"name":"c","_id":"ckhub3cic003smxkaz8rm9ol1"},{"name":"make","_id":"ckhub3cif003ymxkakjuagz9v"},{"name":"equation","_id":"ckhub3cij0046mxkannirm004"},{"name":"matlab","_id":"ckhub3cil004dmxkaod1bl0nc"},{"name":"python","_id":"ckhub3cio004jmxka67mvy54y"},{"name":"git","_id":"ckhub3ciq004omxkaixj9z5mm"},{"name":"mysql","_id":"ckhub3ciq004smxkam0sfo2lp"},{"name":"software","_id":"ckhub3cis0052mxkajs9z1idl"},{"name":"ubuntu","_id":"ckhub3cis0054mxkacbu1linl"},{"name":"grub","_id":"ckhub3cis0055mxkarba59pwp"},{"name":"wps","_id":"ckhub3cit0058mxkaznqsm23o"},{"name":"vim","_id":"ckhub3cit005amxkabos0z5ns"},{"name":"word","_id":"ckhub3cit005cmxkakvscc4yq"},{"name":"机器人学","_id":"ckhub3ciu005emxka0hkmp7wm"},{"name":"位姿变换","_id":"ckhub3ciu005gmxkakwx666lp"},{"name":"编码","_id":"ckhub3ciu005hmxkat8e9m5i9"},{"name":"重装系统","_id":"ckhub3civ005kmxka8nmep1k2"},{"name":"matlab绘图","_id":"ckhub3civ005mmxkamwy7510q"},{"name":"ps","_id":"ckhub3civ005omxkaptkoe1sv"},{"name":"快捷键","_id":"ckhub3ciw005qmxka053oahid"},{"name":"simulink","_id":"ckhub3ciw005smxkabz13rnsj"},{"name":"clion","_id":"ckhub3ciw005tmxka0xig79j1"},{"name":"world","_id":"ckhub3ciw005umxkayexa5bjt"},{"name":"excel","_id":"ckhub3cix005vmxkagwe2lryf"},{"name":"傅里叶变换","_id":"ckhub3cix005zmxka9tratoz4"},{"name":"多线程","_id":"ckhub3ciy0062mxkaronh0cx2"},{"name":"自动控制原理","_id":"ckhub3ciy0065mxkaq35q7yb8"},{"name":"sort","_id":"ckhub3ciz0068mxkagq6yon25"},{"name":"数据结构","_id":"ckhub3ciz006amxkakil4cckn"},{"name":"概率论","_id":"ckhub3ciz006cmxkavt9zmkt9"},{"name":"根轨迹","_id":"ckhub3ciz006emxkaij31givu"},{"name":"补码","_id":"ckhub3cj0006gmxka9k3efpn2"},{"name":"信号分析","_id":"ckhub3cj0006imxkag0lvfzki"},{"name":"权限","_id":"ckhub3cj1006kmxkaofg8f5q7"},{"name":"软硬件","_id":"ckhub3cj1006mmxkaizao03nf"},{"name":"加速度","_id":"ckhub3cj2006qmxkakm6ad43n"},{"name":"anaconda","_id":"ckhub3cj3006smxkapgghy45f"},{"name":"shell","_id":"ckhub3cjk0070mxka3zs14uxn"},{"name":"下载工具","_id":"ckhub3cjo0077mxkadd4nmwgw"},{"name":"网络基础","_id":"ckhub3cjq007bmxkaip7tbz8v"},{"name":"雅克比矩阵","_id":"ckhub3ck6007gmxkaw6n6iqcl"},{"name":"伪逆","_id":"ckhub3ck7007kmxkaphznd11h"},{"name":"efficiency","_id":"ckhub3ck8007lmxkakbyp8tbr"},{"name":"机器人","_id":"ckhub3ckl007rmxkaodv1wldy"}]}}